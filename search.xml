<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Apache2.4启用FastCGI+FPM</title>
    <url>/articles/apache24-enables-fastcgi-fpm/</url>
    <content><![CDATA[<p>由于有一个需求，希望前端请求后服务器可以直接返回，不用等待服务器端长时间的处理，查找一番发现PHP有fastcgi_finish_request()函数可以满足需求，但需要运行在FastCGI模式时,并且是需要PHP-FPM进程管理器才有这个功能。于是乎网上找了资料，发现没有比较完整的记录，折腾了一下午才搞掂，做个总结吧。</p>
<hr>
<a id="more"></a>

<h1 id="1-环境"><a href="#1-环境" class="headerlink" title="1.环境"></a>1.环境</h1><p>Ubuntu 18.04 64位<br>Apache2.4.29（apt自动挡安装）<br>PHP 7.2（apt自动挡安装）</p>
<hr>
<h2 id="2-过程"><a href="#2-过程" class="headerlink" title="2.过程"></a>2.过程</h2><h2 id="2-1-安装fastcgi"><a href="#2-1-安装fastcgi" class="headerlink" title="2.1.安装fastcgi"></a>2.1.安装fastcgi</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt install libapache2-mod-fcgid</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：对应的模块是mod_fcgid，网上搜到很多教程用的实际是mod_fastcgi，结果配置老是不对，版本的区别可以看<a href="https://www.javatang.com/archives/2010/01/07/3629356.html" title="Apache下FastCGI模块的众多版本">这里</a>。</strong></p>
</blockquote>
<h2 id="2-2-安装php-cgi、php-fpm"><a href="#2-2-安装php-cgi、php-fpm" class="headerlink" title="2.2.安装php-cgi、php-fpm"></a>2.2.安装php-cgi、php-fpm</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt install php-cgi</span><br><span class="line">$ sudo apt install php-fpm</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>DEBUG：php-fpm会开启多个php-cgi程序进行管理，需要安装php-cgi。</strong></p>
</blockquote>
<h2 id="2-3-启用模块"><a href="#2-3-启用模块" class="headerlink" title="2.3.启用模块"></a>2.3.启用模块</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo a2dismod php7.2</span><br><span class="line">$ sudo a2enmod fcgid</span><br><span class="line">$ sudo a2enmod proxy_fcgid</span><br></pre></td></tr></table></figure>
<blockquote>
<p>__DEBUG：mod_php7.2是内置进程管理器，需要关闭。安装php-fpm会加入/etc/apache2/conf-enabled/php7.2-fpm.conf，包含了mod_proxy_fcgi模块的设置，不需要额外设置。__</p>
</blockquote>
<h2 id="2-4-配置fcgid模块"><a href="#2-4-配置fcgid模块" class="headerlink" title="2.4.配置fcgid模块"></a>2.4.配置fcgid模块</h2><p>编辑/etc/apache2/mods-enabled/fcgid.conf，加入以下配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">&lt;IfModule</span> <span class="string">mod_fcgid.c&gt;</span></span><br><span class="line">  <span class="string">FcgidConnectTimeout</span> <span class="number">20</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Where to look for the php.ini file?</span></span><br><span class="line">  <span class="string">FcgidInitialEnv</span> <span class="string">PHPRC</span> <span class="string">/etc/php/7.2/fpm</span></span><br><span class="line">  <span class="comment"># Set PHP_FCGI_MAX_REQUESTS to greater than or equal to FcgidMaxRequestsPerProcess</span></span><br><span class="line">  <span class="comment"># to prevent php-cgi process from exiting before all requests completed</span></span><br><span class="line">  <span class="string">FcgidInitialEnv</span> <span class="string">PHP_FCGI_MAX_REQUESTS</span>      <span class="number">1000</span></span><br><span class="line">  <span class="comment"># Maximum requests a process should handle before it is terminated</span></span><br><span class="line">  <span class="string">FcgidMaxRequestsPerProcess</span>       <span class="number">1000</span></span><br><span class="line">  <span class="comment"># Maximum number of PHP processes</span></span><br><span class="line">  <span class="string">FcgidMaxProcesses</span>             <span class="number">5</span></span><br><span class="line">  <span class="comment"># Number of seconds of idle time before a php-cgi process is terminated</span></span><br><span class="line">  <span class="string">FcgidIOTimeout</span>             <span class="number">120</span></span><br><span class="line">  <span class="string">FcgidIdleTimeout</span>                <span class="number">120</span></span><br><span class="line">  <span class="comment">#Path to php-cgi</span></span><br><span class="line">  <span class="string">FcgidWrapper</span> <span class="string">/usr/bin/php-cgi</span> <span class="string">.php</span></span><br><span class="line">  <span class="comment"># Define the MIME-Type for &quot;.php&quot; files</span></span><br><span class="line">  <span class="string">AddType</span> <span class="string">application/x-httpd-php</span> <span class="string">.php</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&lt;IfModule</span> <span class="string">mod_mime.c&gt;</span></span><br><span class="line">    <span class="string">AddHandler</span> <span class="string">fcgid-script</span> <span class="string">.fcgi</span> <span class="string">.php</span></span><br><span class="line">  <span class="string">&lt;/IfModule&gt;</span></span><br><span class="line"><span class="string">&lt;/IfModule&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="2-5-配置目录权限"><a href="#2-5-配置目录权限" class="headerlink" title="2.5.配置目录权限"></a>2.5.配置目录权限</h2><p>编辑/etc/apache2/apche2.conf，给网址目录加上ExecCGI权限</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">&lt;Directory</span> <span class="string">/var/www&gt;</span></span><br><span class="line">  <span class="string">Options</span> <span class="string">-Indexes</span> <span class="string">+FollowSymLinks</span> <span class="string">+ExecCGI</span></span><br><span class="line">  <span class="string">AllowOverride</span> <span class="string">None</span></span><br><span class="line">  <span class="string">Require</span> <span class="string">all</span> <span class="string">granted</span></span><br><span class="line"><span class="string">&lt;/Directory&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：要执行FCGI脚本的要加上，否则可省略。</strong></p>
</blockquote>
<h2 id="2-6-重启apache2生效"><a href="#2-6-重启apache2生效" class="headerlink" title="2.6.重启apache2生效"></a>2.6.重启apache2生效</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo service apache2 restart</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>Apache2</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>ESPHome入门指引（伪）</title>
    <url>/articles/esphome-getting-started-guide-pseudo/</url>
    <content><![CDATA[<p>hassbian的三木大做了<a href="https://bbs.hassbian.com/thread-6628-1-2.html" title="[插件发布] [4月1日更新！！]斐讯DC1插座自制固件接入ha">斐讯DC1固件</a>，于是乎买了两个来玩玩，开始接触了ESPHome，折腾下来有了一些心得，写点东西总结总结吧。由于接触时间有限，理解不一定准确，仅供参考。</p>
<hr>
<a id="more"></a>
<h2 id="1-快速理解"><a href="#1-快速理解" class="headerlink" title="1. 快速理解"></a>1. 快速理解</h2><h3 id="1-1-刷固件三件套"><a href="#1-1-刷固件三件套" class="headerlink" title="1.1 刷固件三件套"></a>1.1 刷固件三件套</h3><p>以刷斐讯DC1固件为例，涉及三个项目。</p>
<ol>
<li>esphome<ul>
<li>项目地址：<a href="https://github.com/Samuel-0-0/esphome">https://github.com/Samuel-0-0/esphome</a></li>
<li>作用：基于python的ESPHome管理工具，负责编译、烧录固件。<blockquote>
<p><strong>INFO：安装该项目会同时安装platformio依赖，platformio是一个8266开发板的开发环境。</strong></p>
</blockquote>
</li>
</ul>
</li>
<li>esphome-core<ul>
<li>项目地址：<a href="https://github.com/Samuel-0-0/esphome-core">https://github.com/Samuel-0-0/esphome-core</a></li>
<li>作用：ESPHome的C++源文件，编译后成为.bin固件，在8266开发板上运行。</li>
</ul>
</li>
<li>platform-espressif8266<ul>
<li>项目地址：<a href="https://github.com/Samuel-0-0/platform-espressif8266">https://github.com/Samuel-0-0/platform-espressif8266</a></li>
<li>作用：platformio开发环境的配置。</li>
</ul>
</li>
</ol>
<h3 id="1-2-编译固件的步骤"><a href="#1-2-编译固件的步骤" class="headerlink" title="1.2 编译固件的步骤"></a>1.2 编译固件的步骤</h3><ol>
<li>建立配置文件</li>
<li>esphome根据配置文件生成C++工程的配置文件</li>
<li>esphome调用platformio的接口编译C++工程文件，生成.bin固件</li>
</ol>
<h3 id="1-3-烧录固件的姿势"><a href="#1-3-烧录固件的姿势" class="headerlink" title="1.3 烧录固件的姿势"></a>1.3 烧录固件的姿势</h3><ol>
<li><p>线刷：接串口线烧录；可以用<code>esphome run/upload</code>命令（参数指定串口–device=/dev/ttyUSB0），也可以用<a href="https://github.com/esphome/esphome-flasher/releases" title="esphome-flasher">esphome-flasher</a>软件。</p>
</li>
<li><p>OTA：使用TCP或者UDP通信刷机；可以用<code>esphome run/upload</code>命令，也可以用设备的web服务（配置文件启用web_server组件），也可以用Home Assistant的ESPHome集成服务。</p>
<p> __INFO：如果配置文件中没有给设备指定IP地址（静态IP或设置use_address属性），命令行OTA会尝试解析{NodeName}.local的IP地址。如果客户机没有mDNS服务是找不到IP的，要么安装mDNS服务（配合设备的mDNS服务工作）；要么在hosts文件手动添加解析记录；如果电脑用的是路由器DNS服务，也可以在路由器上添加解析记录。__</p>
</li>
</ol>
<h3 id="1-4-设备工作模式"><a href="#1-4-设备工作模式" class="headerlink" title="1.4 设备工作模式"></a>1.4 设备工作模式</h3><p>ESPHome提供三种工作模式对设备进行控制.</p>
<table>
<thead>
<tr>
<th>模式</th>
<th align="center">接入Home Assistant</th>
<th align="center">所需编译配置</th>
<th align="center">通信协议</th>
</tr>
</thead>
<tbody><tr>
<td>ESPHome集成服务</td>
<td align="center">Home Assistant 配置-集成-ESPHome，连接到设备后自动生成</td>
<td align="center">api组件</td>
<td align="center">ESPHome自有通信协议</td>
</tr>
<tr>
<td>MQTT</td>
<td align="center">Home Assistant启用mqtt的discovery自动发现、生成</td>
<td align="center">mqtt组件</td>
<td align="center">MQTT</td>
</tr>
<tr>
<td>RESTful API</td>
<td align="center">自行开发</td>
<td align="center">web_server组件</td>
<td align="center">HTTP</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>WARN：api组件不能和mqtt组件一起使用。</strong></p>
</blockquote>
<hr>
<h2 id="2-esphome-cli"><a href="#2-esphome-cli" class="headerlink" title="2. esphome cli"></a>2. esphome cli</h2><p>介绍一下esphome命令行。</p>
<ul>
<li>编译<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编译生成固件文件</span></span><br><span class="line">esphome dc1.yaml compile</span><br></pre></td></tr></table></figure>
成功编译后会固件{CONFIG_DIR}/{NODE_NAME}/.pioenvs/{NODE_NAME}/firmware.bin</li>
</ul>
<blockquote>
<p><strong>INFO：举个例子，有一个/esphome/dc1.yaml，里面设置的NODE_NAME（设备名称）是phicomm_dc1，则编译后固件路径在/esphome/phicomm_dc1/.pioenvs/phicomm_dc1/firmware.bin</strong></p>
</blockquote>
<ul>
<li>刷机<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果带参数--device=/dev/ttyUSB0，则线刷；如果不带参数，则OTA：根据配置文件的静态IP或解析&#123;NODE_NAME&#125;.local的IP进行刷机</span></span><br><span class="line">esphome dc1.yaml upload</span><br></pre></td></tr></table></figure></li>
<li>编译+刷机<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 就是编译+刷机，参数和刷机命令一样</span></span><br><span class="line">esphome dc1.yaml run</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：会同时进入日志输出界面。</strong></p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="3-配置文件"><a href="#3-配置文件" class="headerlink" title="3. 配置文件"></a>3. 配置文件</h2><p>和Home Assistant的配置文件类似，可以搭积木地自由启用组件，挑一些出来分析。</p>
<ul>
<li>esphome组件</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 核心配置</span></span><br><span class="line"><span class="attr">esphome:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">$device_name</span> <span class="comment"># 设备名称，不能和其它设备重复</span></span><br><span class="line">  <span class="attr">platform:</span> <span class="string">ESP8266</span></span><br><span class="line">  <span class="attr">board:</span> <span class="string">$board_model</span></span><br><span class="line">  <span class="attr">esphome_core_version:</span> <span class="comment">#指定esphome_core来源，如果只用latest、dev，则会从官方的项目下载。</span></span><br><span class="line">    <span class="comment">#local: path/to/esphome-core #指定本地来源</span></span><br><span class="line">    <span class="attr">repository:</span> <span class="string">https://github.com/Samuel-0-0/esphome-core.git</span> <span class="comment">#指定外部来源，项目作用上面有介绍过</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">dc1</span></span><br><span class="line">  <span class="attr">build_path:</span> <span class="string">build/$device_name</span> <span class="comment"># 编译路径，默认是&#123;CONFIG_DIR&#125;/&#123;NODE_NAME&#125;</span></span><br><span class="line">  <span class="attr">esp8266_restore_from_flash:</span> <span class="literal">yes</span></span><br><span class="line">  <span class="attr">arduino_version:</span> <span class="number">2.5</span><span class="number">.0</span></span><br><span class="line">  <span class="attr">platformio_options:</span></span><br><span class="line">    <span class="attr">platform:</span> <span class="string">https://github.com/Samuel-0-0/platform-espressif8266.git#dc1</span> <span class="comment"># 项目作用上面有介绍过</span></span><br></pre></td></tr></table></figure>
<p>__INFO：$device_name是使用了substitutions设定的变量。__<br><strong>INFO：编译后生成固件路径{build_path}/.pioenvs/{NODE_NAME}/firmware.bin</strong></p>
<ul>
<li>wifi组件</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># wifi连接</span></span><br><span class="line"><span class="attr">wifi:</span></span><br><span class="line">  <span class="attr">ssid:</span> <span class="string">$wifi_ssid</span> <span class="comment"># wifi名称</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">$wifi_password</span> <span class="comment"># wifi密码</span></span><br><span class="line">  <span class="attr">use_address:</span> <span class="number">192.168</span><span class="number">.178</span><span class="number">.230</span> <span class="comment"># 指定烧录固件时候目标设备IP，优先级高于静态IP</span></span><br><span class="line">  <span class="comment"># 设置静态地址，建议设置，根据自己网络配置</span></span><br><span class="line">  <span class="attr">manual_ip:</span></span><br><span class="line">   <span class="attr">static_ip:</span> <span class="number">192.168</span><span class="number">.178</span><span class="number">.230</span></span><br><span class="line">   <span class="attr">gateway:</span> <span class="number">192.168</span><span class="number">.178</span><span class="number">.1</span></span><br><span class="line">   <span class="attr">subnet:</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">   <span class="attr">dns1:</span> <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">   <span class="attr">dns2:</span> <span class="number">1.2</span><span class="number">.2</span><span class="number">.1</span></span><br><span class="line">  <span class="attr">domain:</span> <span class="string">.local</span> <span class="comment"># 组合后设备主机名为&#123;NodeName&#125;.local，不设置默认就这个</span></span><br><span class="line">  <span class="attr">reboot_timeout:</span> <span class="string">$wifi_reboot_timeout</span> <span class="comment"># 无wifi连接自动重启时间，默认5min</span></span><br><span class="line">  <span class="attr">power_save_mode:</span> <span class="string">none</span> <span class="comment"># 节能模式，启用的话不会一直连接wifi</span></span><br><span class="line">  <span class="attr">fast_connect:</span> <span class="string">$wifi_fast_connect</span> <span class="comment"># 快速连接，不执行完整的wifi扫描，当存在多个相同wifi可能会直接连接到最弱的信号</span></span><br></pre></td></tr></table></figure>

<ul>
<li>ota组件</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ota:</span></span><br><span class="line">  <span class="attr">safe_mode:</span> <span class="literal">true</span> <span class="comment"># 连续10次启动失败，进入安全模式，只加载Serial Logging+WiFi+OTA组件</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">$ota_password</span></span><br></pre></td></tr></table></figure>

<ul>
<li>web_server组件</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># web端，可以查看排查信息以及进行控制，另外新版可以OTA。</span></span><br><span class="line"><span class="attr">web_server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span> <span class="comment"># web端口</span></span><br><span class="line">  <span class="attr">css_url:</span> <span class="string">https://esphome.io/_static/webserver-v1.min.css</span> <span class="comment"># css样式，不设置默认就这个，后续官方更新才用上。</span></span><br><span class="line">  <span class="attr">js_url:</span> <span class="string">https://esphome.io/_static/webserver-v1.min.js</span> <span class="comment"># js文件，不设置默认就这个，后续官方更新才用上。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：会同时启用HTTP RESTful API。</strong></p>
</blockquote>
<ul>
<li>api组件</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 本地api服务（esphome自己通信协议）</span></span><br><span class="line"><span class="attr">api:</span></span><br><span class="line">  <span class="attr">reboot_timeout:</span> <span class="string">$api_reboot_timeout</span> <span class="comment"># 无客户端访问设备API自动重启，默认5min</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>WARN：不使用Home Assistant的集成服务管理设备的话不要启用改配置，否则会导致不断定期重启。</strong></p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 日志组件</span></span><br><span class="line"><span class="attr">logger:</span></span><br><span class="line"><span class="comment">#  hardware_uart: UART1 # 串口调式，不懂</span></span><br><span class="line">  <span class="attr">level:</span> <span class="string">info</span> <span class="comment"># 日志等级，默认DEBUG，平常用设置INFO</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>__INFO：启用mqtt后，通过订阅{topic_prefix}/debug也可以获取日志。__</p>
</blockquote>
<hr>
<h2 id="4-mqtt模式"><a href="#4-mqtt模式" class="headerlink" title="4.mqtt模式"></a>4.mqtt模式</h2><p>ESPHome中大部分组件都能叠加mqtt功能直接使用，只需要相应的配置即可。</p>
<h3 id="4-1配置项说明"><a href="#4-1配置项说明" class="headerlink" title="4.1配置项说明"></a>4.1配置项说明</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mqtt功能</span></span><br><span class="line"><span class="attr">mqtt:</span></span><br><span class="line">  <span class="attr">broker:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span> <span class="comment"># mqtt服务器ip/域名</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">mosquitto</span> <span class="comment"># 账号</span></span><br><span class="line">  <span class="attr">password:</span> <span class="number">123</span> <span class="comment"># 密码</span></span><br><span class="line">  <span class="comment">#-------------------------------#</span></span><br><span class="line">  <span class="attr">birth_message:</span> <span class="comment"># 连接通知，设备发起</span></span><br><span class="line">    <span class="attr">topic:</span> <span class="string">phicomm_dc1/state</span> <span class="comment"># 默认&#123;TOPIC_PREFIX&#125;/status</span></span><br><span class="line">    <span class="attr">payload:</span> <span class="string">online</span> <span class="comment"># 默认通知online状态</span></span><br><span class="line">  <span class="attr">will_message:</span> <span class="comment"># 离线通知，由mqtt服务器发起</span></span><br><span class="line">    <span class="attr">topic:</span> <span class="string">phicomm_dc1/state</span> <span class="comment"># 默认&#123;TOPIC_PREFIX&#125;/status</span></span><br><span class="line">    <span class="attr">payload:</span> <span class="string">offline</span> <span class="comment"># 默认通知offline状态</span></span><br><span class="line">  <span class="comment"># 如果不设置，默认就是如上配置；如果birth_message、will_message的topic为空或不一样，则不生效。</span></span><br><span class="line">  <span class="comment">#-------------------------------#</span></span><br><span class="line">  <span class="attr">topic_prefix:</span> <span class="string">phicomm_dc1</span> <span class="comment"># 不设置默认&#123;NodeName&#125;</span></span><br><span class="line">  <span class="attr">discovery:</span> <span class="literal">True</span> <span class="comment"># 发现标记设置（全局）</span></span><br><span class="line">  <span class="attr">discovery_prefix:</span> <span class="string">homeassistant</span> <span class="comment"># 配置数据topic，默认homeassistant，要与Home Assistant的mqtt组件设置保持一直（默认也是homeassistant）</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>WARN：mqtt组件不能和api组件一起使用。</strong></p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 组件的mqtt配置</span></span><br><span class="line"><span class="attr">switch:</span> <span class="comment"># 组件类型，对应topic中的&#123;COMPONENT_TYPE&#125;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">platform:</span> <span class="string">gpio</span></span><br><span class="line">    <span class="attr">pin:</span> <span class="string">GPIO14</span></span><br><span class="line">    <span class="comment">#LOGO灯</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">&quot;$&#123;device_name&#125; LOGO_light&quot;</span> <span class="comment"># 组件名称对应topic中的&#123;COMPONENT_NAME&#125;</span></span><br><span class="line">    <span class="attr">id:</span> <span class="string">LOGO_light</span></span><br><span class="line">    <span class="attr">internal:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">inverted:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启用MQTT组件后，其它的大部分组件都拥有以下可选属性</span></span><br><span class="line"><span class="attr">retain:</span> <span class="literal">True</span> <span class="comment"># state_topic消息保持，默认True</span></span><br><span class="line"><span class="attr">discovery:</span> <span class="literal">True</span> <span class="comment"># 如果不设置，取mqtt组件的discovery属性 </span></span><br><span class="line"><span class="attr">availability:</span> <span class="comment"># 不设置取mqtt组件的birth_message、will_message属性</span></span><br><span class="line">  <span class="attr">topic:</span> <span class="string">livingroom/status</span></span><br><span class="line">  <span class="attr">payload_available:</span> <span class="string">online</span></span><br><span class="line">  <span class="attr">payload_not_available:</span> <span class="string">offline</span></span><br><span class="line"><span class="attr">state_topic:</span> <span class="string">livingroom/custom_state_topic</span> <span class="comment"># 不设置默认&#123;TOPIC_PREFIX&#125;/&#123;COMPONENT_TYPE&#125;/&#123;COMPONENT_NAME&#125;/state</span></span><br><span class="line"><span class="attr">command_topic:</span> <span class="string">livingroom/custom_command_topic</span> <span class="comment"># 不设置默认&#123;TOPIC_PREFIX&#125;/&#123;COMPONENT_TYPE&#125;/&#123;COMPONENT_NAME&#125;/command</span></span><br></pre></td></tr></table></figure>
<p><strong>INFO：如果设置internal: True属性隐藏，则不会通过mqtt上报。</strong><br><strong>INFO：一些不可控组件例如text_sensor，是没有command_topic的。</strong></p>
<h3 id="4-2实际使用样例"><a href="#4-2实际使用样例" class="headerlink" title="4.2实际使用样例"></a>4.2实际使用样例</h3><p>只需增加mqtt，其它保持默认即可。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># api: # 需要取消api组件</span></span><br><span class="line"><span class="attr">mqtt:</span></span><br><span class="line">  <span class="attr">broker:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span> <span class="comment"># mqtt服务器ip/域名</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">mosquitto</span> <span class="comment"># 账号</span></span><br><span class="line">  <span class="attr">password:</span> <span class="number">123</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure>
<p>假设设备名称{NodeName}为phicomm_dc1，则LOGO灯的topic如下，其它槽位开关的topic不在赘述。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># state_topic</span></span><br><span class="line"><span class="string">phicomm_dc1/switch/phicomm_dc1_logo_light/state</span></span><br><span class="line"><span class="comment"># command_tpoic，payload设置ON/OFF进行打开/关闭操作</span></span><br><span class="line"><span class="string">phicomm_dc1/switch/phicomm_dc1_logo_light/command</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：如果自定义了新topic，需要执行esphome dc1.yaml clean-mqtt命令清除mqtt服务器的信息。</strong></p>
</blockquote>
<p>最后Home Assistant中启用mqtt服务。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注意这个是Home Assistant的configuration.yaml</span></span><br><span class="line"><span class="attr">mqtt:</span></span><br><span class="line">  <span class="attr">broker:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">mosquitto</span></span><br><span class="line">  <span class="attr">password:</span> <span class="number">123</span></span><br><span class="line">  <span class="attr">discovery:</span> <span class="literal">True</span> <span class="comment"># 启用主动发现</span></span><br><span class="line">  <span class="attr">discovery_prefix:</span> <span class="string">homeassistant</span> <span class="comment"># 不设置默认就这个，要和ESPHome的一致</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h2><ul>
<li>为更深入了解ESPHome，想自行搭建了环境再编译固件，结果发现教程里esphome项目放错了链接，折腾了好久，找官方的docker研究了才知道原来有个esphome工具。</li>
<li>因为本人是更偏向与用mqtt接入的，原固件没有相关教程，本来想研究下代码直接把mqtt功能给加上去的，不过发现有点难看懂C++，硬件编程经验太少。后来查看官方文档，发现其实只要简单配置下就能用了。</li>
<li>配置调试mqtt期间，发现增加属性后编译报错，查看相关源码发现esphome cli有对配置文件解析成cpp文件的过程，才对整体的流程以及相关工具的分工更加明晰了。</li>
</ul>
]]></content>
      <categories>
        <category>Home Assistant</category>
      </categories>
      <tags>
        <tag>Home Assistant</tag>
        <tag>ESPHome</tag>
      </tags>
  </entry>
  <entry>
    <title>Home Assistant新手问题集</title>
    <url>/articles/home-assistant-novice-question-set/</url>
    <content><![CDATA[<p>不定期更新。</p>
<hr>
<a id="more"></a>

<h2 id="1-目录位置"><a href="#1-目录位置" class="headerlink" title="1. 目录位置"></a>1. 目录位置</h2><p>Home Assistant有两个主要的目录，一个是配置目录，有configuration.yaml(配置文件)、.storage(组件信息存储文件夹)、home-assistant.log（程序运行日志）等；一个是安装目录，放置有程序核心代码及官方组件代码（components目录）。</p>
<ul>
<li><p>windows</p>
<ul>
<li>安装目录<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新建.bat文件运行</span></span><br><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">rem 在PATH变量中查找Python安装包路径</span><br><span class="line"><span class="built_in">set</span> string=%PATH%</span><br><span class="line"><span class="built_in">set</span> targetstr=<span class="string">&quot;site-packages&quot;</span></span><br><span class="line">:split</span><br><span class="line"><span class="keyword">for</span> /f <span class="string">&quot;tokens=1,* delims=;&quot;</span> %%i <span class="keyword">in</span> (<span class="string">&quot;%string%&quot;</span>) <span class="keyword">do</span> (</span><br><span class="line"><span class="built_in">echo</span> %%i | findstr %targetstr%</span><br><span class="line"><span class="built_in">set</span> string=%%j</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> not <span class="string">&quot;%string%&quot;</span>==<span class="string">&quot;&quot;</span> goto split</span><br><span class="line">pause</span><br></pre></td></tr></table></figure></li>
<li>配置目录<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cmd命令行执行</span></span><br><span class="line"><span class="built_in">echo</span> %APPDATA%/.homeassistant</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>linux（直接安装方式）</p>
<ul>
<li>安装目录<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># root用户运行</span></span><br><span class="line">find / -name homeassistant | grep -E <span class="string">&#x27;site-packages|dist-packages&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>配置目录<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># root用户运行</span></span><br><span class="line">find / -name configuration.yaml</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>linux（docker手动拉取镜像运行）</p>
<ul>
<li>安装目录（容器）：<code>/usr/src/homeassistant/homeassistant</code></li>
<li>配置目录（容器）：<code>/config</code></li>
</ul>
</li>
<li><p>linux（hassio）</p>
<ul>
<li>安装目录（容器）：<code>/usr/src/homeassistant/homeassistant</code></li>
<li>配置目录（容器）：<code>/config</code></li>
<li>配置目录（宿主机）：<code>/usr/share/hassio/homeassistant</code></li>
</ul>
<blockquote>
<p><strong>INFO：hassio实际也是通过容器跑homeassistant。</strong></p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="2-安装插件（自定义组件）"><a href="#2-安装插件（自定义组件）" class="headerlink" title="2. 安装插件（自定义组件）"></a>2. 安装插件（自定义组件）</h2><p>Home Assistant各种各样的功能以插件的形式提供，目前配置方法还是以文本编辑为主，分两步走。</p>
<ul>
<li>把下载的插件目录放到<code>[配置目录]/custom_components/</code>文件夹下，确认<code>__init__.py</code>文件位于<code>[配置目录]/custom_components/[插件名称]/__init__.py</code></li>
<li>编辑<code>[HA配置目录]/configuration.yaml</code>加入相应的配置信息启用</li>
</ul>
<p>__WARN：没有custom_components文件夹则新建一个。__</p>
<hr>
<h2 id="3-调试及查看程序运行日志"><a href="#3-调试及查看程序运行日志" class="headerlink" title="3. 调试及查看程序运行日志"></a>3. 调试及查看程序运行日志</h2><p>组件开发一般都设置有不同级别的日志信息输出，一般日常运行在info级别，调式时候应改为debug级别。</p>
<ul>
<li><p>设置组件运行日志的生成规则，更详细说明看<a href="https://www.home-assistant.io/components/logger/" title="logger组件">官方文档</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># [HA配置目录]/configuration.yaml</span></span><br><span class="line"><span class="attr">logger:</span></span><br><span class="line">  <span class="attr">default:</span> <span class="string">error</span>  <span class="comment"># 提高所有组件的默认级别，调试完后改回info（预设）</span></span><br><span class="line">  <span class="attr">logs:</span>           <span class="comment"># 设定指定组件的级别，debug有更详细的输出</span></span><br><span class="line">    <span class="string">custom_components.[插件名称]:</span> <span class="string">debug</span> <span class="comment"># 不需要[]符号</span></span><br></pre></td></tr></table></figure>
<p><strong>INFO：把不想看的组件级别调高，把想看的组件级别调低（更多输出），有助于排查指定插件问题。</strong></p>
</li>
<li><p>查看日志</p>
<ul>
<li><p>web浏览器方式：<code>“开发者工具”-&gt; “信息”-&gt; LOAD FULL HOME ASSISTANT LOG</code></p>
</li>
<li><p>查看日志文件方式：<code>tail -f [HA配置目录]/home-assistant.log</code></p>
<p><strong>INFO：该文件程序每次启动会重新生成；也可以直接用文本编辑器打开观看。</strong></p>
</li>
<li><p>docker日志方式，宿主机运行命令：<code>docker logs [容器名/容器ID] -f --tail 1</code></p>
<p><strong>INFO：可以再指令后增加”| grep”进一步筛选输出。</strong></p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="4-控制历史数据生成"><a href="#4-控制历史数据生成" class="headerlink" title="4. 控制历史数据生成"></a>4. 控制历史数据生成</h2><p>Home Assistant运行占用空间主要是各类entity的历史数据，可以通过recorder组件控制生成，更详细的使用说明建议看<a href="https://www.home-assistant.io/components/recorder/" title="recorder组件">官方文档</a>。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">recorder:</span></span><br><span class="line">  <span class="comment"># db_url: # 设定把数据存到另外的数据库服务器也可以有效减少本机空间的占用</span></span><br><span class="line">  <span class="attr">purge_interval:</span> <span class="number">3</span>     <span class="comment"># 每X天执行一次清理，重启会重置</span></span><br><span class="line">  <span class="attr">purge_keep_days:</span> <span class="number">15</span>   <span class="comment"># 历史数据保存的天数</span></span><br><span class="line">  <span class="attr">exclude:</span>              <span class="comment"># 不记录的放这里</span></span><br><span class="line">    <span class="attr">domains:</span>            <span class="comment"># 按域名过滤</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">automation</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">weblink</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">updater</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">input_text</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">input_select</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">input_boolean</span></span><br><span class="line">    <span class="attr">entities:</span>           <span class="comment"># 按entity ID过滤，比如这里将某些不需要记录的sun、或者sensor</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">sun.sun</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">sensor.last_boot</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">sensor.date</span></span><br><span class="line">  <span class="comment"># include:            # 也可以不设置exclude，只设置include，则只有指定的domian</span></span><br><span class="line">  <span class="comment">#   domains:</span></span><br><span class="line">  <span class="comment">#     - </span></span><br><span class="line">  <span class="comment">#   entities:</span></span><br><span class="line">  <span class="comment">#     - </span></span><br></pre></td></tr></table></figure>
<p><strong>INFO：exclude与include可以一起使用，规则是先判断include再判断exclude（应该）。</strong></p>
<hr>
<h2 id="5-容器与宿主机拷贝文件"><a href="#5-容器与宿主机拷贝文件" class="headerlink" title="5. 容器与宿主机拷贝文件"></a>5. 容器与宿主机拷贝文件</h2><p>很多HA都是跑在docker上，配置目录可以通过映射方式（bind）方便地在宿主机目录访问，但如果想要查看或修改安装目录的源码，则可以用命令拷贝出来。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拷贝宿主机文件至容器</span></span><br><span class="line"><span class="string">docker</span> <span class="string">cp</span> [<span class="string">本机目录</span>] [<span class="string">容器名/容器ID</span>]<span class="string">:[容器目录]</span></span><br><span class="line"><span class="comment"># 拷贝容器文件至宿主机</span></span><br><span class="line"><span class="string">docker</span> <span class="string">cp</span> [<span class="string">容器名/容器ID</span>]<span class="string">:[容器目录]</span> [<span class="string">本机目录</span>]</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="6-换源"><a href="#6-换源" class="headerlink" title="6. 换源"></a>6. 换源</h2><p>软件的更新源一般在国外服务器，经常蜗牛速度，换国内源可以大大提升体验，以下方法如不适用，可以搜索网上更详细的教程。</p>
<ul>
<li><p>pip</p>
<ul>
<li>linux，直接用命令创建，哪个用户运行HA就用哪个用户执行<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/.pip/ &amp;&amp; \</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[global]&quot;</span> &gt; ~/.pip/pip.conf &amp;&amp; \</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;index-url = http://mirrors.aliyun.com/pypi/simple/&quot;</span> &gt;&gt; ~/.pip/pip.conf &amp;&amp; \</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[install]&quot;</span> &gt;&gt; ~/.pip/pip.conf &amp;&amp; \</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;trusted-host = mirrors.aliyun.com&quot;</span> &gt;&gt; ~/.pip/pip.conf</span><br></pre></td></tr></table></figure></li>
<li>windows，CMD命令行下执行命令创建<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">%APPDATA%</span>\.pip &amp;&amp; ^</span><br><span class="line"><span class="built_in">echo</span> [global] &gt; <span class="variable">%APPDATA%</span>\.pip\pip.ini &amp;&amp; ^</span><br><span class="line"><span class="built_in">echo</span> index-url = http://mirrors.aliyun.com/pypi/simple/ &gt;&gt; <span class="variable">%APPDATA%</span>\.pip\pip.ini &amp;&amp; ^</span><br><span class="line"><span class="built_in">echo</span> [install] &gt;&gt; <span class="variable">%APPDATA%</span>\.pip\pip.ini &amp;&amp; ^</span><br><span class="line"><span class="built_in">echo</span> trusted-host = mirrors.aliyun.com &gt;&gt; <span class="variable">%APPDATA%</span>\.pip\pip.ini</span><br></pre></td></tr></table></figure>
<strong>INFO：也可以自行创建文件再添加内容。</strong></li>
</ul>
</li>
<li><p>linux，一般可以用命令替换网址就能使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Debian 需root权限</span></span><br><span class="line">sed -i <span class="string">&quot;s@http://\(security.debian.org\|deb.debian.org\)@http://mirrors.aliyun.com@g&quot;</span> /etc/apt/sources.list</span><br><span class="line"><span class="comment"># Ubuntu 需root权限</span></span><br><span class="line">sed -i <span class="string">&quot;s@http://\(security.ubuntu.com\|archive.ubuntu.com\)@http://mirrors.aliyun.com@g&quot;</span> /etc/apt/sources.list</span><br></pre></td></tr></table></figure>
</li>
<li><p>docker，在配置文件中增加内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/docker/deamon.json</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /etc/docker/deamon.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;https://registry.docker-cn.com&quot;</span>,</span><br><span class="line">    <span class="string">&quot;http://hub-mirror.c.163.com&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;dns&quot;</span>: [<span class="string">&quot;8.8.8.8&quot;</span>,<span class="string">&quot;8.8.4.4&quot;</span>] <span class="comment">// 换成你常用的DNS地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>INFO：在/etc/resolv.conf设置DNS经常会被覆盖，建议在daemon.json中指定</strong></p>
</li>
</ul>
<hr>
<h2 id="7-时间不对"><a href="#7-时间不对" class="headerlink" title="7.时间不对"></a>7.时间不对</h2><p>一般用docker方式跑HA会出现时间慢8小时，这是由于镜像的时区为UTC，修改为CST即可。</p>
<ul>
<li>首次运行容器，docker run加入参数<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方式1.指定环境变量</span></span><br><span class="line">-e <span class="string">&quot;TZ=Asia/Shanghai&quot;</span></span><br><span class="line"><span class="comment"># 方式2.把宿主机的已配置好的文件覆盖掉容器的文件</span></span><br><span class="line">-v <span class="string">&quot;/etc/localtime:/etc/localtime:ro&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>已在运行容器，进入容器修改<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it [容器名/容器id] sh</span><br><span class="line">容器内执行命令：</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Asia/Shanghai&quot;</span> &gt; /etc/timezone</span><br><span class="line">dpkg-reconfigure -f noninteractive tzdata</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h2 id="10068-其它"><a href="#10068-其它" class="headerlink" title="10068. 其它"></a>10068. 其它</h2><ul>
<li>入门教程建议看HAChina的<a href="https://www.hachina.io/docs/321.html" title="HA文档">教程</a>，很全面也够详细。</li>
</ul>
]]></content>
      <categories>
        <category>Home Assistant</category>
      </categories>
      <tags>
        <tag>Home Assistant</tag>
      </tags>
  </entry>
  <entry>
    <title>Let&#39;s Encrypt通配符证书续期及分发</title>
    <url>/articles/lets-encrypt-wildcard-certificate-renewal-and-distribution/</url>
    <content><![CDATA[<p>由于家里使用的宽带没公网IP，为了接入智能音箱的skill，采取了VPS反向代理方式提供对接服务。由于对接服务需要使用https，因此申请了免费的Let’s Encrypt证书。Let’s Encrypt证书的有效期为3个月，做个自动续期脚本还是需要的，不过通配符证书只能用DNS验证，没有现成的腾讯云续签脚本，得自己写下；考虑到VPS的临时性（都是薅各种云的试用羊毛），不打算在VPS上部署证书自动续期脚本，考虑用scp命令将证书推送过去。</p>
<hr>
<a id="more"></a>
<h2 id="0-目标"><a href="#0-目标" class="headerlink" title="0.目标"></a>0.目标</h2><p>家里的服务器自动续期证书，并将新证书推送到指定的VPS上。</p>
<blockquote>
<p><strong>INFO：服务器系统均为Ubuntu。</strong></p>
</blockquote>
<hr>
<h2 id="1-续期"><a href="#1-续期" class="headerlink" title="1.续期"></a>1.续期</h2><ul>
<li>安装certbot工具</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/certbot/certbot</span><br></pre></td></tr></table></figure>

<ul>
<li>下载腾讯云的DNS更新脚本（<a href="https://github.com/cnk700i/certbot-dns-hook" title="qcloud">下载地址</a>）,编辑<code>qcloud.php</code>，填写secretId和secretKey</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#qcloud.php</span></span><br><span class="line">define(<span class="string">&quot;secretId&quot;</span>, <span class="string">&quot;填写secretId&quot;</span>);</span><br><span class="line">define(<span class="string">&quot;secretKey&quot;</span>, <span class="string">&quot;填写secretKey&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>设置计划任务</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换root用户</span></span><br><span class="line">sudo su</span><br><span class="line"><span class="comment"># </span></span><br><span class="line">crontab -e</span><br><span class="line"><span class="comment"># 一周运行一次</span></span><br><span class="line">0 3 * * 1 [certbot工具目录]/certbot-auto renew --cert-name [域名例如ljr.im] --manual-auth-hook [DNS更新脚本目录]/certbot-dns-qcloud/au.sh</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>INFO：自行替换<code>[ ]</code>部分。</strong></p>
</blockquote>
<hr>
<h2 id="2-分发"><a href="#2-分发" class="headerlink" title="2.分发"></a>2.分发</h2><p>为了使脚本可以定期自动执行，需要配置scp免密传输证书。</p>
<ul>
<li>PC1生成钥匙对(PC1当前用户user1)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成钥匙对</span></span><br><span class="line">ssh-keygen -b 1024 -t rsa</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>INFO：在程序提示输入passphrase时直接输入回车，表示无证书密码。上述命令将生成私钥证书id_rsa和公钥证书id_rsa.pub，存放在~/.ssh/目录，即当前登陆用户的用户目录中。</strong></p>
</blockquote>
<ul>
<li>PC2添加信任user1(PC2当前用户user2)<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建.ssh目录，如果已存在目录可跳过</span></span><br><span class="line">mkdir ~/.ssh</span><br><span class="line"><span class="comment"># 设置权限，如果已存在目录可跳过</span></span><br><span class="line">chmod 700 ~/.ssh</span><br><span class="line"><span class="comment"># 编辑authorized_keys文件，并将PC1的id_rsa.pub的内容添加到authorized_keys文件的尾部。</span></span><br><span class="line">vi ~/.ssh/authorized_keys</span><br><span class="line"><span class="comment"># 设置权限，如果文件已存在目录可跳过</span></span><br><span class="line">chmod 600 ~./ssh/authorized_keys</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p><strong>WARN：通过以上配置，user1可以以user2的身份登陆到PC2上进行复制，即PC1的user1用户可以免密执行<code>scp [本地路径] [user2]@[PC2域名或IP]:[远程路径]</code>。</strong><br><strong>INFO：复制时候要注意PC2的user2对远程路径有写权限。</strong></p>
</blockquote>
<ul>
<li>PC1设置定期推送计划任务<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换到user1（PC2的信任用户）</span></span><br><span class="line">su user1</span><br><span class="line"><span class="comment"># 设置计划任务，user1执行scp</span></span><br><span class="line">crontab -e</span><br><span class="line"><span class="comment"># 一周运行一次，复制privkey.pem和fullchain.pem即可</span></span><br><span class="line">0 3 * * 2 scp /etc/letsencrypt/live/[域名例如ljr.im]/privkey.pem [user2]@[PC2域名或IP]:~/cert/</span><br><span class="line">0 3 * * 2 scp /etc/letsencrypt/live/[域名例如ljr.im]/fullchain.pem [user2]@[PC2域名或IP]:~/cert/</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：申请到的https证书默认存放在<code>/etc/letsencrypt/live/[域名例如ljr.im]/</code>目录</strong></p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h2><ul>
<li>certbot工具的DNS方式续期证书，脚本需要做的工作是接收一个校验字符串，在DNS服务商平台上添加一条TXT类型、主机记录为<code>_acme-challeng</code>、值为校验字符串的记录。</li>
<li>scp免密传输，实际上是本地机器用户以远程机器用户身份登录，相关配置在这两个用户相应的用户文件夹里的<code>.ssh文件夹</code>进行。</li>
</ul>
<hr>
<p>参考文章传送门：</p>
<p>1、<a href="https://www.jianshu.com/p/d318321b93a1" title="不会自动为Let&#39;s Encrypt通配符证书续期？我写了个小工具">不会自动为Let’s Encrypt通配符证书续期？我写了个小工具</a></p>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>Let&#39;s Encrypt</tag>
        <tag>腾讯云</tag>
        <tag>VPS</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx配置url转发</title>
    <url>/articles/nginx-configure-url-forwarding/</url>
    <content><![CDATA[<p>之前havcs插件配套站点因为功能页面设置在第二层级，如要访问需要直接访问域名/account/，访问域名/account也会报错，着实反人类。最近因为443端口被禁了，为了避免url再加上端口号长到记不住，趁着调整域名的机会优化了地址访问，在此整理一下Nginx配置方法。</p>
<hr>
<a id="more"></a>

<h2 id="1-环境"><a href="#1-环境" class="headerlink" title="1. 环境"></a>1. 环境</h2><ul>
<li>Ubuntu 18.04 64位</li>
<li>Nginx 1.17.3</li>
</ul>
<hr>
<h2 id="2-案例"><a href="#2-案例" class="headerlink" title="2. 案例"></a>2. 案例</h2><p>以下配置均在<code>http&#123;&#125;块</code>里面配置。</p>
<h3 id="2-1-域名首页跳转"><a href="#2-1-域名首页跳转" class="headerlink" title="2.1. 域名首页跳转"></a>2.1. 域名首页跳转</h3><p>需求：访问{域名}转跳到{域名}/account/</p>
<p>实现：Nginx提供location块以及if语句来对uri判断并进行跳转，有如下三种配置方法。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># location精确匹配</span></span><br><span class="line"><span class="attribute">location</span> = / &#123;</span><br><span class="line">    <span class="attribute">rewrite</span> / account/ <span class="literal">permanent</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># location正则精确匹配</span></span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~ ^/$</span> &#123;</span><br><span class="line">    <span class="attribute">rewrite</span> / account/ <span class="literal">permanent</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># nginx内置变量正则匹配</span></span><br><span class="line"><span class="attribute">if</span> (<span class="variable">$request_uri</span> <span class="regexp">~ &quot;^/$&quot;)</span> &#123;</span><br><span class="line">  <span class="attribute">rewrite</span> / account/ <span class="literal">permanent</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>INFO：location有几种匹配模式，优先级不同，建议网上搜索教程再仔细了解。</strong></p>
</blockquote>
<h3 id="2-2-uri结尾补全”-“"><a href="#2-2-uri结尾补全”-“" class="headerlink" title="2.2. uri结尾补全”/“"></a>2.2. uri结尾补全”/“</h3><p>需求：访问<code>&#123;域名&#125;/account</code>，转跳到<code>&#123;域名&#125;/account/</code></p>
<p>实现：判断是否目录，再rewrite匹配非/结尾的uri进行补全</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">if</span> (-d <span class="variable">$request_filename</span>)&#123;</span><br><span class="line">  <span class="attribute">rewrite</span><span class="regexp"> ^/(.*)([^/])$</span> https://<span class="variable">$host</span>/<span class="variable">$1</span><span class="variable">$2</span>/ <span class="literal">permanent</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-静态资源访问"><a href="#2-3-静态资源访问" class="headerlink" title="2.3. 静态资源访问"></a>2.3. 静态资源访问</h3><p>假设：{域名}/resoutces/路径存放静态资源，实际对应目录/usr/share/nginx/html/resoutces</p>
<p>实现：使用root和alias指定文件路径</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法1</span></span><br><span class="line"><span class="attribute">location</span><span class="regexp"> ^~</span> /resources/ &#123;</span><br><span class="line">  <span class="attribute">root</span> /usr/share/nginx/html/;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法2</span></span><br><span class="line"><span class="attribute">location</span><span class="regexp"> ^~</span> /resources/ &#123; </span><br><span class="line">  <span class="attribute">alias</span> /usr/share/nginx/html/resources/;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法3</span></span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~ ^/resources/(.*)</span> &#123;</span><br><span class="line">  <span class="attribute">alias</span> /usr/share/nginx/html/resources/<span class="variable">$1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：^~ 是字符常量匹配，填uri前缀字符串，~是正则匹配，填正则表达式。</strong></p>
</blockquote>
<p>*错误实现：alias在location使用正则匹配时候不会自动填充地址，需要将匹配出来的变量$1组合成正确路径。如果像下面配置，只会访问/usr/share/nginx/html/resources/目录，如果该目录没有index页面或者启用目录文件列表功能（autoindex），最后返回403错误。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 匹配只返回目录</span></span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~ ^/resources/</span> &#123;</span><br><span class="line">  <span class="attribute">alias</span> /usr/share/nginx/html/resources/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拓展：也可以通过判断$request_uri，使用代理转发将静态资源的请求转发给专用的资源主机处理，获取相关的静态资源。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">  <span class="attribute">if</span> (<span class="variable">$request_uri</span> <span class="regexp">~ &quot;^/resources/([^?]*)&quot;)</span> &#123;</span><br><span class="line">    <span class="attribute">set</span> <span class="variable">$path</span> <span class="variable">$1</span>;</span><br><span class="line">    <span class="attribute">rewrite</span> . /<span class="variable">$path</span> <span class="literal">break</span>;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://1.1.1.1; <span class="comment"># 资源主机</span></span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>INFO：proxy_pass带uri会报错。</strong></p>
</blockquote>
<hr>
<h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><ul>
<li>很多场景下uri匹配都需要使用正则表达式，正则表达式虽然难但真香。</li>
<li>Nginx配置还是很灵活的，某一需求其实可以使用不同的方法实现，但有不少细节需要注意。</li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Visual Studio Code调试Home Assistant代码（Docker版）</title>
    <url>/articles/visual-studio-code-debugging-home-assistant-docker-version/</url>
    <content><![CDATA[<p><a href="https://ljr.im/articles/visual-studio-code-debugging-home-assistant-wsl-version/" title="Visual Studio Code调试Home Assistant代码（WSL版）">上次</a>使用VS Code在WSL下实现了Home Assistant代码的调试，对Visual Studio Code的远程调试功能有了一定的了解，现在再回头看一开始就折腾的Docker远程调试，很多问题迎刃而解。</p>
<hr>
<a id="more"></a>
<h2 id="0-环境"><a href="#0-环境" class="headerlink" title="0.环境"></a>0.环境</h2><ul>
<li>Win10 + Docker Desktop 2.1.0.1</li>
<li>Ubuntu 18.04 + Docker CE 19.03.1</li>
<li>Visual Studio Code 1.38.0<br><strong>INFO：Windows需要Docker Desktop相关的工具提供支持。</strong></li>
</ul>
<hr>
<h2 id="1-方法简介"><a href="#1-方法简介" class="headerlink" title="1.方法简介"></a>1.方法简介</h2><p>Docker容器环境开发调试，需要一台Linux主机提供容器，本地Windows使用VS Code远程到容器环境运行代码。与使用WSL开发调试相比，有一个好处就是代码在Linux主机上，可以在不同的终端主机通过VS Code远程登录开发调试。不过缺点就是本地代码是没法直接和远程环境同步，不像WSL所加载的代码目录在Windows上是可以直接访问修改的。<br>使用Docker容器环境开发调试，可以根据项目工程的<code>devcontainer.json</code>文件实现镜像构建、插件安装、运行参数设定等一系列过程实现自动部署容器开发环境；也可以将代码加载到已有的容器中去运行。前一种由于本人理解有限加上上手较难，有兴趣可以观看<a href="https://code.visualstudio.com/docs/remote/containers" title="Developing inside a Container">VS Code文档</a>结合HA代码工程（Github上的项目带有配置文件）实践部署。这里只介绍后一种方法，目标是以最简单的方法实现调试Home Assistant代码。</p>
<hr>
<h2 id="2-准备"><a href="#2-准备" class="headerlink" title="2.准备"></a>2.准备</h2><h3 id="2-1-Linux"><a href="#2-1-Linux" class="headerlink" title="2.1.Linux"></a>2.1.Linux</h3><p>Linux下docker安装过程省略。</p>
<ul>
<li><p>开启Docker开启远程访问。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /lib/systemd/system/docker.service</span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /lib/systemd/system/docker.service 文件</span></span><br><span class="line"><span class="comment"># 修改ExecStart行</span></span><br><span class="line"><span class="string">ExecStart=/usr/bin/dockerd</span> <span class="string">-H</span> <span class="string">tcp://0.0.0.0:2375</span> <span class="string">-H</span> <span class="string">unix:///var/run/docker.sock</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p><strong>WARN：这里的端口号不是自定义端口，只能用2375或2376，另外2375是不加密不验证的端口，有安全方面的要求请启用2376端口并进行相应设置，具体方法自行搜索。</strong></p>
</li>
<li><p>调大用户监视文件数，详细说明可以看<a href="https://code.visualstudio.com/docs/setup/linux#_visual-studio-code-is-unable-to-watch-for-file-changes-in-this-large-workspace-error-enospc" title="Visual Studio Code is unable to watch for file changes in this large workspace">这里</a>。</p>
<ul>
<li><p>编辑配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/sysctl.conf</span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /etc/sysctl.conf 文件</span></span><br><span class="line"><span class="comment"># 末尾加入</span></span><br><span class="line"><span class="string">fs.inotify.max_user_watches</span> <span class="string">=</span> <span class="number">81920</span></span><br></pre></td></tr></table></figure>
<p><strong>INFO：默认数值是8192，最大是524,288。</strong><br><strong>INFO：容器的参数和宿主机一致，只能在宿主机修改。</strong></p>
</li>
<li><p>使能配置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>创建测试环境容器，用使用官方的镜像即可，根据需要调整版本号。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull homeassistant/home-assistant:0.98.0</span><br><span class="line">docker run -it --name demo -p 8456:8123 homeassistant/home-assistant:0.98.0 /bin/sh -c <span class="string">&quot;while sleep 1000; do :; done&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>INFO：也可以不设置端口映射，VS Code提供Remote-Containers: Forward Port from Container功能，分配到端口后可以在Windows通过<code>localhost:[转发端口]</code>访问。</strong></p>
<h3 id="2-2-Windows"><a href="#2-2-Windows" class="headerlink" title="2.2.Windows"></a>2.2.Windows</h3><p>windows下只要安装Docker Desktop即可。</p>
</li>
</ul>
<hr>
<h2 id="3-VS-Code操作"><a href="#3-VS-Code操作" class="headerlink" title="3.VS Code操作"></a>3.VS Code操作</h2><ul>
<li><p>VS Code安装Docker插件、RemoteDevelopment插件。</p>
 
    <img src="/articles/visual-studio-code-debugging-home-assistant-docker-version/c3_p1_%E5%AE%89%E8%A3%85docker%E6%8F%92%E4%BB%B6.png" class="" title="安装docker插件">
  
 
    <img src="/articles/visual-studio-code-debugging-home-assistant-docker-version/c3_p2_%E5%AE%89%E8%A3%85RemoteDevelopment%E6%8F%92%E4%BB%B6.png" class="" title="安装Remote Development插件">
  </li>
<li><p>配置docker连接信息。</p>
 
    <img src="/articles/visual-studio-code-debugging-home-assistant-docker-version/c3_p3_%E8%AE%BE%E7%BD%AEdocker%E4%B8%BB%E6%9C%BA%E5%9C%B0%E5%9D%80.png" class="" title="设置docker主机地址">
  
 
    <img src="/articles/visual-studio-code-debugging-home-assistant-docker-version/c3_p4_%E6%88%90%E5%8A%9F%E8%BF%9E%E6%8E%A5docker%E4%B8%BB%E6%9C%BA.png" class="" title="成功连接docker主机">
  
</li>
<li><p>连接容器，将会新建远程窗口，有两种方法。</p>
<ul>
<li>方法1：远程资源管理器中，选择容器-&gt;”Connect to Container” 
    <img src="/articles/visual-studio-code-debugging-home-assistant-docker-version/c3_p5_%E9%80%9A%E8%BF%87RemoteDevelopment%E6%8F%92%E4%BB%B6%E8%BF%9E%E6%8E%A5%E5%AE%B9%E5%99%A8.png" class="" title="通过Remote Development插件连接容器">
  </li>
<li>方法2：Docker插件中，容器窗-&gt;容器右键-&gt;”Attach Visual Studio Code” 
    <img src="/articles/visual-studio-code-debugging-home-assistant-docker-version/c3_p6_%E9%80%9A%E8%BF%87Docker%E6%8F%92%E4%BB%B6%E8%BF%9E%E6%8E%A5%E5%AE%B9%E5%99%A8.png" class="" title="通过Docker插件连接容器">
  </li>
<li>新窗口成功连接容器（左下角有变化） 
    <img src="/articles/visual-studio-code-debugging-home-assistant-docker-version/c3_p7_%E6%88%90%E5%8A%9F%E8%BF%9E%E6%8E%A5%E5%88%B0%E5%AE%B9%E5%99%A8.png" class="" title="成功连接到容器">
  </li>
</ul>
</li>
<li><p>在容器中安装Python插件，代码调试需要。</p>
 
    <img src="/articles/visual-studio-code-debugging-home-assistant-docker-version/c3_p8_%E5%AE%B9%E5%99%A8%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6.png" class="" title="容器环境安装插件">
  </li>
<li><p>准备代码目录。</p>
<ul>
<li>打开主目录，因为官方镜像中程序代码位于<code>/usr/src/homeassistant/homeassistant</code>，可以直接使用<code>/usr/src/homeassistant</code>作为主目录而无需新建。 
    <img src="/articles/visual-studio-code-debugging-home-assistant-docker-version/c3_p9_%E8%BF%9C%E7%A8%8B%E7%AA%97%E5%8F%A3%E6%89%93%E5%BC%80%E4%B8%BB%E7%9B%AE%E5%BD%95.png" class="" title="远程窗口打开主目录">
  </li>
<li>保留<code>homeassitant</code>文件夹，删除其它非必要文件（可选）。 
    <img src="/articles/visual-studio-code-debugging-home-assistant-docker-version/c3_p10_%E5%8E%9F%E6%9C%89%E7%9A%84%E5%86%85%E5%AE%B9.png" class="" title="原有的内容">
  </li>
<li>新建<code>config</code>目录，作为HA配置目录。<br><strong>INFO：VS Code的文件资源管理中直接编辑即可，也支持拖拽上传下载的。</strong></li>
<li>新建<code>debug.py</code>，用于启动HA，内容如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> homeassistant <span class="keyword">import</span> __main__ <span class="keyword">as</span> hass_entry</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    sys.exit(hass_entry.main())</span><br></pre></td></tr></table></figure></li>
<li>新建<code>.vscode</code>目录,<code>.vscode</code>目录下新建<code>launch.json</code>文件<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//launch.json内容</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用 IntelliSense 了解相关属性。 </span></span><br><span class="line">    <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">    <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Home Assistant Debug&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;python&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;program&quot;</span>: <span class="string">&quot;$&#123;workspaceRoot&#125;/debug.py&quot;</span>, <span class="comment">//运行HA</span></span><br><span class="line">            <span class="attr">&quot;console&quot;</span>: <span class="string">&quot;integratedTerminal&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [<span class="string">&quot;-c&quot;</span>, <span class="string">&quot;config&quot;</span>], <span class="comment">//指定配置文件</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>最终目录结构如图。 
    <img src="/articles/visual-studio-code-debugging-home-assistant-docker-version/c3_p11_%E5%A2%9E%E5%8A%A0%E8%B0%83%E8%AF%95%E7%94%A8%E7%9A%84%E6%96%87%E4%BB%B6.png" class="" title="增加调试用的文件">
  
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="4-调试"><a href="#4-调试" class="headerlink" title="4.调试"></a>4.调试</h2><p>在远程窗口（连接到容器）下，菜单栏-&gt;调试-&gt;启动调试（快捷键F5）开始运行调试。如下图，可以看到能够正常追踪HA主程序断点以及自定义组件代码断点。</p>
<ul>
<li>启动过程断点 
    <img src="/articles/visual-studio-code-debugging-home-assistant-docker-version/c4_p1_%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E6%96%AD%E7%82%B9.png" class="" title="启动过程断点">
  </li>
<li>正常运行自定义插件断点 
    <img src="/articles/visual-studio-code-debugging-home-assistant-docker-version/c4_p2_%E5%90%AF%E5%8A%A8%E5%90%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E4%BB%B6%E6%96%AD%E7%82%B9.png" class="" title="启动后自定义插件断点">
  </li>
<li>网页调用服务触发断点 
    <img src="/articles/visual-studio-code-debugging-home-assistant-docker-version/c4_p3_%E7%BD%91%E9%A1%B5%E8%B0%83%E7%94%A8%E6%9C%8D%E5%8A%A1%E8%A7%A6%E5%8F%91%E6%96%AD%E7%82%B9.png" class="" title="网页调用服务触发断点">
  
</li>
</ul>
<hr>
<h2 id="5-其它"><a href="#5-其它" class="headerlink" title="5.其它"></a>5.其它</h2><ul>
<li><p><font color="red">修改过的代码应及时备份到本地</font>，以免删除容器丢失代码，也可以根据<a href="https://code.visualstudio.com/docs/remote/containers-advanced#_optional-making-the-remote-source-code-available-locally" title="Making the remote source code available locally">VS Code文档指引</a>自动同步至本地。</p>
</li>
<li><p>避免在断点停下来时候直接结束调试，这样进程不会退出无法释放端口，需要手工终止进程。  </p>
 
    
  
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># VS Code新建终端</span></span><br><span class="line">ps -aux | grep python | grep config</span><br><span class="line"><span class="built_in">kill</span> -9 [进程号]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h2><ul>
<li>远程调试不需要本地安装python运行环境，代码解析由远端的python运行；远程调试模式下远端会安装有VS Code服务程序，本地VS Code作为操作界面实现交互。</li>
<li>得益于官方HA镜像的主程序代码没有在python安装目录，不需要另外下载代码包。另外不同版本的代码文件可以直接docker pull下来，初步使用下来比用WSL部署更方便。</li>
</ul>
]]></content>
      <categories>
        <category>Home Assistant</category>
      </categories>
      <tags>
        <tag>Home Assistant</tag>
        <tag>VS Code</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Visual Studio Code调试Home Assistant代码（SSH版）</title>
    <url>/articles/visual-studio-code-debugging-home-assistant-ssh-version/</url>
    <content><![CDATA[<p>Visual Studio Code在WSL或容器远程调试，需要在本地安装相应的WSL或者Docker Desktop，如需要尽量保持本地环境的简洁，采用SSH方式是一个更好的选择。</p>
<hr>
<a id="more"></a>
<h2 id="0-环境"><a href="#0-环境" class="headerlink" title="0.环境"></a>0.环境</h2><ul>
<li>Win10 + OpenSSH</li>
<li>Ubuntu 18.04 + Docker CE 19.03.1</li>
<li>Visual Studio Code 1.38.0</li>
</ul>
<hr>
<h2 id="1-方法简介"><a href="#1-方法简介" class="headerlink" title="1.方法简介"></a>1.方法简介</h2><p>SSH方式通过远程到Linux主机上，使用Linux主机环境实现代码调试，实际上<a href="https://code.visualstudio.com/docs/remote/ssh" title="VS Code官方文档">VS Code官方文档</a>已有很完整教程，有疑问可以多翻翻。为了隔离测试环境，在此使用容器部署Linux环境。</p>
<hr>
<h2 id="2-准备"><a href="#2-准备" class="headerlink" title="2.准备"></a>2.准备</h2><h3 id="2-1-Windows"><a href="#2-1-Windows" class="headerlink" title="2.1.Windows"></a>2.1.Windows</h3><ul>
<li><p>安装OpenSSH客户端，Win10 1809 和 Windows Server 2019后系统默认安装好，其它版本下载<a href="https://github.com/PowerShell/Win32-OpenSSH/releases" title="Win32-OpenSSH releases">Win32-OpenSSH</a>解压后加入PATH环境变量即可，或看官方<a href="https://code.visualstudio.com/docs/remote/troubleshooting#_installing-a-supported-ssh-client" title="安装SSH客户端">教程</a>安装。</p>
</li>
<li><p>创建SSH钥匙对，会提示保存目录直接回车确认即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096</span><br></pre></td></tr></table></figure></li>
<li><p>将<code>%USERPROFILE%\.ssh\</code>目录下生成的id_rsa.pub（公匙）复制出来，将id_rsa（私匙）更名为id_rsa-hass-dev。</p>
<blockquote>
<p><strong>INFO：更名的目的是作为专用的钥匙。</strong></p>
</blockquote>
</li>
</ul>
<h2 id="2-2-Linux"><a href="#2-2-Linux" class="headerlink" title="2.2.Linux"></a>2.2.Linux</h2><ul>
<li><p>下载<a href="https://github.com/cnk700i/blog-attachment/tree/master/hass-dev" title="HA开发环境镜像Dockerfile">Dockerfile</a>，将上一步骤的id_rsa.pub放进同一个目录，然后上传至Docker宿主机。</p>
</li>
<li><p>进入Dockerfile文件所在目录，构建镜像。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> hass-dev</span><br><span class="line"><span class="comment"># PIP_SOURCE指定pip源，HA_VERSION指定版本号</span></span><br><span class="line">docker build -t hass-dev:0.98.0 --build-arg PIP_SOURCE=<span class="string">&quot;http://mirrors.aliyun.com/pypi/simple/&quot;</span> --build-arg HA_VERSION=<span class="string">&quot;0.98.0&quot;</span> .</span><br></pre></td></tr></table></figure>
<blockquote>
<p>__INFO：PIP_SOURCE建议用阿里的，比较新。__</p>
</blockquote>
</li>
<li><p>启动容器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -v ~/hass-dev-config:/usr/src/homeassistant/config -p 8022:22 -p 8456:8123 hass-dev:0.98.0</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：把配置目录映射出来方便备份；需要映射容器22端口；可以不设置映射HA的8123端口，后续在VS Code设置映射到本地访问。</strong></p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="3-VS-Code操作"><a href="#3-VS-Code操作" class="headerlink" title="3.VS Code操作"></a>3.VS Code操作</h2><ul>
<li>配置SSH连接信息。 
    <img src="/articles/visual-studio-code-debugging-home-assistant-ssh-version/c3_p1_%E6%89%93%E5%BC%80SSH%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png" class="" title="打开SSH配置文件">
  
 
    <img src="/articles/visual-studio-code-debugging-home-assistant-ssh-version/c3_p2_%E9%80%89%E6%8B%A9%E7%94%A8%E6%88%B7%E7%9B%AE%E5%BD%95%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png" class="" title="选择用户目录的配置文件">
  
 
    <img src="/articles/visual-studio-code-debugging-home-assistant-ssh-version/c3_p3_%E5%A2%9E%E5%8A%A0%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF.png" class="" title="增加主机信息">
  
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">Host</span> <span class="string">hass-dev</span>                             <span class="comment"># 主机名，自定义</span></span><br><span class="line">  <span class="string">User</span> <span class="string">root</span>                               <span class="comment"># 登录用户，不需要改动</span></span><br><span class="line">  <span class="string">HostName</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.10</span>                   <span class="comment"># 宿主机IP，根据实际调整</span></span><br><span class="line">  <span class="string">IdentityFile</span> <span class="string">~/.ssh/id_rsa-hass-dev</span>     <span class="comment"># 本地私钥文件</span></span><br><span class="line">  <span class="string">Port</span> <span class="number">8022</span>                               <span class="comment"># 容器映射的端口，根据实际调整</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：配置文件中应删掉注释。</strong></p>
</blockquote>
</li>
<li>连接远程主机（容器）。 
    <img src="/articles/visual-studio-code-debugging-home-assistant-ssh-version/c3_p4_%E5%BC%80%E5%A7%8B%E8%BF%9E%E6%8E%A5%E4%B8%BB%E6%9C%BA.png" class="" title="开始连接主机">
  
 
    <img src="/articles/visual-studio-code-debugging-home-assistant-ssh-version/c3_p5_%E9%80%89%E6%8B%A9%E4%B8%BB%E6%9C%BA.png" class="" title="选择主机">
    
 
    <img src="/articles/visual-studio-code-debugging-home-assistant-ssh-version/c3_p6_%E9%A6%96%E6%AC%A1%E8%BF%9E%E6%8E%A5%E4%BC%9A%E6%8F%90%E7%A4%BA%E7%A1%AE%E8%AE%A4.png" class="" title="c3_p6_首次连接会提示确认">
  </li>
<li>在远程主机（容器）上安装Python插件，代码调试需要。 
    <img src="/articles/visual-studio-code-debugging-home-assistant-ssh-version/c3_p7_%E6%88%90%E5%8A%9F%E8%BF%9E%E6%8E%A5%E4%B8%BB%E6%9C%BA%E5%90%8E%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6.png" class="" title="成功连接主机后安装插件">
  </li>
<li>打开主目录，开始调试。 
    <img src="/articles/visual-studio-code-debugging-home-assistant-ssh-version/c3_p8_%E5%8A%A0%E8%BD%BD%E4%B8%BB%E7%9B%AE%E5%BD%95.png" class="" title="加载主目录">
  
 
    <img src="/articles/visual-studio-code-debugging-home-assistant-ssh-version/c3_p9_%E5%BC%80%E5%A7%8B%E8%B0%83%E8%AF%95.png" class="" title="c3_p9_开始调试">
  

</li>
</ul>
<hr>
<h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><ul>
<li>官方的HA镜像貌似没有给Dockerfile，只得自己写，顺便精简了一些文件。</li>
<li>VS Code的三种远程调试方法整体上操作流程都一样，难点都是远程主机环境的搭建。</li>
</ul>
]]></content>
      <categories>
        <category>Home Assistant</category>
      </categories>
      <tags>
        <tag>Home Assistant</tag>
        <tag>VS Code</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Visual Studio Code调试Home Assistant代码（WSL版）</title>
    <url>/articles/visual-studio-code-debugging-home-assistant-wsl-version/</url>
    <content><![CDATA[<p>最近在瀚思彼岸看到M大的<a href="https://bbs.hassbian.com/thread-8054-1-1.html" title="[基础教程] 篇六：有些硬件太小众了怎么自己写插件">写插件教程帖子</a>提及用pycharm断点调试插件，想到自己一直以来开发插件全靠logging埋点看输出、研究HA核心功能代码依靠人肉追踪，真有点内牛满面。不过M大的调试方法不是放在普通原代码上的，貌似也没法追踪HA主程序代码，用的工具也不是自己熟悉的，于是乎狠下决心去折腾实现能用VS Code对HA代码进行直接调试，发现坑真不少。</p>
<hr>
<a id="more"></a>
<h2 id="0-环境"><a href="#0-环境" class="headerlink" title="0.环境"></a>0.环境</h2><ul>
<li>Win10 LTSC 2019 + WSL(Ubuntu 18.04)</li>
<li>Visual Studio Code 1.38.0</li>
</ul>
<hr>
<h2 id="1-问题及结论"><a href="#1-问题及结论" class="headerlink" title="1.问题及结论"></a>1.问题及结论</h2><p>这几天先是按官方的<a href="https://developers.home-assistant.io/docs/en/development_environment.html" title="官方的开发环境部署文档">搭建开发环境文档</a>去搭了（VS Code+容器）环境，结果发现压根没提到调试方面的操作。后来在官方的论坛中有搜到不少无法追踪断点的问题，不过没发现解决方法。再后来百度有人提及是目录位置问题才有了转机，瞎折腾测试一番总是解决了。</p>
<ul>
<li><p>问题</p>
<ul>
<li>pip安装后，使用<code>site-packages/homeassistant</code>安装目录作为VS Code主目录，运行会跳过所有断点，显示“未验证的断点”。 
      <img src="/articles/visual-studio-code-debugging-home-assistant-wsl-version/c1_p1_%E6%96%AD%E7%82%B9%E6%9C%AA%E9%AA%8C%E8%AF%81.png" class="" title="断点未验证">
    </li>
<li>在其它路径放置HA代码目录<code>homeassistant</code>作为VS Code主目录，断点在<code>__main__.py</code>程序入口373行之后就不停了。 
      <img src="/articles/visual-studio-code-debugging-home-assistant-wsl-version/c1_p2_%E5%90%8E%E7%BB%AD%E6%96%AD%E7%82%B9%E4%B8%8D%E5%81%9C.png" class="" title="后续断点不停">
    </li>
</ul>
</li>
<li><p>结论</p>
<ul>
<li>要正常调试需要Linux环境，并且不能用pip安装目录的代码。</li>
<li>要跟踪断点的代码需要在同一个VS Code主目录。</li>
</ul>
</li>
<li><p>解决方法</p>
<ul>
<li>将配置目录和程序代码放一起，这样可以<font color = 'red'>调试自定义组件。</font></li>
<li>HA程序代码使用了不少<code>from homeassistant import xx</code>方式导入包，如果以HA代码目录比如<code>d:\homeassistant</code>作为VS Code主目录，则运行点就跑到pip的<code>site-packages/homeassistant</code>安装目录里的代码去，所以需要利用Python的搜索优先规则，给HA代码目录加多一层上级目录，使得导入的是VS Code主目录下的HA代码，也就能<font color = 'red'>调试HA主程序代码</font>。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-准备"><a href="#2-准备" class="headerlink" title="2.准备"></a>2.准备</h2><ul>
<li><p>Windows下启用Linux子系统功能，开始菜单-&gt;设置-&gt;应用和功能-&gt;程序和功能-&gt;启用或关闭Windows功能-&gt;适用于Linux的Windows子系统。</p>
 
    <img src="/articles/visual-studio-code-debugging-home-assistant-wsl-version/c2_p1_%E5%BA%94%E7%94%A8%E8%AE%BE%E7%BD%AE%E5%85%A5%E5%8F%A3.png" class="" title="应用设置入口">
  
 
    <img src="/articles/visual-studio-code-debugging-home-assistant-wsl-version/c2_p2_%E5%90%AF%E7%94%A8%E5%AD%90%E7%B3%BB%E7%BB%9F.png" class="" title="启用子系统">
  
<p><strong>INFO：也可以PowerShell（管理员权限）运行Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux</strong><br><strong>INFO：安装完毕需要重启。</strong></p>
</li>
<li><p>下载Ubuntu 18.04安装包。<a href="https://docs.microsoft.com/zh-cn/windows/wsl/install-manual" title="手动下载适用于 Linux 的 Windows 子系统发行版包">下载地址</a></p>
<p><strong>INFO：也可以在Microsoft Store中安装，不过下载安装包安装可以选择安装路径。</strong></p>
</li>
<li><p>解压安装包至安装路径，运行<code>ubuntu1804.exe</code>进行注册。</p>
 
    <img src="/articles/visual-studio-code-debugging-home-assistant-wsl-version/c2_p3_%E5%AE%89%E8%A3%85Ubuntu%E5%AD%90%E7%B3%BB%E7%BB%9F.png" class="" title="安装Ubuntu子系统">
  

<p>__INFO：在Microsoft Store安装的安装路径是在C:\Users\ [用户名]\AppData\Local\Packages\CanonicalGroupLimited.Ubuntu18.04onWindows_79rhkp1fndgsc\LocalState\rootfs__</p>
</li>
</ul>
<hr>
<h2 id="3-VS-Code操作"><a href="#3-VS-Code操作" class="headerlink" title="3.VS Code操作"></a>3.VS Code操作</h2><ul>
<li><p>安装Remote Development插件，用于远程WSL调试</p>
 
    <img src="/articles/visual-studio-code-debugging-home-assistant-wsl-version/c3_p1_%E5%AE%89%E8%A3%85WSL%E6%8F%92%E4%BB%B6.png" class="" title="安装WSL插件">
  
<p><strong>INFO：实际上用到的是Remote - WSL插件，安装Remote Development插件会打包安装。</strong></p>
</li>
<li><p>打开远程窗口连接WSL，在WSL上安装Python插件，代码调试需要</p>
 
    <img src="/articles/visual-studio-code-debugging-home-assistant-wsl-version/c3_p2_%E6%96%B0%E5%BB%BAWSL%E7%AA%97%E5%8F%A3.png" class="" title="新建WSL窗口">
  
 
    <img src="/articles/visual-studio-code-debugging-home-assistant-wsl-version/c3_p3_%E5%AE%89%E8%A3%85Python%E6%8F%92%E4%BB%B6.png" class="" title="安装Python插件">
  
</li>
<li><p>WSL窗口下使用终端，在WSL上安装软件包，中途会有确认步骤</p>
 
    <img src="/articles/visual-studio-code-debugging-home-assistant-wsl-version/c3_p4_%E6%89%93%E5%BC%80Linux%E7%BB%88%E7%AB%AF.png" class="" title="打开Linux终端">
  
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># VS Code远程窗口的bash终端执行。PS：不嫌CMD辣眼睛也可以在CMD下敲命令安装。</span></span><br><span class="line">sudo su</span><br><span class="line">sed -i <span class="string">&quot;s@http://\(security.ubuntu.com\|archive.ubuntu.com\)@http://mirrors.aliyun.com@g&quot;</span> /etc/apt/sources.list &amp;&amp; \</span><br><span class="line">apt update &amp;&amp; \</span><br><span class="line">apt install python3-pip &amp;&amp; \</span><br><span class="line">mkdir -p ~/.pip/ &amp;&amp; \</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[global]&quot;</span> &gt; ~/.pip/pip.conf &amp;&amp; \</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;index-url = https://pypi.tuna.tsinghua.edu.cn/simple&quot;</span> &gt;&gt; ~/.pip/pip.conf &amp;&amp; \</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[install]&quot;</span> &gt;&gt; ~/.pip/pip.conf &amp;&amp; \</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;trusted-host = https://pypi.tuna.tsinghua.edu.cn&quot;</span> &gt;&gt; ~/.pip/pip.conf &amp;&amp; \</span><br><span class="line">pip3 install homeassistant</span><br></pre></td></tr></table></figure>
<p><strong>INFO：Ctrl+Shift+`打开新的终端。</strong></p>
</li>
</ul>
<hr>
<h2 id="4-准备代码目录"><a href="#4-准备代码目录" class="headerlink" title="4.准备代码目录"></a>4.准备代码目录</h2><ul>
<li>新建一个文件夹<code>d:\workspace</code>，作为VS Code主目录，内容如下：<ul>
<li>放入<code>homeassistant</code>目录，github下载指定版本HA取相应的文件夹即可。</li>
<li>新建<code>config</code>目录，作为HA配置目录。</li>
<li>新建<code>debug.py</code>，用于启动HA，内容如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> homeassistant <span class="keyword">import</span> __main__ <span class="keyword">as</span> hass_entry</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    sys.exit(hass_entry.main())</span><br></pre></td></tr></table></figure></li>
<li>用CMD命令新建<code>.vscode</code>目录<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="comment">rem 命令行下新建.vscode文件夹，直接右键新建会报错</span></span><br><span class="line"><span class="built_in">cd</span> d:\workspace</span><br><span class="line"><span class="built_in">mkdir</span> .vscode</span><br></pre></td></tr></table></figure></li>
<li><code>.vscode</code>目录下新建<code>launch.json</code>文件<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//launch.json内容</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用 IntelliSense 了解相关属性。 </span></span><br><span class="line">    <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">    <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Home Assistant Debug&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;python&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;program&quot;</span>: <span class="string">&quot;$&#123;workspaceRoot&#125;/debug.py&quot;</span>, <span class="comment">//运行HA</span></span><br><span class="line">            <span class="attr">&quot;console&quot;</span>: <span class="string">&quot;integratedTerminal&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [<span class="string">&quot;-c&quot;</span>, <span class="string">&quot;config&quot;</span>], <span class="comment">//指定配置文件</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>INFO：该步骤也可以打开文件夹后，在VS Code调试页添加配置，添加完配置后会生成对应文件。</strong></li>
</ul>
</li>
<li>最终目录结构如图 
    <img src="/articles/visual-studio-code-debugging-home-assistant-wsl-version/c4_p1_%E6%95%B4%E4%BD%93%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" class="" title="整体目录结构">
  

</li>
</ul>
<hr>
<h2 id="5-开始调试"><a href="#5-开始调试" class="headerlink" title="5.开始调试"></a>5.开始调试</h2><ul>
<li><p>加载主目录，有两种方法：</p>
<ul>
<li><p>先打开文件夹，再点左下角弹出选项选”Reopen Folder in WSL”</p>
 
      <img src="/articles/visual-studio-code-debugging-home-assistant-wsl-version/c5_p1_%E6%89%93%E5%BC%80%E6%9C%AC%E5%9C%B0%E7%9B%AE%E5%BD%95%E5%86%8D%E7%94%A8WSL%E9%87%8D%E6%96%B0%E5%8A%A0%E8%BD%BD.png" class="" title="打开本地目录再用WSL重新加载">
    
</li>
<li><p>点左下角弹出选项选”New Window”，在新建窗口再打开文件夹（WSL中的windows文件夹路径对应为<code>/mnt/[盘符]/[文件夹A]/[文件夹B]</code>）</p>
 
      <img src="/articles/visual-studio-code-debugging-home-assistant-wsl-version/c5_p2_%E6%89%93%E5%BC%80WSL%E7%AA%97%E5%8F%A3.png" class="" title="打开WSL窗口">
    
 
      <img src="/articles/visual-studio-code-debugging-home-assistant-wsl-version/c5_p3_WSL%E7%AA%97%E5%8F%A3%E5%8A%A0%E8%BD%BD%E7%9B%AE%E5%BD%95.png" class="" title="WSL窗口加载目录">
    
</li>
<li><p>后续可以快速重新打开</p>
 
      <img src="/articles/visual-studio-code-debugging-home-assistant-wsl-version/c5_p4_%E5%BF%AB%E9%80%9F%E6%89%93%E5%BC%80%E4%B8%BB%E7%9B%AE%E5%BD%95.png" class="" title="快速打开主目录">
    
</li>
</ul>
</li>
<li><p>设置python解析器，一般会自动识别出来，直接选择即可。</p>
 
    <img src="/articles/visual-studio-code-debugging-home-assistant-wsl-version/c5_p5_%E8%AE%BE%E7%BD%AEpython%E8%A7%A3%E9%87%8A%E5%99%A8.png" class="" title="设置python解释器">
  
<p><strong>INFO：WSL环境自带有3.6.8版本，Windows不用安装Python。</strong></p>
</li>
<li><p>按F5即可运行调试。</p>
 
    <img src="/articles/visual-studio-code-debugging-home-assistant-wsl-version/c5_p6_%E8%B0%83%E8%AF%95%E6%95%88%E6%9E%9C.png" class="" title="调试效果">
  
<p><strong>WARN：首次运行先不要设断点，待配置目录初始化完成后，再加入配置信息调试。</strong></p>
</li>
</ul>
<hr>
<h2 id="6-其它"><a href="#6-其它" class="headerlink" title="6.其它"></a>6.其它</h2><ul>
<li>有时候无法正常退出调试，会占用8123端口导致无法访问网页，需要手工终止一下进程。 
    <img src="/articles/visual-studio-code-debugging-home-assistant-wsl-version/c6_p1_%E5%8D%A0%E7%94%A8%E7%AB%AF%E5%8F%A3%E6%83%85%E5%86%B5%E4%B8%8B%E7%BB%88%E6%AD%A2%E8%BF%9B%E7%A8%8B.png" class="" title="占用端口情况下终止进程">
  
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo su</span><br><span class="line">ps -aux | grep python3 | grep config</span><br><span class="line"><span class="built_in">kill</span> -9 [进程号]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h2 id="7-小结"><a href="#7-小结" class="headerlink" title="7.小结"></a>7.小结</h2><ul>
<li>VS Code的远程调试挺有意思的，一开始看的是容器方式的文档，看得各种懵逼，后来改看WSL方式的发现简单不少，调试果然是一门水深的学问。</li>
</ul>
]]></content>
      <categories>
        <category>Home Assistant</category>
      </categories>
      <tags>
        <tag>Home Assistant</tag>
        <tag>VS Code</tag>
      </tags>
  </entry>
  <entry>
    <title>Zabbix+Grafana数据展示</title>
    <url>/articles/zabbix-grafana-data-show/</url>
    <content><![CDATA[<p>因工作需要搜了一些监控解决方案，发现zabbix还是挺多人推荐的，于是乎记录一下学习过程。<a href="https://ljr.im/articles/first-test-zabbix-monitoring-solution/" title="初试zabbix监控方案">上篇</a>已实现了设备数据采集，虽然zabbix自身也可以使用图形进行可视化展示，但用起来不太顺手，使用依旧是广受推荐的grafana进行展示。</p>
<hr>
<a id="more"></a>
<h2 id="0-环境"><a href="#0-环境" class="headerlink" title="0.环境"></a>0.环境</h2><ul>
<li>ubuntu 18.04</li>
<li>docker-ce 19.03.1</li>
<li>docker-compose 1.24.1</li>
<li>zabbix server 4.2.5</li>
<li>zabbix agent 1:4.2.5-1+bionic</li>
<li>grafana v6.3.2</li>
</ul>
<h2 id="1-grafana部署"><a href="#1-grafana部署" class="headerlink" title="1.grafana部署##"></a>1.grafana部署##</h2><p>依旧是docker-compose编排，加入之前的即可</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker-compose.yaml</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">grafana-data:</span></span><br><span class="line">  <span class="attr">grafana-etc:</span></span><br><span class="line">  <span class="attr">grafana-logs:</span></span><br><span class="line">  <span class="attr">grafana-home:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">grafana:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">grafana</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">grafana/grafana</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="comment"># - /data/grafana/plugins:/var/lib/grafana/plugins # 离线安装插件文件夹</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;grafana-data:/var/lib/grafana&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;grafana-etc:/etc/grafana/&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;grafana-logs:/var/log/grafana&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;grafana-home:/usr/share/grafana&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;monitor-app&#x27;</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;3000:3000&#x27;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;GF_INSTALL_PLUGINS=alexanderzobnin-zabbix-app&quot;</span> <span class="comment"># 安装zabbix插件，需联网</span></span><br><span class="line">    <span class="string">&lt;&lt;:</span> <span class="string">*logging-setting-template</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO: 在volumes、services层级加入相对应的配置即可。</strong></p>
</blockquote>
<hr>
<h2 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h2><p>访问http://宿主机ip:3000，登录。默认用户密码为<code>admin</code>:<code>admin</code></p>
 
  <img src="/articles/zabbix-grafana-data-show/c2_p1_%E7%99%BB%E9%99%86.png" class="" title="登陆">


<h3 id="2-1-配置数据源"><a href="#2-1-配置数据源" class="headerlink" title="2.1.配置数据源"></a>2.1.配置数据源</h3><p>grafana通过zabbix的接口获取数据。</p>
<ul>
<li><p>启用zabbix插件</p>
 
  <img src="/articles/zabbix-grafana-data-show/c2.1_p1_%E5%90%AF%E7%94%A8%E6%8F%92%E4%BB%B61.png" class="" title="启用插件1">

 
  <img src="/articles/zabbix-grafana-data-show/c2.1_p2_%E5%90%AF%E7%94%A8%E6%8F%92%E4%BB%B62.png" class="" title="启用插件2">

</li>
<li><p>配置zabbix信息</p>
 
  <img src="/articles/zabbix-grafana-data-show/c2.1_p3_%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E6%BA%901.png" class="" title="配置数据源1">

 
  <img src="/articles/zabbix-grafana-data-show/c2.1_p4_%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E6%BA%902.png" class="" title="配置数据源2">

 
  <img src="/articles/zabbix-grafana-data-show/c2.1_p5_%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E6%BA%903.png" class="" title="配置数据源3">

 
  <img src="/articles/zabbix-grafana-data-show/c2.1_p6_%E4%BF%9D%E5%AD%98%E6%B5%8B%E8%AF%95.png" class="" title="保存测试">


</li>
</ul>
<h3 id="2-2-主机仪表盘模板"><a href="#2-2-主机仪表盘模板" class="headerlink" title="2.2.主机仪表盘模板"></a>2.2.主机仪表盘模板</h3><p>zabbix插件自带有仪表盘模板，可以适配zabbix中官方模板所采集的数据。</p>
<ul>
<li><p>导入主机模板</p>
 
  <img src="/articles/zabbix-grafana-data-show/c2.2_p1_%E5%AF%BC%E5%85%A5%E4%B8%BB%E6%9C%BA%E6%A8%A1%E6%9D%BF1.png" class="" title="导入主机模板1">

 
  <img src="/articles/zabbix-grafana-data-show/c2.2_p2_%E5%AF%BC%E5%85%A5%E4%B8%BB%E6%9C%BA%E6%A8%A1%E6%9D%BF2.png" class="" title="导入主机模板2">

</li>
<li><p>打开仪表盘界面</p>
 
  <img src="/articles/zabbix-grafana-data-show/c2.2_p3_%E6%89%93%E5%BC%80dashboard.png" class="" title="打开dashboard">

 
  <img src="/articles/zabbix-grafana-data-show/c2.2_p3_%E4%B8%BB%E6%9C%BA%E7%9B%91%E6%8E%A7%E7%95%8C%E9%9D%A2.png" class="" title="主机监控界面">


</li>
</ul>
<h3 id="2-3-交换机仪表盘模板"><a href="#2-3-交换机仪表盘模板" class="headerlink" title="2.3.交换机仪表盘模板"></a>2.3.交换机仪表盘模板</h3><ul>
<li>导入交换机模板，这里是我做的一个模板，需要配合ziabbix模板使用，<a href="https://github.com/cnk700i/blog-attachment/tree/master/zabbix-grafana_templates" title="模板下载">下载地址</a> 
  <img src="/articles/zabbix-grafana-data-show/c2.3_p1_%E5%AF%BC%E5%85%A5%E6%A8%A1%E6%9D%BF1.png" class="" title="导入模板1">

 
  <img src="/articles/zabbix-grafana-data-show/c2.3_p2_%E5%AF%BC%E5%85%A5%E6%A8%A1%E6%9D%BF2.png" class="" title="导入模板2">

 
  <img src="/articles/zabbix-grafana-data-show/c2.3_p3_%E5%AF%BC%E5%85%A5%E6%A8%A1%E6%9D%BF3.png" class="" title="导入模板3">
</li>
<li>交换机监控信息 
  <img src="/articles/zabbix-grafana-data-show/c2.3_p4_%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9B%91%E6%8E%A7%E7%95%8C%E9%9D%A2.png" class="" title="交换机监控界面">


</li>
</ul>
<h3 id="2-4-配置项简介"><a href="#2-4-配置项简介" class="headerlink" title="2.4.配置项简介"></a>2.4.配置项简介</h3><ul>
<li><p>变量Variables，配置好的变量会在仪表盘界面左上方作为选择项出现，对应的值可以传到具体图形的查询项Query，这样图形的内容也会发生变化。</p>
 
  <img src="/articles/zabbix-grafana-data-show/c2.4_p1_%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E5%85%A5%E5%8F%A31.png" class="" title="变量配置入口1">

 
  <img src="/articles/zabbix-grafana-data-show/c2.4_p2_%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E5%85%A5%E5%8F%A32.png" class="" title="变量配置入口2">

</li>
<li><p>查询项Query，图形所展示的数据。</p>
 
  <img src="/articles/zabbix-grafana-data-show/c2.4_p3_%E7%BC%96%E8%BE%91%E5%9B%BE%E5%BD%A2%E5%85%A5%E5%8F%A3.png" class="" title="编辑图形入口">

 
  <img src="/articles/zabbix-grafana-data-show/c2.4_p4_%E8%AE%BE%E5%AE%9A%E6%9F%A5%E8%AF%A2%E9%A1%B9.png" class="" title="设定查询项">


</li>
</ul>
<blockquote>
<p><strong>INFO：grafana的图形配置涉及很多调整，个人了解有限很难说清楚，其实多摸索下基本就懂了。</strong></p>
</blockquote>
<hr>
<h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h2><ul>
<li>grafana中zabbix的数据组织层次为“群组”-“主机”-“应用集合”-“监控项”，这样可以定位具体要展示的数据。</li>
</ul>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Zabbix</tag>
        <tag>Grafana</tag>
      </tags>
  </entry>
  <entry>
    <title>Zabbix+微信企业号推送告警</title>
    <url>/articles/zabbix-wechat-enterprise-account-push-alarm/</url>
    <content><![CDATA[<p>因工作需要搜了一些监控解决方案，发现zabbix还是挺多人推荐的，于是乎记录一下学习过程。上篇使用grafana实现了数据可视化展示，可以通过web网页直观了解主机运行状况。为了及时了解到异常信息，可以使用zabbix的推送机制，实现告警信息的推送，</p>
<hr>
<a id="more"></a>

<h2 id="1-企业微信"><a href="#1-企业微信" class="headerlink" title="1.企业微信"></a>1.企业微信</h2><p>详细教程网上自行搜索，我是参照这个<a href="http://www.ttlsa.com/zabbix/use-wechat-send-zabbix-msg/" title="zabbix使用微信发送告警（附Python代码）">教程</a>，大体过程如下：</p>
<ul>
<li><p>注册企业微信，记录下ID，脚本调用API接口推送消息需要用到</p>
</li>
<li><p>成员加入企业微信，关注微工作台</p>
 
  <img src="/articles/zabbix-wechat-enterprise-account-push-alarm/c1_p1_%E5%8A%A0%E5%85%A5%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1.png" class="" title="加入企业微信">

 
  <img src="/articles/zabbix-wechat-enterprise-account-push-alarm/c1_p2_%E5%85%B3%E6%B3%A8%E5%BE%AE%E5%B7%A5%E4%BD%9C%E5%8F%B0.png" class="" title="关注微工作台">

<blockquote>
<p><strong>INFO：企业微信是一个独立APP，微工作台是微信中原先的企业号（类似公众号），关注微工作台就可以用微信接收消息。</strong></p>
</blockquote>
</li>
<li><p>通过通信录管理成员（可选）</p>
</li>
<li><p>创建应用，记录下应用ID（AgentId）、应用安全码（Secret），脚本调用API接口推送消息需要用到</p>
</li>
<li><p>设置应用可见范围（指定具体人员/部门可以使用应用）</p>
<blockquote>
<p><strong>INFO：分配应用的使用权限给指定人员，这样相关人员就可以接收该应用的消息。</strong></p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="2-zabbix"><a href="#2-zabbix" class="headerlink" title="2.zabbix"></a>2.zabbix</h2><h3 id="2-1-准备脚本"><a href="#2-1-准备脚本" class="headerlink" title="2.1.准备脚本"></a>2.1.准备脚本</h3><ul>
<li>放置py脚本至zabbix的监控脚本目录，此处使用docker方式部署，已对脚本目录进行了映射（详细见docker-compose.yaml），所以只要拷贝至宿主机的<code>/data/zabbix/alertscripts</code></li>
</ul>
 
  <img src="/articles/zabbix-wechat-enterprise-account-push-alarm/c2.1_p1_%E6%94%BE%E7%BD%AE%E8%84%9A%E6%9C%AC.png" class="" title="放置脚本.png">


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># sendToWeixin.py</span></span><br><span class="line">import requests</span><br><span class="line">import json</span><br><span class="line">import sys</span><br><span class="line">import logging</span><br><span class="line"></span><br><span class="line"><span class="comment"># 企业号及应用相关信息</span></span><br><span class="line">corp_id = <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">corp_secret = <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">agent_id = <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line"><span class="comment"># 存放access_token文件路径</span></span><br><span class="line">token_path = <span class="string">&#x27;/tmp/access_token.log&#x27;</span></span><br><span class="line"><span class="comment"># 日志文件路径</span></span><br><span class="line">log_path = <span class="string">&#x27;/tmp/send.log&#x27;</span></span><br><span class="line">logging.basicConfig(level=logging.INFO,<span class="comment">#控制台打印的日志级别</span></span><br><span class="line">                    filename=log_path,</span><br><span class="line">                    filemode=<span class="string">&#x27;a&#x27;</span>,<span class="comment">##模式，有w和a，w就是写模式，每次都会重新写日志，覆盖之前的日志；#a是追加模式，默认如果不写的话，就是追加模式</span></span><br><span class="line">                    format=<span class="string">&#x27;%(asctime)s - %(pathname)s[line:%(lineno)d] - %(levelname)s: %(message)s&#x27;</span><span class="comment">#日志格式</span></span><br><span class="line">                    )</span><br><span class="line"></span><br><span class="line">def get_access_token_from_file():</span><br><span class="line">    try:</span><br><span class="line">        f = open(token_path,<span class="string">&#x27;r+&#x27;</span>)</span><br><span class="line">        this_access_token = f.read()</span><br><span class="line">        logging.debug(<span class="string">&#x27;get success %s&#x27;</span> % this_access_token)</span><br><span class="line">        f.close()</span><br><span class="line">        <span class="built_in">return</span> this_access_token</span><br><span class="line">    except Exception as e:</span><br><span class="line">        logging.debug(e)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取token函数，文本里记录的token失效时调用</span></span><br><span class="line">def get_access_token():</span><br><span class="line">    get_token_url = <span class="string">&#x27;https://qyapi.weixin.qq.com/cgi-bin/gettoken?corpid=%s&amp;corpsecret=%s&#x27;</span> % (corp_id, corp_secret)</span><br><span class="line">    logging.debug(get_token_url)</span><br><span class="line">    r = requests.get(get_token_url)</span><br><span class="line">    request_json = r.json()</span><br><span class="line">    this_access_token = request_json[<span class="string">&#x27;access_token&#x27;</span>]</span><br><span class="line">    logging.debug(this_access_token)</span><br><span class="line">    r.close()</span><br><span class="line">    <span class="comment"># 把获取到的access_token写入文本</span></span><br><span class="line">    try:</span><br><span class="line">        f = open(token_path,<span class="string">&#x27;w+&#x27;</span>)</span><br><span class="line">        f.write(this_access_token)</span><br><span class="line">        f.close()</span><br><span class="line">    except Exception as e:</span><br><span class="line">        logging.debug(e)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回获取到的access_token值</span></span><br><span class="line">    <span class="built_in">return</span> this_access_token</span><br><span class="line"></span><br><span class="line"><span class="comment"># snedMessage</span></span><br><span class="line">retry = 2</span><br><span class="line"><span class="keyword">while</span>(retry&gt;0):</span><br><span class="line">    retry -= 1</span><br><span class="line">    <span class="comment"># 从文本获取access_token</span></span><br><span class="line">    access_token = get_access_token_from_file()</span><br><span class="line">    try:</span><br><span class="line">        to_user = <span class="string">&#x27;@all&#x27;</span></span><br><span class="line">        message = sys.argv[2]+<span class="string">&#x27;\n&#x27;</span>+sys.argv[3]</span><br><span class="line">        inputArg = <span class="string">&#x27; &#x27;</span>.join(str(i) <span class="keyword">for</span> i <span class="keyword">in</span> sys.argv)</span><br><span class="line">        logging.debug(<span class="string">&#x27;cmd: &#x27;</span>+inputArg)</span><br><span class="line"></span><br><span class="line">        send_message_url = <span class="string">&#x27;https://qyapi.weixin.qq.com/cgi-bin/message/send?access_token=%s&#x27;</span> % access_token</span><br><span class="line">        logging.debug(send_message_url)</span><br><span class="line">        message_params = &#123;</span><br><span class="line">                            <span class="string">&quot;touser&quot;</span>:to_user,</span><br><span class="line">                            <span class="string">&quot;msgtype&quot;</span>:<span class="string">&quot;text&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;agentid&quot;</span>:agent_id,</span><br><span class="line">                            <span class="string">&quot;text&quot;</span>:&#123;</span><br><span class="line">                                <span class="string">&quot;content&quot;</span> : message</span><br><span class="line">                            &#125;,</span><br><span class="line">                            <span class="string">&quot;safe&quot;</span>:0</span><br><span class="line">                        &#125;</span><br><span class="line">        <span class="comment"># markdown消息模板</span></span><br><span class="line">        <span class="comment"># markdown_message = &#123;</span></span><br><span class="line">        <span class="comment">#     &quot;touser&quot; : &quot;@all&quot;,</span></span><br><span class="line">        <span class="comment">#     &quot;msgtype&quot;: &quot;markdown&quot;,</span></span><br><span class="line">        <span class="comment">#     &quot;agentid&quot; : agent_id,</span></span><br><span class="line">        <span class="comment">#     &quot;markdown&quot;: &#123;</span></span><br><span class="line">        <span class="comment">#         &quot;content&quot;: &quot;您的会议室已经预定，稍后会同步到`邮箱`\r\</span></span><br><span class="line">        <span class="comment">#             &gt;**事项详情**\r\</span></span><br><span class="line">        <span class="comment">#             &gt;事　项：&lt;font color=\&quot;info\&quot;&gt;开会&lt;/font&gt;\r\</span></span><br><span class="line">        <span class="comment">#             &gt;组织者：@miglioguan\r\</span></span><br><span class="line">        <span class="comment">#             &gt;参与者：@miglioguan、@kunliu、@jamdeezhou、@kanexiong、@kisonwang\r\</span></span><br><span class="line">        <span class="comment">#             &gt;\r\</span></span><br><span class="line">        <span class="comment">#             &gt;会议室：&lt;font color=\&quot;info\&quot;&gt;广州TIT 1楼 301&lt;/font&gt;\r\</span></span><br><span class="line">        <span class="comment">#             &gt;日　期：&lt;font color=\&quot;warning\&quot;&gt;2018年5月18日&lt;/font&gt;\r\</span></span><br><span class="line">        <span class="comment">#             &gt;时　间：&lt;font color=\&quot;comment\&quot;&gt;上午9:00-11:00&lt;/font&gt;\r\</span></span><br><span class="line">        <span class="comment">#             &gt;\r\</span></span><br><span class="line">        <span class="comment">#             &gt;请准时参加会议。\r\</span></span><br><span class="line">        <span class="comment">#             &gt;\r\</span></span><br><span class="line">        <span class="comment">#             &gt;如需修改会议信息，请点击：[修改会议信息](https://work.weixin.qq.com)&quot;</span></span><br><span class="line">        <span class="comment">#     &#125;</span></span><br><span class="line">        <span class="comment"># &#125;</span></span><br><span class="line">        <span class="comment"># message_params = markdown_message</span></span><br><span class="line">        r = requests.post(send_message_url, data=json.dumps(message_params))</span><br><span class="line">        logging.debug(<span class="string">&#x27;post success %s &#x27;</span> % r.text)</span><br><span class="line">        request_json = r.json()</span><br><span class="line">        errmsg = request_json[<span class="string">&#x27;errmsg&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> errmsg == <span class="string">&#x27;ok&#x27;</span>:</span><br><span class="line">            retry = 0</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            access_token = get_access_token()</span><br><span class="line">    except Exception as e:</span><br><span class="line">        logging.error(e)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：企业微信APP才支持markdown格式的消息。</strong></p>
</blockquote>
<ul>
<li>设置可执行权限</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /data/zabbix/alertscripts <span class="comment"># 脚本目录（宿主机）</span></span><br><span class="line">chmod 755 sendToWeixin.py <span class="comment"># 设置可执行权限</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>WARN：脚本有对文件读写操作，如果以root用户执行脚本测试，需将/tmp目录下的log文件删除，避免zabbix-server进程（zabbix用户）因权限问题执行失败。</strong></p>
</blockquote>
<ul>
<li>zabbix-server安装运行环境</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it zabbix-server bash <span class="comment"># 进入容器</span></span><br><span class="line">apk add python3 <span class="comment"># 安装python环境</span></span><br><span class="line">pip3 install requests <span class="comment"># 安装requests包</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：容器镜像是基于alpine的，没有带python环境，所以需要另外安装。</strong></p>
</blockquote>
<h3 id="2-2-报警媒介"><a href="#2-2-报警媒介" class="headerlink" title="2.2.报警媒介"></a>2.2.报警媒介</h3><ul>
<li>创建报警媒介类型</li>
</ul>
 
  <img src="/articles/zabbix-wechat-enterprise-account-push-alarm/c2.2_p1_%E6%96%B0%E5%A2%9E%E6%8A%A5%E8%AD%A6%E5%AA%92%E4%BB%8B%E5%85%A5%E5%8F%A3.png" class="" title="新增报警媒介入口">


 
  <img src="/articles/zabbix-wechat-enterprise-account-push-alarm/c2.2_p2_%E6%96%B0%E5%A2%9E%E6%8A%A5%E8%AD%A6%E5%AA%92%E4%BB%8B.png" class="" title="新增报警媒介">

<blockquote>
<p><strong>INFO：使用了自定义脚本处理，传入参数使用了宏，对应后面用户关联报警媒介、动作中设置的信息。</strong></p>
</blockquote>
<ul>
<li>用户关联报警媒介，指定用户接收报警的类型、收报警的时段。</li>
</ul>
 
  <img src="/articles/zabbix-wechat-enterprise-account-push-alarm/c2.2_p3_%E7%94%A8%E6%88%B7%E9%85%8D%E7%BD%AE%E5%85%A5%E5%8F%A3.png" class="" title="用户配置入口">

 
  <img src="/articles/zabbix-wechat-enterprise-account-push-alarm/c2.2_p4_%E7%94%A8%E6%88%B7%E5%85%B3%E8%81%94%E6%8A%A5%E8%AD%A6%E5%AA%92%E4%BB%8B.png" class="" title="用户关联报警媒介">


<h3 id="2-3-动作"><a href="#2-3-动作" class="headerlink" title="2.3.动作"></a>2.3.动作</h3><p>动作是设定特定事件发生后触发的操作，比如触发器告警事件出现，发送消息通知特定人员。可以配置触发条件（例如特定的触发器）、消息模板、发送消息方式、发送目标。</p>
 
  <img src="/articles/zabbix-wechat-enterprise-account-push-alarm/c2.3_p1_%E6%96%B0%E5%A2%9E%E5%8A%A8%E4%BD%9C%E5%85%A5%E5%8F%A3.png" class="" title="新增动作入口">

 
  <img src="/articles/zabbix-wechat-enterprise-account-push-alarm/c2.3_p2_%E8%AE%BE%E7%BD%AE%E5%8A%A8%E4%BD%9C%E5%90%8D%E7%A7%B0.png" class="" title="设置动作名称">

 
  <img src="/articles/zabbix-wechat-enterprise-account-push-alarm/c2.3_p3_%E5%BC%82%E5%B8%B8%E9%80%9A%E7%9F%A5%E9%85%8D%E7%BD%AE1.png" class="" title="异常通知配置1">

 
  <img src="/articles/zabbix-wechat-enterprise-account-push-alarm/c2.3_p4_%E5%BC%82%E5%B8%B8%E9%80%9A%E7%9F%A5%E9%85%8D%E7%BD%AE2.png" class="" title="异常通知配置2">

 
  <img src="/articles/zabbix-wechat-enterprise-account-push-alarm/c2.3_p5_%E6%81%A2%E5%A4%8D%E9%80%9A%E7%9F%A5%E9%85%8D%E7%BD%AE.png" class="" title="恢复通知配置">

<blockquote>
<p><strong>INFO：更新操作的配置类似。</strong></p>
</blockquote>
<h3 id="3-测试"><a href="#3-测试" class="headerlink" title="3.测试"></a>3.测试</h3><p>停止监控主机上zabbix agent服务，5分钟之后zabbix server会出现告警，同时企业微信也收到告警消息。</p>
 
  <img src="/articles/zabbix-wechat-enterprise-account-push-alarm/c3_p1_zabbix%E5%91%8A%E8%AD%A6%E6%B6%88%E6%81%AF.png" class="" title="zabbix告警消息">

 
  <img src="/articles/zabbix-wechat-enterprise-account-push-alarm/c3_p2_%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E5%91%8A%E8%AD%A6%E6%B6%88%E6%81%AF.png" class="" title="企业微信告警消息">


<h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h3><ul>
<li>要做精细化的通知，可以结合zabbix用户关联报警媒介所设置的收件人参数、修改脚本为通知相应企业微信用户来实现。</li>
<li>后续可以通过zabbix的API接口，在企业微信应用中实现主动查询状态的功能。</li>
</ul>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title>docker从入门到入坑的四个阶段</title>
    <url>/articles/the-four-stages-of-docker-from-entry-to-pit/</url>
    <content><![CDATA[<p>刚开始接触docker的时候是去年尝试给Home Assistant做自动化安装node-red，全过程一脸懵逼按教程拷打命令，最后还写了篇<a href="https://ljr.im/articles/docker-installation-using-nodered-practice/" title="docker安装使用Node-RED实践">实践记录</a>。后来也一直在用docker，但理解还是一直停留在刚开始，命令倒是熟悉了不少。最近突然沉迷学习docker，陆续将web、mysql服务都迁到docker容器里面运行了，也逐渐有了更清晰的认识，也是时候回顾做个总结，希望能给新接触docker的朋友解惑。目前docker的学习资料很容易找，在此就不打算详细介绍各种命令，只挑选常用的命令结合自己的使用情况进行介绍，目的在于帮助快速建立对docker的认识。</p>
<hr>
<a id="more"></a>
<h2 id="0-基本概念"><a href="#0-基本概念" class="headerlink" title="0.基本概念"></a>0.基本概念</h2><ul>
<li>仓库（Repository）：卖Windows 10、Windows 7、Windows XP安装盘的商店</li>
<li>镜像（images）：Windows 10/Windows 7/Windows XP安装盘</li>
<li>容器（container）：安装Windows 10/Windows 7/Windows XP的电脑</li>
</ul>
<p>创建容器，就像买一台新电脑，安装指定镜像的系统；删除容器，就像把电脑扔了，如果不保存资料，那电脑里面资料就没了。</p>
<h2 id="1-阶段一-跑容器"><a href="#1-阶段一-跑容器" class="headerlink" title="1.阶段一 跑容器"></a>1.阶段一 跑容器</h2><ul>
<li>docker pull</li>
</ul>
<p>下载镜像。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull nodered/node-red-docker:last</span><br><span class="line"><span class="comment"># 参数解析</span></span><br><span class="line"><span class="comment"># [nodered/node-red-docker:last] 镜像名称，格式REPOSITORY:TAG（仓库：标签），如果指定标签自动默认为:last</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：镜像默认从公有仓库（在hub.docker.com搜索镜像）进行下载，如果是私有仓库下载，则还需指定服务器地址。</strong></p>
</blockquote>
<ul>
<li>docker run</li>
</ul>
<p>使用镜像创建一个容器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 1888:1880 -v /<span class="built_in">local</span>/workdir:/contianer/workdir --name docker-nodered nodered/node-red-docker npm start -- --userDir /data</span><br><span class="line"><span class="comment"># 参数解析</span></span><br><span class="line"><span class="comment"># [-d] 后台运行，如果不加-d，容器的输出会直接显示</span></span><br><span class="line"><span class="comment"># [-p 主机端口:容器端口] 映射端口，容器端口和容器服务相关，这里镜像的nodered服务用了1880端口，映射主机的1888，这样访问主机IP:1888就可以访问容器内的nodered服务了</span></span><br><span class="line"><span class="comment"># [-v /local/workdir:/contianer/workdir] 映射文件夹，将主机的/local/workdir目录映射到容器内的/contianer/workdir目录，容器内访问/contianer/workdir就可以访问主机/local/workdir的资源了</span></span><br><span class="line"><span class="comment"># [--name docker-nodered] 设置容器名称为docker-nodered，不指定会随机生成</span></span><br><span class="line"><span class="comment"># [nodered/node-red-docker] 镜像名称</span></span><br><span class="line"><span class="comment"># [npm start -- --userDir /data] 启动命令，位于镜像名称后面，是设置容器启动后执行的命令。这里的例子实际上是镜像中已经预设好的命令，目的是运行nodered。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>INFO：启动命令如果设置其它命令，会覆盖镜像中预设的命令，比如echo HelloWorld，那创建的容器就作用也就是echo HelloWorld，不会运行nodered服务了。</strong></p>
</blockquote>
<ul>
<li>docker ps</li>
</ul>
<p>查看容器信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br><span class="line"><span class="comment"># 参数解析</span></span><br><span class="line"><span class="comment"># [-a] 查看所有容器，不带则只显示运行中的容器</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>INFO：执行后可以看到CONTAINER ID（容器ID）,IMAGE（镜像名称）,COMMAND（启动命令）,CREATED（创建时间）,STATUS（运行状态）,PORTS（映射端口）,NAMES（容器名称）等信息，其中容器ID和容器名称比较有用。</strong></p>
</blockquote>
<ul>
<li>docker start/stop/restart/rm</li>
</ul>
<p>容器的启、停、删。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker start docker-nodered</span><br><span class="line"><span class="comment"># 参数解析</span></span><br><span class="line"><span class="comment"># [docker-nodered] 操作的容器名称/容器ID</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>INFO：运行中的容器是无法删除的，需要先停止。</strong></p>
</blockquote>
<ul>
<li>docker logs</li>
</ul>
<p>查看容器输出日志。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker logs -f docker-nodered</span><br><span class="line"><span class="comment"># 参数解析</span></span><br><span class="line"><span class="comment"># [-f] 跟随日志输出不断显示</span></span><br><span class="line"><span class="comment"># [docker-nodered] 操作的容器名称/容器ID</span></span><br></pre></td></tr></table></figure>

<h2 id="2-阶段二-修改容器"><a href="#2-阶段二-修改容器" class="headerlink" title="2.阶段二 修改容器"></a>2.阶段二 修改容器</h2><ul>
<li>docker exec</li>
</ul>
<p>在运行的容器中执行命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it docker-nodered bash</span><br><span class="line"><span class="comment"># 参数解析</span></span><br><span class="line"><span class="comment"># [-it] 分配一个伪终端，并接管其stdin/stdout支持交互操作，这时候bash命令不会自动退出</span></span><br><span class="line"><span class="comment"># [docker-nodered] 操作的容器名称/容器ID</span></span><br><span class="line"><span class="comment"># [bash] shell程序，对于alpine内核的镜像则用sh</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：执行bash/sh，相当于运行了一个命令行终端（类似ssh），运行效果就是登陆进入容器的内部系统了。</strong><br><strong>INFO：当然你也可以执行echo HelloWorld、ps aux之类的命令。</strong></p>
</blockquote>
<ul>
<li>docker commit</li>
</ul>
<p>保存容器成为一个新的镜像。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker commit docker-nodered my-nodered:custom</span><br><span class="line"><span class="comment"># 参数解析</span></span><br><span class="line"><span class="comment"># [docker-nodered] 操作的容器名称/容器ID</span></span><br><span class="line"><span class="comment"># [my-nodered:custom] 镜像名称，格式REPOSITORY:TAG（仓库：标签）</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：结合docker exec命令使用，进入容器后修改文件、安装程序等操作后，保存成新新镜像；后面用新镜像创建的容器就会有先前操作产生的内容。</strong></p>
</blockquote>
<ul>
<li>镜像维护</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看镜像信息</span></span><br><span class="line">docker images</span><br><span class="line"><span class="comment"># 重命名镜像</span></span><br><span class="line">docker tag IMAGEID(镜像id) REPOSITORY:TAG（仓库：标签）</span><br><span class="line"><span class="comment"># 删除镜像</span></span><br><span class="line">docker rmi IMAGEID(镜像id)</span><br></pre></td></tr></table></figure>

<ul>
<li>修改容器配置</li>
</ul>
<p>docker run命令设置了容器的配置信息，如果需要修改配置信息，一般是删除容器，重新再docker run。但也可以通过修改容器的配置文件来达到修改的目的，以修改端口映射为例。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. 停止容器</span><br><span class="line">2. 停止docker服务（systemctl stop docker）</span><br><span class="line">3. 修改这个容器的配置文件（hostconfig.json、config.v2.json）</span><br><span class="line">    <span class="built_in">cd</span> /var/lib/docker/containers/3b6ef264a040* <span class="comment"># 这里是CONTAINER ID</span></span><br><span class="line">    vi hostconfig.json <span class="comment"># 在&quot;PortBindings&quot;属性下增加/修改映射记录：&quot;PortBindings&quot;:&#123;&quot;3306/tcp&quot;:[&#123;&quot;HostIp&quot;:&quot;&quot;,&quot;HostPort&quot;:&quot;3307&quot;&#125;]&#125;，前一个数字是容器端口, 后一个是宿主机端口。</span></span><br><span class="line">    vi config.v2.json  <span class="comment"># 在&quot;Ports&quot;属性下增加/修改映射记录。</span></span><br><span class="line">4. 启动止docker服务（systemctl start docker）</span><br><span class="line">5. 启动容器</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：类似地可以更改目录映射，感觉通过docker run命令或者Dockerfile里命令设定的参数都可以通过修改hostconfig.json、config.v2.json来进行变更。</strong></p>
</blockquote>
<h2 id="3-阶段三-定制镜像"><a href="#3-阶段三-定制镜像" class="headerlink" title="3.阶段三 定制镜像"></a>3.阶段三 定制镜像</h2><ul>
<li>docker build</li>
</ul>
<p>使用指定的Dockerfile创建镜像。Dockerfile是一个文件，类似脚本，build后会生成一个镜像。Dockerfile的执行效果类似于：创建一个容器、进容器安装新软件/服务、然后提交成为新镜像。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -f /path/to/a/Dockerfile -t my-nodered:custom --no-cache .</span><br><span class="line"><span class="comment"># 参数解析</span></span><br><span class="line"><span class="comment"># [-f] 指定Dockerfile文件，不指定则默认上下文目录的Dockerfile文件</span></span><br><span class="line"><span class="comment"># [my-nodered:custom] 镜像名称，格式REPOSITORY:TAG（仓库：标签），不使用参数则默认生成None:None名称</span></span><br><span class="line"><span class="comment"># [--no-cache] 设置不使用缓存，不使用该参数则在build过程中会从上次出错的步骤继续执行</span></span><br><span class="line"><span class="comment"># [.] 指定上下文目录，.代表当前目录</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：在此不展开介绍Dockerfile了，可以从官方仓库看镜像的Dockerfile，重点学习理解其中的RUN、ENTRYPOINT、CMD指令。</strong></p>
</blockquote>
<h2 id="4-阶段四-批量部署"><a href="#4-阶段四-批量部署" class="headerlink" title="4.阶段四 批量部署"></a>4.阶段四 批量部署</h2><ul>
<li>docker-compose</li>
</ul>
<p>批量运行docker-compose.yml中预定义的容器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose -f /path/to/a/docker-compose.yml -d up</span><br><span class="line"><span class="comment"># 参数解析</span></span><br><span class="line"><span class="comment"># [-f] 指定docker-compose.yml文件，不指定则默认当前目录docker-compose.yml文件</span></span><br><span class="line"><span class="comment"># [-d] 后台运行</span></span><br><span class="line"><span class="comment"># [up] 创建并运行作为服务的容器，如果已经存在服务的容器，且容器创建后服务的配置有变化，就重新创建容器。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：docker-compose引入了服务管理模式，docker-compose start/stop是控制某个服务容器启停，docker-compose down是删除所有服务容器。</strong></p>
</blockquote>
<ul>
<li>docker-compose.yml样例</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker-compose.yml</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span> <span class="comment"># 指定语法的版本</span></span><br><span class="line"><span class="attr">services:</span> <span class="comment"># 定义服务</span></span><br><span class="line">    <span class="attr">nginx:</span> <span class="comment"># 服务的名称</span></span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">web-nginx</span> <span class="comment"># 容器的名称，不指定默认&quot;项目名称_服务名称_序号&quot;，其中项目名称默认为docker-compose.yaml所在目录的目录名称</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:latest</span> <span class="comment"># 镜像名称</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="string">always</span> <span class="comment"># 重启方式</span></span><br><span class="line">        <span class="attr">ports:</span> <span class="comment"># 端口映射</span></span><br><span class="line">          <span class="bullet">-</span> <span class="number">80</span><span class="string">:80</span></span><br><span class="line">        <span class="attr">volumes:</span> <span class="comment"># 主机与容器目录映射</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">./webserver:/webserver</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">./nginx/nginx.conf:/etc/nginx/nginx.conf</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：配置文件中的对容器的设置，实际上用docker run命令来设置也能达到相同的效果。</strong></p>
</blockquote>
<h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h2><ul>
<li>不要docker run一个ubuntu镜像，然后docker exec进入里面装很多应用来当虚拟机用。</li>
<li>Dockerfile是一个创建镜像的脚本，配合docker build命令使用。</li>
<li>docker-compose.yml是一个定义了多个容器的配置文件，配合docker-compose工具使用（需要另行安装）。</li>
</ul>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker安装使用Node-RED实践</title>
    <url>/articles/docker-installation-using-nodered-practice/</url>
    <content><![CDATA[<blockquote>
<p>最近了解到Node-RED，感觉配合HA做自动化挺不错的，于是折腾一番，搭个环境来学习学习。</p>
</blockquote>
<hr>
<a id="more"></a>

<h2 id="1-准备"><a href="#1-准备" class="headerlink" title="1.准备"></a>1.准备</h2><p>Ubuntu 18.04 64位</p>
<h2 id="2-过程"><a href="#2-过程" class="headerlink" title="2.过程"></a>2.过程</h2><h3 id="2-1-安装docker"><a href="#2-1-安装docker" class="headerlink" title="2.1.安装docker"></a>2.1.安装docker</h3><blockquote>
<p>版本强迫症，所以按<a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/" title="Get Docker CE for Ubuntu">官网教程</a>来装最新社区版。</p>
</blockquote>
<p>1）安装依赖的工具</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install apt-transport-https ca-certificates curlsoftware-properties-common</span><br></pre></td></tr></table></figure>

<p>2）获取官方GPG key</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudoapt-key add -</span><br></pre></td></tr></table></figure>

<p>3）增加软件源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo add-apt-repository <span class="string">&quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu <span class="subst">$(lsb_release -cs)</span> stable&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>__DEBUG：之前踩坑，18.04刚出还没有源，需要手动替换$(lsb_release -cs)为17.10版本的源artful__</p>
</blockquote>
<p>4）更新源索引</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br></pre></td></tr></table></figure>

<p>5）安装docker-ce</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install docker-ce</span><br></pre></td></tr></table></figure>
<h3 id="2-2-设置免sudo执行docker命令"><a href="#2-2-设置免sudo执行docker命令" class="headerlink" title="2.2.设置免sudo执行docker命令"></a>2.2.设置免sudo执行docker命令</h3><p>1）将当前用户加入docker组</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo gpasswd -a <span class="variable">$&#123;USER&#125;</span> docker</span><br></pre></td></tr></table></figure>
<p>2）重启docker</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo service docker restart</span><br></pre></td></tr></table></figure>
<p>3）刷新docker组</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ newgrp -docker</span><br></pre></td></tr></table></figure>
<h2 id="3-安装Node-RED"><a href="#3-安装Node-RED" class="headerlink" title="3.安装Node-RED"></a>3.安装Node-RED</h2><p>1）获取node-red镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker pull nodered/node-red-docker</span><br></pre></td></tr></table></figure>
<p>2）创建docker-nodered容器，运行node-red镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -d -p 1880:1880 --name docker-nodered --user=root nodered/node-red-docker</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>WARN：增加–user=root参数以获取root权限。</strong><br>3）进入Docker容器</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it docker-nodered /bin/bash</span><br><span class="line">root@容器ID:/usr/src/node-red<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：执行命令后切换到虚拟机环境了，系统也是Ubuntu</strong></p>
</blockquote>
<h2 id="4-升级node-js"><a href="#4-升级node-js" class="headerlink" title="4.升级node.js"></a>4.升级node.js</h2><blockquote>
<p>镜像自带的node.js版本是6.x的，而看github项目介绍node-red-contrib-home-assistant插件需求环境是&gt;8.0</p>
<p><strong>DEBUG：后续的“docker#”表示是在docker容器环境操作。</strong><br>1）检查版本</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker<span class="comment"># node -v</span></span><br></pre></td></tr></table></figure>
<p>2）清除node缓存；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker<span class="comment"># npm cache clean -f  </span></span><br></pre></td></tr></table></figure>
<p>3）安装node版本管理工具’n’</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker<span class="comment"># npm install n -g</span></span><br></pre></td></tr></table></figure>
<p>4）使用版本管理工具安装指定node或者升级到最新node版本，实测最新版本10.3.0不行，装8.11.2吧</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker<span class="comment"># n 8.11.2</span></span><br></pre></td></tr></table></figure>
<p>5）使用node -v查看node版本，如果版本号改变为你想要的则升级成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker<span class="comment"># node -v</span></span><br></pre></td></tr></table></figure>
<h2 id="5-安装插件"><a href="#5-安装插件" class="headerlink" title="5.安装插件"></a>5.安装插件</h2><blockquote>
<p>此步骤也可以在web端操作</p>
</blockquote>
<p>1）切换/data目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker<span class="comment"># cd /data</span></span><br></pre></td></tr></table></figure>
<p>2）安装插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker<span class="comment"># npm install node-red-contrib-home-assistant</span></span><br></pre></td></tr></table></figure>
<p>3）退出docker容器环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker<span class="comment"># exit</span></span><br></pre></td></tr></table></figure>
<p>4）重启容器，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker restart docker-nodered</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>DEBUG：容器名“docker-nodered”是之前docker run指定的</strong></p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Home Assistant</category>
      </categories>
      <tags>
        <tag>Home Assistant</tag>
        <tag>docker</tag>
        <tag>Node-RED</tag>
      </tags>
  </entry>
  <entry>
    <title>【插件·改】升级Home Assistant官方博联和空调伴侣插件的红外功能</title>
    <url>/articles/plugins-and-changes-upgrade-the-infrared-function-of-home-assistant-official-blog-air-conditioner-companion-plugin/</url>
    <content><![CDATA[<p>现在使用的两个插件<a href="https://github.com/home-assistant/home-assistant/blob/0.80.0/homeassistant/components/switch/broadlink.py" title="broadlink.py">switch/broadlink.py（官方自带）</a>、<a href="https://github.com/syssi/xiaomi_airconditioningcompanion/blob/develop/custom_components/climate/xiaomi_miio.py" title="xiaomi_miio.py">climate/xiaomi_miio.py（syssi大神的）</a>，都是一个设备初始化一个服务，然后以红外码作为传入参数进行调用。如果想调用预设的红外码，得配置成switch或script之类的entity，间接调用service发送红外码，假如要使用按键多的电视遥控器，会额外生成很多entity。另外，一个博联RM或者空调伴侣生成一个service，会让HA的service列表很长，特别加上一个script会独立生成一个servcie，会长得令人崩溃。于是乎对两个插件改造了一下。</p>
<hr>
<h2 id="0-插件说明"><a href="#0-插件说明" class="headerlink" title="0. 插件说明"></a>0. 插件说明</h2><ul>
<li>下载地址<ul>
<li><a href="https://github.com/cnk700i/ha_modified_components">https://github.com/cnk700i/ha_modified_components</a></li>
</ul>
</li>
</ul>
<blockquote>
<p>__INFO：连带文件夹，放到{HA配置目录}/custom_components/下。__</p>
</blockquote>
<ul>
<li><p>switch/broadlink.py</p>
<ul>
<li>修正开关复位的bug</li>
<li>增加显示不可用状态</li>
<li>增加配置内置红外码</li>
<li>通过服务方式调用预设内置红外码</li>
</ul>
</li>
<li><p>climate/xiaomi_miio.py</p>
<ul>
<li>增加配置内置红外码</li>
<li>通过服务方式调用预设内置红外码</li>
</ul>
</li>
</ul>
<hr>
<h2 id="1-环境"><a href="#1-环境" class="headerlink" title="1.环境"></a>1.环境</h2><ul>
<li>Ubuntu 18.04 + HA 0.80.0</li>
</ul>
<h2 id="2-使用说明-0-82版"><a href="#2-使用说明-0-82版" class="headerlink" title="2.使用说明(0.82版)"></a>2.使用说明(0.82版)</h2><h3 id="2-1学码"><a href="#2-1学码" class="headerlink" title="2.1学码"></a>2.1学码</h3><ul>
<li>service: switch.broadlink_rm_learn_command[博联RM]</li>
</ul>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">是否必填</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">entity_id</td>
<td align="center">否</td>
<td align="center">如果不指定，指令将发送到所有博联RM设备</td>
</tr>
</tbody></table>
<blockquote>
<p>__INFO：参考climate.xiaomi_miio.py的服务调用代码进行修改。__</p>
</blockquote>
<ul>
<li>service: climate.xiaomi_miio_learn_command[空调伴侣]</li>
</ul>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">是否必填</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">entity_id</td>
<td align="center">否</td>
<td align="center">如果不指定，指令将发送到所有的空调伴侣设备</td>
</tr>
<tr>
<td align="center">slot</td>
<td align="center">否</td>
<td align="center">存储的槽位，默认1</td>
</tr>
<tr>
<td align="center">timeout</td>
<td align="center">否</td>
<td align="center">学习红外状态等待时间，默认10秒</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>INFO：没做修改，顺带介绍。</strong></p>
</blockquote>
<h3 id="2-2发码"><a href="#2-2发码" class="headerlink" title="2.2发码"></a>2.2发码</h3><ul>
<li>service: switch.broadlink_rm_send_command[博联RM]</li>
</ul>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">是否必填</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">entity_id</td>
<td align="center">否</td>
<td align="center">如果不指定，指令将发送到所有的博联RM设备</td>
</tr>
<tr>
<td align="center">command</td>
<td align="center">否</td>
<td align="center">红外指令字符串</td>
</tr>
<tr>
<td align="center">command_name</td>
<td align="center">否</td>
<td align="center">内置红外指令名称，优先级高于command参数</td>
</tr>
</tbody></table>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置 configuration.yaml</span></span><br><span class="line"><span class="attr">switch:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">platform:</span> <span class="string">broadlink</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">rm_living_room</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">10.11</span><span class="number">.12</span><span class="number">.200</span></span><br><span class="line">    <span class="attr">mac:</span> <span class="string">&#x27;34:ea:34:42:ce:bb&#x27;</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">10</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">remote</span>                    <span class="comment">#注，要设置为remote</span></span><br><span class="line">    <span class="attr">commands:</span>                       <span class="comment">#commands层级定义内置红外指令</span></span><br><span class="line">        <span class="attr">ir_cmn0:</span> <span class="string">&#x27;FE0123456789&#x27;</span>       <span class="comment">#调用的command_name为ir_cmn0</span></span><br><span class="line">        <span class="attr">ir_cmn1:</span> <span class="string">&#x27;FE112233445566&#x27;</span>     <span class="comment">#调用的command_name为ir_cmn1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：在任意一个博联RM中定义红外码即可，其它博联RM可共用。</strong></p>
</blockquote>
<ul>
<li>service: climate.xiaomi_miio_send_command[空调伴侣]</li>
</ul>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">是否必填</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">entity_id</td>
<td align="center">否</td>
<td align="center">如果不指定，指令将发送到所有的空调伴侣设备</td>
</tr>
<tr>
<td align="center">command</td>
<td align="center">否</td>
<td align="center">红外指令字符串，需’FE’或’01’开头</td>
</tr>
<tr>
<td align="center">command_name</td>
<td align="center">否</td>
<td align="center">内置红外指令名称，优先级高于command参数</td>
</tr>
</tbody></table>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置 configuration.yaml</span></span><br><span class="line"><span class="attr">climate:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">platform:</span> <span class="string">xiaomi_miio</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Aqara</span> <span class="string">Air</span> <span class="string">Conditioning</span> <span class="string">Companion</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.130</span><span class="number">.71</span></span><br><span class="line">    <span class="attr">token:</span> <span class="string">b7c4a758c251955d2c24b1d9e41ce47d</span></span><br><span class="line">    <span class="attr">target_sensor:</span> <span class="string">sensor.temperature_158d0001f53706</span></span><br><span class="line">    <span class="attr">scan_interval:</span> <span class="number">60</span></span><br><span class="line">    <span class="attr">commands:</span>                       <span class="comment">#commands层级定义内置红外指令</span></span><br><span class="line">        <span class="attr">ir_cmn0:</span> <span class="string">&#x27;FE0123456789&#x27;</span>       <span class="comment">#调用的command_name为ir_cmn0</span></span><br><span class="line">        <span class="attr">ir_cmn1:</span> <span class="string">&#x27;FE112233445566&#x27;</span>     <span class="comment">#调用的command_name为ir_cmn1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：在任意一个空调伴侣中定义红外码即可，其它空调伴侣可共用。</strong></p>
</blockquote>
<hr>
<h2 id="3-使用说明-0-92版"><a href="#3-使用说明-0-92版" class="headerlink" title="3.使用说明(0.92版)"></a>3.使用说明(0.92版)</h2><h3 id="2-1学码-1"><a href="#2-1学码-1" class="headerlink" title="2.1学码"></a>2.1学码</h3><ul>
<li>service: broadlink.learn[博联RM]</li>
</ul>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">是否必填</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">host</td>
<td align="center">是</td>
<td align="center">entity_id或者ip</td>
</tr>
</tbody></table>
<blockquote>
<p>__INFO：参考climate.xiaomi_miio.py的服务调用代码进行修改。__</p>
</blockquote>
<ul>
<li>service: climate.xiaomi_miio_learn_command[空调伴侣]</li>
</ul>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">是否必填</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">host</td>
<td align="center">否</td>
<td align="center">entity_id或者ip，如果不指定，指令将发送到所有的空调伴侣设备</td>
</tr>
<tr>
<td align="center">slot</td>
<td align="center">否</td>
<td align="center">存储的槽位，默认30</td>
</tr>
<tr>
<td align="center">timeout</td>
<td align="center">否</td>
<td align="center">学习红外状态等待时间，默认10秒</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>INFO：没做修改，顺带介绍。</strong></p>
</blockquote>
<h3 id="2-2发码-1"><a href="#2-2发码-1" class="headerlink" title="2.2发码"></a>2.2发码</h3><ul>
<li>service: broadlink.send[博联RM]</li>
</ul>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">是否必填</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">host</td>
<td align="center">是</td>
<td align="center">entity_id或者ip</td>
</tr>
<tr>
<td align="center">packet</td>
<td align="center">否</td>
<td align="center">红外指令字符串，支持多个（数组）</td>
</tr>
<tr>
<td align="center">command</td>
<td align="center">否</td>
<td align="center">内置红外指令名称，支持多个（数组）</td>
</tr>
</tbody></table>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置 configuration.yaml</span></span><br><span class="line"><span class="attr">switch:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">platform:</span> <span class="string">broadlink</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">rm_living_room</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">10.11</span><span class="number">.12</span><span class="number">.200</span></span><br><span class="line">    <span class="attr">mac:</span> <span class="string">&#x27;34:ea:34:42:ce:bb&#x27;</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">10</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">remote</span>                    <span class="comment">#注，要设置为remote</span></span><br><span class="line">    <span class="attr">commands:</span>                       <span class="comment">#commands层级定义内置红外指令</span></span><br><span class="line">        <span class="attr">ir_cmn0:</span> <span class="string">&#x27;FE0123456789&#x27;</span>       <span class="comment">#调用的command_name为ir_cmn0</span></span><br><span class="line">        <span class="attr">ir_cmn1:</span> <span class="string">&#x27;FE112233445566&#x27;</span>     <span class="comment">#调用的command_name为ir_cmn1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：在任意一个博联RM中定义红外码即可，其它博联RM可共用。</strong></p>
</blockquote>
<ul>
<li>service: climate.xiaomi_miio_send_command[空调伴侣]</li>
</ul>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">是否必填</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">host</td>
<td align="center">否</td>
<td align="center">entity_id或者ip，如果不指定，指令将发送到所有的空调伴侣设备</td>
</tr>
<tr>
<td align="center">packet</td>
<td align="center">否</td>
<td align="center">红外指令字符串，需’FE’或’01’开头，支持多个（数组）</td>
</tr>
<tr>
<td align="center">command</td>
<td align="center">否</td>
<td align="center">内置红外指令名称，支持多个（数组）</td>
</tr>
</tbody></table>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置 configuration.yaml</span></span><br><span class="line"><span class="attr">climate:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">platform:</span> <span class="string">xiaomi_miio</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Aqara</span> <span class="string">Air</span> <span class="string">Conditioning</span> <span class="string">Companion</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.130</span><span class="number">.71</span></span><br><span class="line">    <span class="attr">token:</span> <span class="string">b7c4a758c251955d2c24b1d9e41ce47d</span></span><br><span class="line">    <span class="attr">target_sensor:</span> <span class="string">sensor.temperature_158d0001f53706</span></span><br><span class="line">    <span class="attr">scan_interval:</span> <span class="number">60</span></span><br><span class="line">    <span class="attr">commands:</span>                       <span class="comment">#commands层级定义内置红外指令</span></span><br><span class="line">        <span class="attr">ir_cmn0:</span> <span class="string">&#x27;FE0123456789&#x27;</span>       <span class="comment">#调用的command_name为ir_cmn0</span></span><br><span class="line">        <span class="attr">ir_cmn1:</span> <span class="string">&#x27;FE112233445566&#x27;</span>     <span class="comment">#调用的command_name为ir_cmn1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：在任意一个空调伴侣中定义红外码即可，其它空调伴侣可共用。</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>Home Assistant</category>
      </categories>
      <tags>
        <tag>Home Assistant</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title>【插件·改】基于和风天气的lovelace天气卡片</title>
    <url>/articles/plugin-%C2%B7-change-lovelace-weather-card-based-on-windy/</url>
    <content><![CDATA[<p>还是管不住手把HA升级到0.92，开始配置大迁移。旧的天气插件用的是<a href="https://bbs.hassbian.com/thread-3971-1-1.html" title="和风天气插件组(天气预报+生活提示+小时预报+空气质量)">伸手拿来用版</a>，测试下来基本能继续用，不过比较臃肿，会生成很多sensor来保存展示数据。刚好这次得启用lovelace界面，想了下干脆一起改了吧，做个自定义卡片统一展示天气数据。折腾了两天还算顺利地完成了，还好之前接触Vue框架积累了点经验，这次看Polymer的前台代码不至于眼前一黑了。目前对HA前端整体架构理解还是有限，只能做到小修改，以后有机会再深入了解吧。</p>
<hr>
<a id="more"></a>
<h2 id="0-插件说明"><a href="#0-插件说明" class="headerlink" title="0. 插件说明"></a>0. 插件说明</h2><ul>
<li>概述<ul>
<li>包含hf_weather组件、自定义卡片两块：hf_weather组件获取数据，卡片展示数据。<img src="/articles/plugin-%C2%B7-change-lovelace-weather-card-based-on-windy/demo.gif" class="" title="[效果图]"></li>
<li>2019-08-24新增一个样式<img src="/articles/plugin-%C2%B7-change-lovelace-weather-card-based-on-windy/demo2.gif" class="" title="[新样式效果图]"></li>
</ul>
</li>
<li>下载地址<ul>
<li><a href="https://github.com/cnk700i/ha_modified_components/tree/master/hf_weather" title="hf_weather">hf_weather</a></li>
</ul>
</li>
<li>主要改动<ul>
<li>支持生成多个天气Entity</li>
<li>天气数据统一存储</li>
<li>天气卡片增加空气质量、小时预报、生活建议、数据更新时间</li>
<li>天气卡片更多信息增加生活建议详细数据</li>
<li>天气卡片图表增加下雨概率</li>
<li>天气卡片使用动态图标</li>
</ul>
</li>
<li>参考插件<ul>
<li><a href="https://github.com/sgttrs/lovelace-weather-card-chart" title="lovelace-weather-card-chart">基础版式</a></li>
<li><a href="https://github.com/bramkragten/custom-ui/tree/master/weather-card" title="weather-card">动态图标</a></li>
</ul>
</li>
</ul>
<hr>
<h2 id="1-环境"><a href="#1-环境" class="headerlink" title="1.环境"></a>1.环境</h2><ul>
<li>Ubuntu 18.04 + HA 0.92.1</li>
</ul>
<hr>
<h2 id="2-使用说明"><a href="#2-使用说明" class="headerlink" title="2.使用说明"></a>2.使用说明</h2><h3 id="2-1-组件"><a href="#2-1-组件" class="headerlink" title="2.1 组件"></a>2.1 组件</h3><ul>
<li><p>下载文件，<code>hf_weather</code>目录放置在<code>&#123;HA配置目录&#125;/custom_components/</code>下。</p>
</li>
<li><p>在<a href="https://wx.jdcloud.com/market/datas/26/10610" title="中国和世界天气预报API">京东万象api平台</a>申请appkey。</p>
</li>
<li><p>在<a href="https://where.heweather.com/" title="和风天气位置搜索">和风天气网站</a>找到你的城市代码，CN开头的字符串。</p>
</li>
<li><p>配置启用hf_weather组件。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置 configuration.yaml</span></span><br><span class="line"><span class="comment"># &#123;&#123;&#125;&#125;符号为标示变量</span></span><br><span class="line"><span class="attr">weather:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">platform:</span> <span class="string">hf_weather</span></span><br><span class="line">    <span class="attr">name:</span> &#123;&#123;<span class="string">test</span>&#125;&#125;              <span class="comment"># 必填，自定义实体名称，生成实体的entityId为weather.&#123;&#123;test&#125;&#125;，后续配置需要用到</span></span><br><span class="line">    <span class="attr">city:</span> &#123;&#123;<span class="string">YOUR_CITY_CODE</span>&#125;&#125;    <span class="comment"># 必填，城市代码，支持城市中英文名称、ID和IP地址，例如city=北京，city=beijing，city=CN101010100，city= 60.194.130.1，建议使用ID</span></span><br><span class="line">    <span class="attr">appkey:</span> &#123;&#123;<span class="string">YOUR_API_KEY</span>&#125;&#125;    <span class="comment"># 必填，京东万象api平台申请的key</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：重复即可增加多个实体。</strong></p>
</blockquote>
</li>
<li><p>启用sun组件。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置 configuration.yaml</span></span><br><span class="line"><span class="attr">sun:</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>DEBUG：用于提供卡片的日出日落数据。</strong></p>
</blockquote>
</li>
</ul>
<h3 id="2-2-自定义卡片"><a href="#2-2-自定义卡片" class="headerlink" title="2.2 自定义卡片"></a>2.2 自定义卡片</h3><ul>
<li>下载文件，<code>hf_weather-card</code>目录放置在<code>&#123;HA配置目录&#125;/www/custom-lovelace/</code>下。</li>
</ul>
<blockquote>
<p><strong>INO：该路径可自定义，只要保证在www目录里即可。</strong></p>
</blockquote>
<ul>
<li>lovelace启用天气卡片<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置lovelace（使用UI的原始编辑器编辑即可）,注意删除备注不然无法保存</span></span><br><span class="line"><span class="comment"># 引入自定义卡片hf_weather-card</span></span><br><span class="line"><span class="attr">resources:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">module</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">/local/custom-lovelace/hf_weather-card/hf_weather-card.js</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">module</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">/local/custom-lovelace/hf_weather-card/hf_weather-more-info.js</span></span><br><span class="line"><span class="comment"># 在view里面的cards节点，增加天气卡片类型</span></span><br><span class="line"><span class="attr">views:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">default_view</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">Home</span></span><br><span class="line">    <span class="attr">cards:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">&#x27;custom:hf_weather-card&#x27;</span>                                <span class="comment"># card类型</span></span><br><span class="line">        <span class="attr">entity:</span> <span class="string">weather.test</span>                                         <span class="comment"># 天气插件生成实体的entityId</span></span><br><span class="line">        <span class="attr">mode:</span> <span class="string">daily</span>                                                   <span class="comment"># 指定显示模式，hourly按小时天气预报、daily按天天气预报，不设置（不要这个属性）则同时显示</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">天气</span>                                                   <span class="comment"># 标题，不设置则使用entity的friendly_name</span></span><br><span class="line">        <span class="attr">icons:</span> <span class="string">/local/custom-lovelace/hf_weather-card/icons/animated/</span>  <span class="comment"># 图标路径，不设置则采用cdn，结尾要有&quot;/&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>WARN：lovelace配置里面路径，<code>/local/</code>实际映射<code>&#123;HA配置目录&#125;/www/</code>，保证放置文件的子路径设置对。</strong></p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><ul>
<li>新版本Home Assistant的前端项目名为home-assistant-polymer，可以在src/cards找到天气卡片代码进行分析，结合别人自定义卡片代码基本就能完成了解数据的传入及展示方法。</li>
<li>点击卡片弹出详细信息的面板，由src/dialogs其中相关代码逐级渲染完成：ha-more-info-dialog.js&gt;&gt;more-info-controls.js-more&gt;&gt;more-info-weather.js，通过修改more-info-weather.js可以实现详细信息面板数据的自定义展示，但这样需要重新编译太麻烦。查看代码发现给实体添加<code>custom_ui_more_info</code>属性可以指定自定义的js处理。</li>
</ul>
]]></content>
      <categories>
        <category>Home Assistant</category>
      </categories>
      <tags>
        <tag>Home Assistant</tag>
        <tag>插件</tag>
        <tag>lovelace</tag>
      </tags>
  </entry>
  <entry>
    <title>【插件】HAVCS食用说明</title>
    <url>/articles/plugins-havcs-edible-instructions/</url>
    <content><![CDATA[<p>折腾语音音箱接入控制家里设备从开始构想到现在已经两年有多了：一开始是用别人的<a href="https://ljr.im/articles/intellectually-impaired-home-battlematching/" title="智障家居初战-对接篇">PHP版天猫精灵网关</a>尝了鲜；然后有了想整合多个音箱平台接入的想法，于是尝试搭建过<a href="https://ljr.im/articles/home-for-the-mentally-retardedvoice-control-based-on-nodered-docking/" title="智障家居初战-语音控制篇(基于Node-RED对接)">nodered版本网关</a>；再后来想着自定义技能方式更方便不同平台的接入，又折腾出一个<a href="https://ljr.im/articles/rollover-series-universal-access-platform-for-smart-speakers/" title="【翻车系列】智能音箱通用接入平台">整合版PHP网关</a>并想着提供APP技能方便使用，结果审核翻车了，考虑到自用部署过于复杂就没发布了；然后恰好碰上单平台插件版网关的出现，然后做了HAVCS整合插件，为了进一步简化使用，目前迭代了2个版本，考虑到使用方法变化较大，特意整了这个汇总版的说明。</p>
<hr>
<a id="more"></a>

<h2 id="1-HAVCS是什么"><a href="#1-HAVCS是什么" class="headerlink" title="1. HAVCS是什么"></a>1. HAVCS是什么</h2><p><strong>含义：</strong><br>HAVCS全称为Home Assistant Voice Control Skill，诣在提供Home Assistant对接音箱平台的能力，通过在Home Assistant上运行本插件，可对接音箱厂家的技能开放平台（自建技能或用线上技能），响应音箱指令控制相关设备。<br><strong>本插件实际上由两大功能模块组成：</strong></p>
<ul>
<li><p>MQTT对接服务<br>配合本人搭建的mqtt中转服务，可以将音箱云平台的音箱命令消息、oauth消息转发到无公网环境下家中的Home Assistant。</p>
</li>
<li><p>音箱组件<br>即智能音箱本地网关插件，对音箱云平台的音箱命令消息进行解析、处理，可以初始化为HTTP网关服务与音箱云平台直接对接。<br><strong>有三种使用模式，适合不同场景的接入：</strong></p>
</li>
<li><p>模式一 http模式</p>
<ul>
<li>生成音箱http网关，通过<code>平台自建的测试技能</code>接入</li>
<li>适合家庭宽带<code>有公网ip</code>或<code>已实现内网穿透</code>场景下使用</li>
<li><strong>建议有条件、不怕折腾就用这个，留服务资源给有需要的人</strong><img src="/articles/plugins-havcs-edible-instructions/mode1.svg" class="" title="模式一"></li>
</ul>
</li>
<li><p>模式二 http proxy模式</p>
<ul>
<li>生成音箱http网关，同时使用mqtt代理穿透内网访问，通过<code>平台自建的测试技能</code>接入</li>
<li>适合家庭宽带<code>无公网ip</code>场景下使用</li>
<li><strong>临时提供，视服务资源情况会停止</strong><img src="/articles/plugins-havcs-edible-instructions/mode2.svg" class="" title="模式二"></li>
</ul>
</li>
<li><p>模式三 skill模式</p>
<ul>
<li>通过<code>官方音箱APP技能</code>接入，目前技能已上线<code>叮咚、天猫精灵、小度</code></li>
<li>适合<code>无公网</code>、<code>简单接入</code>场景使用</li>
<li><strong>服务资源有限不能保证稳定</strong><img src="/articles/plugins-havcs-edible-instructions/mode3.svg" class="" title="模式三"></li>
</ul>
</li>
<li><p>各模式难度指数<br>模式一：★★★★☆<br>模式二：★★☆☆☆<br>模式三：★☆☆☆☆</p>
</li>
</ul>
<hr>
<h2 id="2-教程传送门"><a href="#2-教程传送门" class="headerlink" title="2. 教程传送门"></a>2. 教程传送门</h2><ul>
<li>HAVCS v1：&nbsp;<a href="https://ljr.im/articles/plugin-integration-of-smart-speakers-into-home-assistant/" title="【插件】智能音箱接入Home Assistant整合">&gt;使用说明</a>&emsp;&emsp;<a href="https://github.com/cnk700i/havcs/archive/v0.98.zip" title="HAVCS v1">&gt;下载地址</a><br>基于单插件版本简单整合、设备信息通过customize.yml配置</li>
<li>HAVCS v2：&nbsp;<a href="https://ljr.im/articles/plugin-smart-speaker-access-home-assistant-integration-plus/" title="【插件】智能音箱接入Home Assistant整合Plus">&gt;使用说明</a>&emsp;&emsp;<a href="https://github.com/cnk700i/havcs/releases/tag/v0.101" title="HAVCS v2">&gt;下载地址</a><br>初步统一设备定义、设备信息通过独立havcs.yml配置</li>
<li>HAVCS v3：&nbsp;<a href="https://ljr.im/articles/plugin-smart-speaker-access-home-assistant-integration-plusplus/" title="【插件】智能音箱接入Home Assistant整合PlusPlus">&gt;使用说明</a>&emsp;&emsp;<a href="https://github.com/cnk700i/havcs" title="HAVCS v3">&gt;下载地址</a><br>实现全UI管理：集成方式配置插件、web网页管理设备</li>
</ul>
<h2 id="3-关于自建技能"><a href="#3-关于自建技能" class="headerlink" title="3. 关于自建技能"></a>3. 关于自建技能</h2><p>自建技能需要额外两个步骤，因涉及较多的知识及不同的环境存在差异，本人只能作简单指引</p>
<ul>
<li><p>将本地HA服务网址发布到公网<br>申请域名、申请域名https证书、路由器设置DDNS（域名绑定）、路由器设置端口转发访问HA</p>
</li>
<li><p>音箱技能平台的配置<br>平台需要填写三种url：授权地址，Token地址，Service地址。根据选用授权地址不同，有以下两种填写方案：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#方案一 使用HA自带的授权页面</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#授权页面网址</span></span><br><span class="line"><span class="string">https://&#123;你的域名及端口&#125;/auth/authorize</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Token页面网址</span></span><br><span class="line"><span class="string">https://&#123;你的域名及端口&#125;/havcs/auth/token（v3版）</span></span><br><span class="line"><span class="string">https://&#123;你的域名及端口&#125;/havcs_auth（v2版）</span></span><br><span class="line"><span class="string">https://&#123;你的域名及端口&#125;/aihome_auth（v1版）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#WebService（服务网关）网址</span></span><br><span class="line"><span class="string">https://&#123;你的域名及端口&#125;/havcs/service（v3版）</span></span><br><span class="line"><span class="string">https://&#123;你的域名及端口&#125;/havcs_auth（v2版）</span></span><br><span class="line"><span class="string">https://&#123;你的域名及端口&#125;/aihome_service（v1版）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Client Id，填回调地址域名那一串即可（HA要求格式）</span></span><br><span class="line"><span class="string">小度：https://xiaodu.baidu.com</span></span><br><span class="line"><span class="string">天猫：https://open.bot.tmall.com</span></span><br><span class="line"><span class="string">叮咚：不支持，因为平台不允许client_id为&quot;https://&quot;开头</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Client Secret</span></span><br><span class="line"><span class="string">随便填写，不做校验</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#方案二 使用插件的授权页面（v3 2020.04.05后版本增加）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#授权页面网址</span></span><br><span class="line"><span class="string">https://&#123;你的域名及端口&#125;/havcs/auth/authorize</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Token页面网址</span></span><br><span class="line"><span class="string">https://&#123;你的域名及端口&#125;/havcs/auth/token</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#WebService（服务网关）网址</span></span><br><span class="line"><span class="string">https://&#123;你的域名及端口&#125;/havcs/service</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Client Id，在插件配置文件定义</span></span><br><span class="line"><span class="string">与插件（配置文件）所设置的一致</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Client Secret，在插件配置文件定义</span></span><br><span class="line"><span class="string">与插件（配置文件）所设置的一致</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>实践建议</p>
<ul>
<li>外网服务地址需要使用https，https证书使用腾讯云、阿里云或者Let’s Encrypt等兼容性好的，并注意有效期</li>
<li>部署nginx或apache反向代理访问HA，在nginx上配置https，本地可以保留http访问HA</li>
<li>先本地测试可访问插件授权页面（插件正常启动），再外网测试（手机数据链接访问）可访问插件授权页面（反代正常工作）</li>
<li>如无外网访问HA需求，建议使用插件授权页面，只反代/havcs/层级uri到公网</li>
</ul>
</li>
<li><p>详细设置可参考以下教程<br><a href="https://bbs.hassbian.com/thread-9309-1-1.html" title="小度音箱接入hass详细过程">小度音箱接入hass详细过程</a><br><a href="https://bbs.hassbian.com/thread-5417-1-1.html" title="小度音箱接入HomeAssistant采用自带OAuth访问控制">小度音箱接入HomeAssistant采用自带OAuth访问控制</a></p>
</li>
</ul>
<h2 id="4-设备信息v2至v3迁移"><a href="#4-设备信息v2至v3迁移" class="headerlink" title="4. 设备信息v2至v3迁移"></a>4. 设备信息v2至v3迁移</h2><p>v3版本的属性有一些小调整，可以将v2版本的<code>&#123;HA配置目录&#125;/havcs.yml</code>里面旧的设备信息按照新格式调整好后，保存为<code>&#123;HA配置目录&#125;/havcs-ui.yml</code>，执行一次<code>havcs.reload</code>服务，即可在网页设备管理界面看到新的设备信息。</p>
]]></content>
      <categories>
        <category>Home Assistant</category>
      </categories>
      <tags>
        <tag>Home Assistant</tag>
        <tag>插件</tag>
        <tag>智能音箱</tag>
      </tags>
  </entry>
  <entry>
    <title>【插件】Home Assistant通用定时器</title>
    <url>/articles/plugin-home-assistant-universal-timer/</url>
    <content><![CDATA[<blockquote>
<p>上次用Appdaemon做了个<a href="https://ljr.im/articles/plugin-universal-timer-based-on-appdaemon/" title="【插件】基于Appdaemon的通用定时器">通用定时器</a>，想了下其实HA实现比较合适，毕竟不涉及复杂的场景判断。最近因为各种踩坑，读了HA的不少代码也算有一定的积累了，正好借这个机会练练手。</p>
</blockquote>
<hr>
<a id="more"></a>
<h2 id="0-功能说明"><a href="#0-功能说明" class="headerlink" title="0.功能说明"></a>0.功能说明</h2><img src="/articles/plugin-home-assistant-universal-timer/demo1.gif" class="" title="[效果图1]">    <img src="/articles/plugin-home-assistant-universal-timer/demo2.gif" class="" title="[效果图2]">
<ul>
<li>支持多个定时任务</li>
<li>可定义开/关操作</li>
<li>自动加载设备列表，无需额外配置</li>
<li>采用看起来很厉害的环形定时队列</li>
<li>可记忆设备上次设置的定时时间<blockquote>
<p><strong>WARN：新手插件，可能存在未知的bug，使用本插件有风险！</strong></p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="1-环境"><a href="#1-环境" class="headerlink" title="1.环境"></a>1.环境</h2><ul>
<li>Ubuntu 18.04 + HA 0.74.0</li>
</ul>
<hr>
<h2 id="2-过程"><a href="#2-过程" class="headerlink" title="2.过程"></a>2.过程</h2><h3 id="2-1配置项"><a href="#2-1配置项" class="headerlink" title="2.1配置项"></a>2.1配置项</h3><ul>
<li>configuration.yaml<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#&#123;HA配置目录&#125;/configuration.yaml</span></span><br><span class="line"><span class="attr">common_timer:</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>__INFO：目前代码内置固定配置，以后再分离做可配置的。初始化会增加以下5个entity，请确保名称不会冲突。<br>1.input_select.domain: 用于选择设备类型<br>2.input_select.entity: 设备<br>3.input_select.operation: 操作类型<br>4.input_text.common_timer: 输入定时<br>5.input_boolean.timer_button:开关按钮__</p>
</blockquote>
<ul>
<li>group.yaml（根据实际情况配置）</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#&#123;HA配置目录&#125;/group.yaml</span></span><br><span class="line"><span class="comment">#参考</span></span><br><span class="line"><span class="attr">default_view:</span></span><br><span class="line">  <span class="attr">view:</span> <span class="literal">yes</span></span><br><span class="line">  <span class="attr">icon:</span> <span class="string">mdi:home</span> </span><br><span class="line">  <span class="attr">entities:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">group.common_timer</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>__INFO：插件会生成一个group.common_timer，如果自定义过group.yaml的分组分页，需要配置放到要显示的分页里。__</p>
</blockquote>
<h3 id="2-2代码"><a href="#2-2代码" class="headerlink" title="2.2代码"></a>2.2代码</h3><ul>
<li><p>input_select.py</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#&#123;HA安装目录&#125;/components/input_select.py</span></span><br><span class="line"><span class="comment">#……省略……#</span></span><br><span class="line"><span class="string">def</span> <span class="string">async_setup(hass,</span> <span class="string">config):</span></span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;Set up an input select.&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="string">component</span> <span class="string">=</span> <span class="string">hass.data[DOMAIN]</span> <span class="string">=</span> <span class="string">EntityComponent(_LOGGER,</span> <span class="string">DOMAIN,</span> <span class="string">hass)</span></span><br><span class="line"><span class="comment">#……省略……#</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>input_text.py</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#&#123;HA安装目录&#125;/components/input_text.py</span></span><br><span class="line"><span class="comment">#……省略……#</span></span><br><span class="line"><span class="string">def</span> <span class="string">async_setup(hass,</span> <span class="string">config):</span></span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;Set up an input text box.&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="string">component</span> <span class="string">=</span> <span class="string">hass.data[DOMAIN]</span> <span class="string">=</span> <span class="string">EntityComponent(_LOGGER,</span> <span class="string">DOMAIN,</span> <span class="string">hass)</span></span><br><span class="line"><span class="comment">#……省略……#</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>input_boolean.py</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#&#123;HA安装目录&#125;/components/input_boolean.py</span></span><br><span class="line"><span class="comment">#……省略……#</span></span><br><span class="line"><span class="string">async</span> <span class="string">def</span> <span class="string">async_setup(hass,</span> <span class="string">config):</span></span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;Set up an input boolean.&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="string">component</span> <span class="string">=</span> <span class="string">hass.data[DOMAIN]</span> <span class="string">=</span> <span class="string">EntityComponent(_LOGGER,</span> <span class="string">DOMAIN,</span> <span class="string">hass)</span></span><br><span class="line"><span class="comment">#……省略……#</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>__INFO：把官方的几个input_xxx component修改一下，以便保存EntityComponent到全局变量hass.data[DOMAIN]，后续可能需要调用。__</p>
</blockquote>
<ul>
<li>common_timer.py（<a href="https://github.com/cnk700i/common_timer/blob/v1/custom_components/common_timer.py" title="common_timer.py">github下载</a>）<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#放到&#123;HA配置目录&#125;/components/common_timer.py</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p><strong>INFO：测试版本，代码风格小随意。。。</strong></p>
</blockquote>
<h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h2><ul>
<li>难点1，往HA中动态添加ENTITY的方法，需要了解HA的启动过程，以免影响加载原来配置文件。</li>
<li>难点2，HA定时调用方法，试用track_time_interval貌似不准，摸索找到的async_track_time_change就好用。</li>
<li>难点3，环形定时队列轮询和执行任务分线程运行，以免影响环形定时队列轮询准确性。HA的异步调度机制仍然是个黑洞，不断调式、参考自带的代码摸索出一定的规律，算是勉强能用了。</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>Home Assistant</category>
      </categories>
      <tags>
        <tag>Home Assistant</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title>【插件】Home Assistant通用定时器（升级版）</title>
    <url>/articles/plugin-home-assistant-universal-timer-upgraded-version/</url>
    <content><![CDATA[<blockquote>
<p>为了定期让家里暗卫的排风扇“开启-关闭-开启”循环工作，保证暗卫的排风时间，把之前的<a href="https://ljr.im/articles/plugin-home-assistant-general-timer/" title="【插件】Home Assistant通用定时器">插件</a>完善了下，顺便优化了一下代码结构，并加入了配置项、服务调用方法，嗯嗯，看起来更像一个标准插件了。</p>
</blockquote>
<hr>
<a id="more"></a>
<h2 id="0-功能说明"><a href="#0-功能说明" class="headerlink" title="0. 功能说明"></a>0. 功能说明</h2><img src="/articles/plugin-home-assistant-universal-timer-upgraded-version/demo.gif" class="" title="[效果图]">
<ul>
<li>支持多个定时任务</li>
<li>可定义开/关/循环操作</li>
<li>自动加载设备列表，无需额外配置</li>
<li>采用看起来很厉害的环形定时队列</li>
<li>可记忆设备上次设置的定时时间</li>
<li>任务列表可查看正在执行的任务</li>
<li>支持调用自定义服务，并可插件服务设置（2019-08-27新增）</li>
<li>支持设置外部操作中断循环任务（2019-08-27新增）<blockquote>
<p><strong>WARN：新手插件，可能存在未知的bug，使用本插件有风险！</strong></p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="1-环境"><a href="#1-环境" class="headerlink" title="1. 环境"></a>1. 环境</h2><ul>
<li>Ubuntu 18.04 + HA 0.76.1</li>
</ul>
<hr>
<h2 id="2-过程"><a href="#2-过程" class="headerlink" title="2. 过程"></a>2. 过程</h2><h3 id="2-1-配置项"><a href="#2-1-配置项" class="headerlink" title="2.1. 配置项"></a>2.1. 配置项</h3><ul>
<li>configuration.yaml<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#&#123;HA配置目录&#125;/configuration.yaml</span></span><br><span class="line"><span class="string">```yaml</span></span><br><span class="line"><span class="comment"># 完整版</span></span><br><span class="line"><span class="attr">common_timer:</span></span><br><span class="line">  <span class="attr">domains:</span>  <span class="comment"># 筛选设备（component）类型</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">light</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">automation</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">switch</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">script</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">input_boolean</span></span><br><span class="line">  <span class="attr">exclude:</span>  <span class="comment"># 排除设备，使用entity_id</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">light.test</span></span><br><span class="line">  <span class="attr">pattern:</span> <span class="string">&#x27;[\u4e00-\u9fa5]+&#x27;</span>   <span class="comment"># &gt;&gt;注意：默认筛选friendly_name包含中文的设备，如果不筛选，设置为&#x27;.*&#x27;</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ct_control_panel</span>        <span class="comment"># 控制面板的名称，需英文。如果有自定义分组页面，需把对应的group，例如goup.ct_control_panel加到分页</span></span><br><span class="line">  <span class="attr">friendly_name:</span> <span class="string">通用定时器</span>      <span class="comment"># 控制面板别名</span></span><br><span class="line">  <span class="attr">ratio:</span> <span class="number">5</span>                      <span class="comment"># 时间比例，只用于周期任务：开⇌关[1:x]表示开状态设置1分钟，则关状态x分钟；关⇌开[1:x]表示关状态设置1分钟，则开状态x分钟</span></span><br><span class="line">  <span class="attr">info_panel:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">ct_info_panel</span>         <span class="comment"># 任务列表面板名称，需英文。如果有自定义分组页面，需把对应的group，例如group.ct_info_panel加到分页</span></span><br><span class="line">    <span class="attr">friendly_name:</span> <span class="string">定时任务列表</span>  <span class="comment">#任务面板别名</span></span><br><span class="line">    <span class="attr">info_num_min:</span> <span class="number">1</span>             <span class="comment"># 任务列表面板常驻显示最小行</span></span><br><span class="line">    <span class="attr">info_num_max:</span> <span class="number">10</span>            <span class="comment"># 任务列表面板常驻显示最大行。注：如果最大最小设置一致，则常驻显示</span></span><br><span class="line">  <span class="attr">linked_user:</span> <span class="string">common_timer_linked_user</span> <span class="comment"># 插件关联用户名，由插件自动创建，用于解决控制需要权限问题</span></span><br><span class="line">  <span class="attr">interrupt_loop:</span> <span class="literal">False</span>         <span class="comment"># 外部操作是否中断循环任务</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：如果只设置<code>common_timer:</code>，会默认按上面的样板配置进行设置。</strong><br><strong>WARN：注意lovelace界面下任务列无法动态显示，info_num_min、info_num_max请设置一致，info_num_min、info_num_max请设置一致，info_num_min、info_num_max请设置一致。</strong></p>
</blockquote>
</li>
</ul>
<blockquote>
<p><strong>INFO：目前代码内置固定配置，以后再分离做可配置的。初始化会增加以下entity，请确保名称不会冲突。<br>1.input_select.ct_domain: 用于选择设备类型<br>2.input_select.ct_entity: 设备<br>3.input_select.ct_operation: 操作类型<br>4.input_text.ct_duration: 输入定时<br>5.input_boolean.ct_switch:开关按钮<br>6.sensor.ct_record_x:任务列表记录行</strong></p>
</blockquote>
<ul>
<li>group.yaml（根据实际情况配置）</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#&#123;HA配置目录&#125;/group.yaml</span></span><br><span class="line"><span class="comment">#参考</span></span><br><span class="line"><span class="attr">default_view:</span></span><br><span class="line">  <span class="attr">view:</span> <span class="literal">yes</span></span><br><span class="line">  <span class="attr">icon:</span> <span class="string">mdi:home</span> </span><br><span class="line">  <span class="attr">entities:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">group.ct_control_panel</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">group.ct_info_panel</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>INFO：插件会生成group.ct_control_panel、group.ct_info_panel（具体名称通过配置设置），如果自定义过group.yaml的分组分页，需要配置放到要显示的分页里。</strong></p>
</blockquote>
<ul>
<li>lovelace界面配置样例</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">views:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">cards:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">entities:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">input_select.ct_domain</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">input_select.ct_entity</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">input_select.ct_operation</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">input_text.ct_duration</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">input_boolean.ct_switch</span></span><br><span class="line">        <span class="attr">show_header_toggle:</span> <span class="literal">false</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">通用定时器</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">entities</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">entities:</span> <span class="comment"># 按任务列表面板常驻显示列数x列设置sensor.ct_record_0~sensor.ct_record_&#123;x-1&#125;</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">sensor.ct_record_0</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">sensor.ct_record_1</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">sensor.ct_record_2</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">sensor.ct_record_3</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">sensor.ct_record_4</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">sensor.ct_record_5</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">sensor.ct_record_6</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">sensor.ct_record_7</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">sensor.ct_record_8</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">sensor.ct_record_9</span></span><br><span class="line">        <span class="attr">show_header_toggle:</span> <span class="literal">false</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">定时任务列表</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">entities</span></span><br><span class="line">    <span class="attr">badges:</span> []</span><br><span class="line">    <span class="attr">title:</span> <span class="string">demo</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>WARN：注意lovelace界面下任务列无法动态显示，info_num_min、info_num_max请设置一致。</strong></p>
</blockquote>
<h3 id="2-2-修改官方组件"><a href="#2-2-修改官方组件" class="headerlink" title="2.2. 修改官方组件"></a>2.2. 修改官方组件</h3><p>本插件需要对官方的input_select、input_text、input_boolean组件进行修改。<font color=red>注意：新版本插件可忽略此步骤。</font></p>
<ul>
<li><p>input_select.py</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#&#123;HA安装目录&#125;/components/input_select.py</span></span><br><span class="line"><span class="comment">#……省略……#</span></span><br><span class="line"><span class="string">def</span> <span class="string">async_setup(hass,</span> <span class="string">config):</span></span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;Set up an input select.&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="string">component</span> <span class="string">=</span> <span class="string">hass.data[DOMAIN]</span> <span class="string">=</span> <span class="string">EntityComponent(_LOGGER,</span> <span class="string">DOMAIN,</span> <span class="string">hass)</span></span><br><span class="line"><span class="comment">#……省略……#</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>input_text.py</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#&#123;HA安装目录&#125;/components/input_text.py</span></span><br><span class="line"><span class="comment">#……省略……#</span></span><br><span class="line"><span class="string">def</span> <span class="string">async_setup(hass,</span> <span class="string">config):</span></span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;Set up an input text box.&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="string">component</span> <span class="string">=</span> <span class="string">hass.data[DOMAIN]</span> <span class="string">=</span> <span class="string">EntityComponent(_LOGGER,</span> <span class="string">DOMAIN,</span> <span class="string">hass)</span></span><br><span class="line"><span class="comment">#……省略……#</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>input_boolean.py</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#&#123;HA安装目录&#125;/components/input_boolean.py</span></span><br><span class="line"><span class="comment">#……省略……#</span></span><br><span class="line"><span class="string">async</span> <span class="string">def</span> <span class="string">async_setup(hass,</span> <span class="string">config):</span></span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;Set up an input boolean.&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="string">component</span> <span class="string">=</span> <span class="string">hass.data[DOMAIN]</span> <span class="string">=</span> <span class="string">EntityComponent(_LOGGER,</span> <span class="string">DOMAIN,</span> <span class="string">hass)</span></span><br><span class="line"><span class="comment">#……省略……#</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>__INFO：把官方的几个input_xxx component修改一下，以便保存EntityComponent到全局变量hass.data[DOMAIN]，插件初始化需要调用。__</p>
</blockquote>
<h3 id="2-3-配置"><a href="#2-3-配置" class="headerlink" title="2.3. 配置"></a>2.3. 配置</h3><ul>
<li>common_timer插件（<a href="https://github.com/cnk700i/common_timer" title="common_timer">github下载</a>）<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#把common_timer目录放到custom_components下，包含2个文件。</span></span><br><span class="line"><span class="comment">#&#123;HA配置目录&#125;/custom_components/common_timer/__init__.py</span></span><br><span class="line"><span class="comment">#&#123;HA配置目录&#125;/custom_components/common_timer/services.yaml</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p><strong>DEBUG：梳理了一遍代码，增加了塑料英文注释。</strong></p>
</blockquote>
<hr>
<h2 id="3-新版本优化部署说明"><a href="#3-新版本优化部署说明" class="headerlink" title="3. 新版本优化部署说明"></a>3. 新版本优化部署说明</h2><p>修改安装目录下官方的input_select、input_text、input_boolean组件代码，当HA升级后会被覆盖又要重新修改。另外，使用docker方式部署（比如hassio），一般只映射配置目录，修改安装目录存在难度。因此新版本插件已经将input_select、input_text、input_boolean打包进来，如Home Assistant后续版本有对以上三个组件更新，可按以下方法进行同步更新：</p>
<ol>
<li>找到对应组件文件，有两种方法：<ul>
<li>在HA安装目录下components文件夹，docker部署可以使用<code>docker cp [容器id]:/usr/src/app/homeassistant/components [宿主机目录]</code>复制components文件夹处理（注意不同容器安装目录可能不同，可以先进入容器使用<code>find / -name homeassistant</code>定位安装目录）</li>
<li>去官方github下载相应版本releases包解压获取</li>
</ul>
</li>
<li>拷贝组件到<code>[HA配置目录]/custom_components</code>目录下</li>
<li>修改组件py文件（以input_select为例，旧版本HA是input_select.py，新版本HA是input_select文件夹的__init__.py），将<code>async def async_setup(hass, config):</code>里的 <code>component= EntityComponent(_LOGGER, DOMAIN, hass)</code>=&gt;<code>component = hass.data[DOMAIN] = EntityComponent(_LOGGER, DOMAIN, hass)</code></li>
</ol>
<blockquote>
<p>__INFO：同名组件会优先使用自定义组件目录（custom_components）下的组件。__</p>
</blockquote>
<hr>
<h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><ul>
<li>难点1，考虑日常应用，设置了人工介入操作则会中断周期任务，需要区分是插件控制设备还是别的地方控制。</li>
<li>难点2，配置项有一些验证设置，都是参考其他插件来设置，具体验证过程还不了解。</li>
<li>难点3，任务列表的记录行，考虑很久采取sensor来展示，但受限于不了解前端，样式暂无法进一步优化。</li>
<li>找到了HA直接更改state的方法，但设备实际状态的控制还是需要通过调用service才能。</li>
</ul>
]]></content>
      <categories>
        <category>Home Assistant</category>
      </categories>
      <tags>
        <tag>Home Assistant</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title>【插件】MQTT中转实现智能音箱接入Home Assistant</title>
    <url>/articles/plugin-mqtt-transit-to-achieve-smart-speaker-access-home-assistant/</url>
    <content><![CDATA[<p>上次打算整个通用的智能音箱接入平台，结果自定义技能不给做智能家居控制，翻车了。后来改用智能家居技能实现，虽然基础功能是没问题，但想要统一语音控制命令，不论是实现的成本还是使用的学习成本都太大，只得先搁浅了。目前瀚思彼岸论坛中已经有天猫精灵、小度音箱两个实现度比较高的插件了，将上个项目的成果改造下，提供一个免公网IP与智能音箱平台对接的新方法吧。</p>
<hr>
<a id="more"></a>

<h2 id="0-插件说明"><a href="#0-插件说明" class="headerlink" title="0.插件说明"></a>0.插件说明</h2><p><strong>技术架构</strong></p>
<ul>
<li>智能音箱技能平台（自建skill）&lt;=__http__=&gt;插件中转服务&lt;=__mqtt__=&gt;本地插件&lt;=__http__=&gt;HA智能音箱服务/HA Oauth服务</li>
</ul>
<p><strong>效果</strong></p>
<ul>
<li>外网访问<code>https://ai-home.ljr.im/h2m2h/&#123;app_key&#125;/ABC</code>，将通过mqtt将请求发给本地插件，由本地插件代理访问<code>https://localhost:8123/ABC</code><blockquote>
<p><strong>INFO：只支持小量文本格式内容页面，比如json。</strong></p>
</blockquote>
</li>
</ul>
<p><strong>处理流程</strong></p>
<ol>
<li>音箱skill平台将指令发送给插件中转服务（http服务）</li>
<li>中转服务通过url区分用户，将指令加密后分发给相应的本地插件（用户）</li>
<li>本地插件生成本地http请求与HA智能音箱服务/HA Oauth服务进行通信</li>
<li>得到的处理结果原路返回给音箱skill平台</li>
</ol>
<p><strong>多用户安全性保障</strong></p>
<ul>
<li>mqtt启用TLS</li>
<li>acl来隔离不同用户的主题</li>
<li>对mqtt消息进行加密</li>
</ul>
<p><strong>注意事项</strong></p>
<ul>
<li>需要相应的智能音箱插件（使用HA自带oauth认证的）使用，本插件只提供代理通道</li>
<li>授权页面仍需要在本地环境进行访问</li>
<li>天猫精灵测试偶尔无法授权，感觉天猫精灵服务器间歇抽风</li>
<li>多用户使用环境下稳定性待测试</li>
</ul>
<h2 id="1-环境"><a href="#1-环境" class="headerlink" title="1.环境"></a>1.环境</h2><ul>
<li>HA 0.86.4 和 HA 0.82.1</li>
<li><a href="https://bbs.hassbian.com/thread-4758-1-1.html">天猫精灵插件</a>或<a href="https://bbs.hassbian.com/thread-5417-1-1.html">小度音箱插件</a></li>
<li><a href="https://github.com/cnk700i/http2mqtt2hass">http2mqtt2hass插件</a></li>
</ul>
<h2 id="2-使用说明"><a href="#2-使用说明" class="headerlink" title="2.使用说明"></a>2.使用说明</h2><h3 id="2-1本地智能音箱服务"><a href="#2-1本地智能音箱服务" class="headerlink" title="2.1本地智能音箱服务"></a>2.1本地智能音箱服务</h3><p>参考相应插件介绍进行搭建</p>
<h3 id="2-2http2mqtt2hass插件"><a href="#2-2http2mqtt2hass插件" class="headerlink" title="2.2http2mqtt2hass插件"></a>2.2http2mqtt2hass插件</h3><ul>
<li>获取账号<br>前往<a href="https://ai-home.ljr.im/account/index.php">账号获取页面</a>，获取app_key,app_secret</li>
<li>插件配置  <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#&#123;HA配置目录&#125;/configuration.yaml</span></span><br><span class="line"><span class="attr">http2mqtt2hass:</span></span><br><span class="line">    <span class="attr">broker:</span> <span class="string">mqtt.ljr.im</span>     <span class="comment"># MQTT Broker</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">28883</span>             <span class="comment"># MQTT Port</span></span><br><span class="line">    <span class="attr">app_key:</span> <span class="string">xxx</span>            <span class="comment"># 获取的app_key</span></span><br><span class="line">    <span class="attr">app_secret:</span> <span class="string">xxx</span>         <span class="comment"># 获取的app_secret</span></span><br><span class="line">    <span class="attr">certificate:</span> <span class="string">xxx</span>        <span class="comment"># 插件目录内ca.crt的全路径</span></span><br><span class="line">    <span class="attr">tls_insecure:</span> <span class="literal">true</span>      <span class="comment"># 不变</span></span><br><span class="line">    <span class="attr">allowed_uri:</span>            <span class="comment"># 允许本地访问的路径</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/auth/token</span>       <span class="comment"># HA的Oauth服务地址</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/dueros_gate</span>      <span class="comment"># 小度音箱插件服务</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/ali_genie_gate</span>   <span class="comment"># 天猫精灵插件服务</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：音箱插件的服务地址见插件代码中继承了HomeAssistantView类的类所定义的url变量。</strong></p>
</blockquote>
</li>
<li>平台配置<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#前往音箱技能平台进行设置</span></span><br><span class="line"><span class="comment">#授权地址</span></span><br><span class="line"><span class="string">https://&#123;本地HA访问地址&#125;/auth/authorize</span></span><br><span class="line"><span class="comment">#Client_Id，回调地址域名那一串即可</span></span><br><span class="line"><span class="string">小度：https://xiaodu.baidu.com</span></span><br><span class="line"><span class="string">天猫：https://open.bot.tmall.com</span></span><br><span class="line"><span class="comment">#Token地址</span></span><br><span class="line"><span class="string">https://ai-home.ljr.im/h2m2h/&#123;app_key&#125;/auth/token</span></span><br><span class="line"><span class="comment">#WebService地址（服务网关）</span></span><br><span class="line"><span class="string">小度：https://ai-home.ljr.im/h2m2h/&#123;app_key&#125;/dueros_gate</span></span><br><span class="line"><span class="string">天猫：https://ai-home.ljr.im/h2m2h/&#123;app_key&#125;/ali_genie_gate</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>__INFO：{本地HA访问地址}、{app_key}替换成相应的字符串。__</p>
</blockquote>
</li>
</ul>
<h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h2><ul>
<li>尝试将授权页面也通过mqtt代理访问，但mqtt消息传200k长的消息就获取不全导致错误，分次传输处理又太麻烦，不折腾了。</li>
<li>智能音箱插件将汉字处理成’\uxxxx’字符串，返回给小度音箱平台无法识别。</li>
</ul>
]]></content>
      <categories>
        <category>Home Assistant</category>
      </categories>
      <tags>
        <tag>Home Assistant</tag>
        <tag>插件</tag>
        <tag>MQTT</tag>
      </tags>
  </entry>
  <entry>
    <title>【插件】智能音箱接入Home Assistant整合Plus</title>
    <url>/articles/plugin-smart-speaker-access-home-assistant-integration-plus/</url>
    <content><![CDATA[<p>之前把<a href="https://ljr.im/articles/visual-studio-code-debugging-home-assistant-ssh-version/" title="Visual Studio Code调试Home Assistant代码（SSH版）">Home Assistant调试环境</a>给弄好了，有点膨胀就把先前<a href="https://ljr.im/articles/plugin-smart-speaker-access-home-assistant-integration/" title="【插件】智能音箱接入Home Assistant整合">aihome插件</a>的智能音箱网关代码进行全部重构<del>2次</del>。好吧，其实只是想实现不用重启可以更新设备信息就行了，中途又有点想法就就停不下来了，真的是费脑费力。不过成果还是满意的，引入一个设备信息管理层以实现配置信息的标准化，同时将基础的业务流程代码独立出来，初步实现可以通过配置的方式来扩展对音箱指令的解析支持，也算是搭建了一个粗略的框架整合接入了三个音箱平台。</p>
<hr>
<a id="more"></a>
<h2 id="0-插件说明"><a href="#0-插件说明" class="headerlink" title="0.插件说明"></a>0.插件说明</h2><p>新插件更名为HAVSC(Home Assistant Voice Control Skill)，同步更改音箱平台技能名称（不影响旧版aihome插件使用），启用新版本需要重新配置设备信息，新版本特点如下：</p>
<ul>
<li>独立配置文件，支持重载文件而无需重启HA</li>
<li>大幅度简化配置</li>
<li>增加指令扩展性</li>
</ul>
<hr>
<h2 id="1-使用说明"><a href="#1-使用说明" class="headerlink" title="1.使用说明"></a>1.使用说明</h2><h3 id="1-1-APP的技能方式接入"><a href="#1-1-APP的技能方式接入" class="headerlink" title="1.1.APP的技能方式接入"></a>1.1.APP的技能方式接入</h3><p>使用官方APP技能，配合havcs服务可实现免公网IP接入。</p>
<ul>
<li>下载<a href="https://github.com/cnk700i/havcs" title="havcs插件">havcs插件</a>，放置到HA自定义插件目录，最终路径结构为<code>&#123;HA配置目录&#125;/custom_components/havcs/__init__.py</code>。</li>
<li>前往<a href="https://ai-home.ljr.im/account/" title="havcs账号">页面</a>注册账号，获取AppKey和AppSecret（先登录再生成，生成后记得保存）。</li>
<li>音箱APP-&gt;搜索’havcs’技能-&gt;关联账号-&gt;输入注册的账号信息登录。</li>
<li>配置Home Assistant<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># &#123;HA配置目录&#125;/configuration.yaml                 </span></span><br><span class="line"><span class="attr">havcs:</span></span><br><span class="line">  <span class="attr">platform:</span>                               <span class="comment"># 音箱平台服务网关，至少启用一个</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">aligenie</span>                            <span class="comment"># 天猫精灵</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">dueros</span>                              <span class="comment"># 小度</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">jdwhale</span>                             <span class="comment"># 叮咚</span></span><br><span class="line">  <span class="attr">skill:</span></span><br><span class="line">    <span class="attr">bind_device:</span> <span class="literal">True</span>                     <span class="comment"># 是否启动时更新设备绑定信息。不设置默认True（叮咚音箱才有效）&gt;&gt;*新版本加入&lt;&lt;</span></span><br><span class="line">    <span class="attr">sync_device:</span> <span class="literal">False</span>                    <span class="comment"># 是否主动上报设备状态。不设置默认False（小度音箱才有效）</span></span><br><span class="line">  <span class="comment"># mqtt相关设置，启用http代理服务及APP技能服务才生效</span></span><br><span class="line">  <span class="attr">setting:</span></span><br><span class="line">    <span class="attr">app_key:</span> <span class="string">your_app_key</span>                 <span class="comment"># 注册账号获取的AppKey</span></span><br><span class="line">    <span class="attr">app_secret:</span> <span class="string">your_app_secret</span>           <span class="comment"># 注册账号获取的AppSecret</span></span><br><span class="line">    <span class="attr">entity_key:</span> <span class="string">your_entity_key</span>           <span class="comment"># 加密entity_id的key，自定义16个字符</span></span><br><span class="line">  <span class="attr">device_config:</span> <span class="string">device_yaml_full_path</span>    <span class="comment"># 设备配置文件路径（完整路径）。不设置默认&#123;HA配置目录&#125;/havcs.yaml &gt;&gt;*新版本加入&lt;&lt;</span></span><br></pre></td></tr></table></figure></li>
<li>配置设备信息（详见第2章节）<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置文件整体结构（默认文件路径：&#123;HA配置目录&#125;/havcs.yaml）</span></span><br><span class="line"><span class="string">设备1的entity_id:</span></span><br><span class="line">  <span class="string">属性1:</span></span><br><span class="line">  <span class="string">属性2:</span></span><br><span class="line"><span class="string">设备2的entity_id:</span></span><br><span class="line">  <span class="string">属性1:</span></span><br><span class="line">  <span class="string">属性2:</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 单设备样例</span></span><br><span class="line"><span class="attr">light.demo:</span></span><br><span class="line">  <span class="attr">havcs_device_name:</span> <span class="string">主卧灯</span></span><br><span class="line">  <span class="attr">havcs_zone:</span> <span class="string">主卧</span></span><br></pre></td></tr></table></figure></li>
<li>更新音箱平台设备信息<ul>
<li>先重载本地信息：调用服务（HA web-&gt;开发者工具-&gt;服务-&gt;调用havcs.reload）或者重启HA</li>
<li>叮咚：重载本地信息会触发上报（bind_device配置为True）。</li>
<li>天猫精灵：在APP中重新绑定触发更新。</li>
<li>小度：执行“发现设备”指令触发更新。</li>
</ul>
</li>
</ul>
<h3 id="1-2-自建技能方式接入"><a href="#1-2-自建技能方式接入" class="headerlink" title="1.2.自建技能方式接入"></a>1.2.自建技能方式接入</h3><ul>
<li>音箱技能配置略</li>
<li>配置Home Assistant<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># &#123;HA配置目录&#125;/configuration.yaml                 </span></span><br><span class="line"><span class="attr">havcs:</span></span><br><span class="line">  <span class="attr">platform:</span>                               <span class="comment"># 音箱平台服务网关，至少启用一个</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">aligenie</span>                            <span class="comment"># 天猫精灵</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">dueros</span>                              <span class="comment"># 小度</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">jdwhale</span>                             <span class="comment"># 叮咚</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">    <span class="attr">ha_url:</span> <span class="string">https://localhost:8123</span>        <span class="comment"># HA所在主机/容器IP地址，不设置则默认识别</span></span><br><span class="line">    <span class="attr">expire_in_hours:</span> <span class="number">24</span>                   <span class="comment"># token超时时间，单位小时，不设置则默认24h</span></span><br><span class="line">  <span class="attr">device_config:</span> <span class="string">device_yaml_full_path</span>    <span class="comment"># 指定设备配置文件位置（填完整路径），不设置默认位于&#123;HA配置目录&#125;/havcs.yaml &gt;&gt;*新版本加入属性&lt;&lt;</span></span><br></pre></td></tr></table></figure></li>
<li>配置设备信息及更新音箱平台设备信息同上章节</li>
<li>新版注意事项及实践建议<ul>
<li>uri调整：<code>/aihome_auth</code> -&gt; <code>/havcs_auth</code>；<code>/aihome_service</code> -&gt; <code>/havcs_service</code>。</li>
<li>相关服务地址使用https及443端口（建议使用nginx或apache反向代理，本地可以保留http访问），https证书使用腾讯云、阿里云或者Let’s Encrypt等兼容性好的，并注意有效期。</li>
<li>先确认本地uri可访问（插件正常启动），再测试确认服务地址的可访问（手机直接访问网址，405代表网络通）。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-设备信息属性说明"><a href="#2-设备信息属性说明" class="headerlink" title="2.设备信息属性说明"></a>2.设备信息属性说明</h2><p>在{HA配置目录}/havcs.yaml（或自定义文件）配置设备信息，用于生成音箱平台的设备（绑定设备）。</p>
<ul>
<li>设备统一使用属性进行配置，属性列表如下：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">属性名</th>
<th align="center">描述</th>
<th align="center">取值</th>
<th align="center">样例</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">havcs_visable</td>
<td align="center">设备可见性</td>
<td align="center">[‘aligenie’, ‘dueros’, ‘jdwhale’]</td>
<td align="center">[‘aligenie’, ‘dueros’]</td>
<td align="center">设置该属性则设备只对指定平台可见；如不设置，对所有平台可见</td>
</tr>
<tr>
<td align="center">havcs_device_name</td>
<td align="center">设备名称</td>
<td align="center"><a href="https://open.bot.tmall.com/oauth/api/aliaslist" title="天猫精灵设备名称">*天猫精灵限制</a></td>
<td align="center">客厅灯</td>
<td align="center">必填，建议“房间”+“设备类型”可以兼容三个平台使用</td>
</tr>
<tr>
<td align="center">havcs_zone</td>
<td align="center">设备位置</td>
<td align="center"><a href="https://open.bot.tmall.com/oauth/api/placelist" title="天猫精灵位置">*天猫精灵限制</a></td>
<td align="center">客厅</td>
<td align="center">天猫精灵必填，其它可不用指定</td>
</tr>
<tr>
<td align="center">havcs_device_type</td>
<td align="center">设备类型</td>
<td align="center">light /switch /sensor /input_boolean</td>
<td align="center">light</td>
<td align="center">一般不用指定</td>
</tr>
<tr>
<td align="center">havcs_attributes</td>
<td align="center">属性</td>
<td align="center">[‘temperature’, ‘brightness’, ‘humidity’, ‘pm25’, ‘co2’, ‘power_state’]</td>
<td align="center">[‘power_state’]</td>
<td align="center">一般不用指定</td>
</tr>
<tr>
<td align="center">havcs_actions</td>
<td align="center">支持操作</td>
<td align="center">[‘turn_on’, ‘turn_off’, ‘timing_turn_on’, ‘timing_turn_off’, ‘query_temperature’, ‘query_humidity’, ‘increase_brightness’, ‘decrease_brightness’]</td>
<td align="center">[‘turn_on’, ‘turn_off’]</td>
<td align="center">一般不用指定</td>
</tr>
<tr>
<td align="center">havcs_related_sensors</td>
<td align="center">传感器设备专用，关联真实传感器</td>
<td align="center">sensor/group列表</td>
<td align="center">[‘sensor.demo’, ‘group.demo’]</td>
<td align="center">支持设置group，会搜索加入该分组下的sensor</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>INFO：属性字典的格式为”属性名: 取值”，需要有1个空格间隔。</strong></p>
</blockquote>
<h3 id="2-1-特殊设备配置说明"><a href="#2-1-特殊设备配置说明" class="headerlink" title="2.1 特殊设备配置说明"></a>2.1 特殊设备配置说明</h3><p>对input_boolean类型的配置方式进行了扩展，实现指定指令调用自定义的service。</p>
<ul>
<li>新增一个input_boolean实体<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#&#123;HA配置目录&#125;/configuration.yaml</span></span><br><span class="line"><span class="attr">input_boolean:</span></span><br><span class="line">  <span class="attr">call_service:</span></span><br></pre></td></tr></table></figure></li>
<li>自定义虚拟input_boolean的属性，在havcs_actions属性中设置对应的service指令（只能设置turn_on/turn_off/timing_turn_on/timing_turn_off/increase_brightness/decrease_brightness，对应打开/关闭/延时打开/延时关闭/调高亮度/调低亮度指令）<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#&#123;HA配置目录&#125;/havcs.yaml</span></span><br><span class="line"><span class="attr">input_boolean.call_service:</span>  </span><br><span class="line">  <span class="attr">havcs_device_name:</span> <span class="string">客厅灯</span></span><br><span class="line">  <span class="attr">havcs_zone:</span> <span class="string">客厅</span></span><br><span class="line">  <span class="attr">havcs_device_type:</span> <span class="string">light</span>                <span class="comment"># 模拟灯设备</span></span><br><span class="line">  <span class="attr">havcs_attributes:</span> [<span class="string">&#x27;power_state&#x27;</span>]       </span><br><span class="line">  <span class="comment">#↓↓↓指令根据实际需要配置↓↓↓</span></span><br><span class="line">  <span class="attr">havcs_actions:</span></span><br><span class="line">      <span class="comment"># service指令格式:[domain, service_name, service_data（json字符串）]，具体内容需参见相应组件的服务定义。</span></span><br><span class="line">      <span class="comment"># 注意，参数变更为数组以支持多条指令，单条指令也别忘了加-</span></span><br><span class="line">      <span class="attr">turn_on:</span></span><br><span class="line">        <span class="bullet">-</span> [<span class="string">&#x27;common_timer&#x27;</span>, <span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;&#123;&quot;entity_id&quot;:&quot;switch.demo&quot;,&quot;duration&quot;:&quot;01:00:00&quot;,&quot;operation&quot;:&quot;off&quot;&#125;&#x27;</span>] <span class="comment"># 打开命令</span></span><br><span class="line">        <span class="bullet">-</span> [<span class="string">&#x27;input_boolean&#x27;</span>, <span class="string">&#x27;turn_on&#x27;</span>, <span class="string">&#x27;&#123;&#125;&#x27;</span>] <span class="comment"># 同步打开状态</span></span><br><span class="line">      <span class="attr">turn_off:</span></span><br><span class="line">        <span class="bullet">-</span> [<span class="string">&#x27;common_timer&#x27;</span>, <span class="string">&#x27;cancel&#x27;</span>, <span class="string">&#x27;&#123;&quot;entity_id&quot;:&quot;switch.demo&quot;&#125;&#x27;</span>] <span class="comment"># 关闭命令</span></span><br><span class="line">        <span class="bullet">-</span> [<span class="string">&#x27;input_boolean&#x27;</span>, <span class="string">&#x27;turn_off&#x27;</span>, <span class="string">&#x27;&#123;&#125;&#x27;</span>] <span class="comment"># 同步关闭状态</span></span><br><span class="line">      <span class="attr">timing_turn_on:</span>         <span class="comment"># 延时打开指令（小度音箱）</span></span><br><span class="line">        <span class="bullet">-</span> [<span class="string">&#x27;指令1&#x27;</span>]</span><br><span class="line">        <span class="bullet">-</span> [<span class="string">&#x27;指令2&#x27;</span>]</span><br><span class="line">      <span class="attr">timing_turn_off:</span>        <span class="comment"># 延时关闭指令（小度音箱）</span></span><br><span class="line">        <span class="bullet">-</span> [<span class="string">&#x27;指令1&#x27;</span>]</span><br><span class="line">        <span class="bullet">-</span> [<span class="string">&#x27;指令2&#x27;</span>]</span><br><span class="line">      <span class="attr">increase_brightness:</span></span><br><span class="line">        <span class="bullet">-</span> [<span class="string">&#x27;指令1&#x27;</span>]</span><br><span class="line">        <span class="bullet">-</span> [<span class="string">&#x27;指令2&#x27;</span>]</span><br><span class="line">      <span class="attr">decrease_brightness:</span></span><br><span class="line">        <span class="bullet">-</span> [<span class="string">&#x27;指令1&#x27;</span>]</span><br><span class="line">        <span class="bullet">-</span> [<span class="string">&#x27;指令2&#x27;</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>__INFO：调自动化(automation.turn_on)、调脚本(scrpit.turn_on)、调红外指令(climate.xiaomi_miio_send_command)等会比较适合。__<br><strong>INFO：天猫精灵无法自定义名称，不太适合使用。</strong></p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="3-完成度"><a href="#3-完成度" class="headerlink" title="3.完成度"></a>3.完成度</h2><p>目前完成度有些低，后续再继续测试完善吧。</p>
<ul>
<li>图例：✓ 支持，- 不支持，* 待测试</li>
<li>switch/cover</li>
</ul>
<table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">描述</th>
<th align="center">aligenie</th>
<th align="center">dueros</th>
<th align="center">jdwhale</th>
</tr>
</thead>
<tbody><tr>
<td align="center">turn_on</td>
<td align="center">打开</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
</tr>
<tr>
<td align="center">turn_off</td>
<td align="center">关闭</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
</tr>
<tr>
<td align="center">timing_turn_on</td>
<td align="center">延时打开</td>
<td align="center">-</td>
<td align="center">✓</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">timing_turn_off</td>
<td align="center">延时关闭</td>
<td align="center">-</td>
<td align="center">✓</td>
<td align="center">-</td>
</tr>
</tbody></table>
<ul>
<li>light</li>
</ul>
<table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">描述</th>
<th align="center">aligenie</th>
<th align="center">dueros</th>
<th align="center">jdwhale</th>
</tr>
</thead>
<tbody><tr>
<td align="center">turn_on</td>
<td align="center">打开</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
</tr>
<tr>
<td align="center">turn_off</td>
<td align="center">关闭</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
</tr>
<tr>
<td align="center">timing_turn_on</td>
<td align="center">延时打开</td>
<td align="center">-</td>
<td align="center">✓</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">timing_turn_off</td>
<td align="center">延时关闭</td>
<td align="center">-</td>
<td align="center">✓</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">set_brightness</td>
<td align="center">设置亮度</td>
<td align="center">*</td>
<td align="center">*</td>
<td align="center">*</td>
</tr>
<tr>
<td align="center">increase_brightness</td>
<td align="center">调高亮度</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
</tr>
<tr>
<td align="center">decrease_brightness</td>
<td align="center">调低亮度</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
</tr>
<tr>
<td align="center">set_color</td>
<td align="center">设置颜色</td>
<td align="center">*</td>
<td align="center">✓</td>
<td align="center">*</td>
</tr>
</tbody></table>
<ul>
<li>sensor</li>
</ul>
<table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">描述</th>
<th align="center">aligenie</th>
<th align="center">dueros</th>
<th align="center">jdwhale</th>
</tr>
</thead>
<tbody><tr>
<td align="center">query_temperature</td>
<td align="center">查询温度</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
</tr>
<tr>
<td align="center">query_humidity</td>
<td align="center">查询湿度</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
</tr>
</tbody></table>
<ul>
<li>inpu_boolean</li>
</ul>
<table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">描述</th>
<th align="center">aligenie</th>
<th align="center">dueros</th>
<th align="center">jdwhale</th>
</tr>
</thead>
<tbody><tr>
<td align="center">turn_on</td>
<td align="center">打开</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
</tr>
<tr>
<td align="center">turn_off</td>
<td align="center">关闭</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
</tr>
<tr>
<td align="center">timing_turn_on</td>
<td align="center">延时打开</td>
<td align="center">-</td>
<td align="center">✓</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">timing_turn_off</td>
<td align="center">延时关闭</td>
<td align="center">-</td>
<td align="center">✓</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">increase_brightness</td>
<td align="center">调高亮度</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
</tr>
<tr>
<td align="center">decrease_brightness</td>
<td align="center">调低亮度</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
</tr>
</tbody></table>
<hr>
<h2 id="4-控制指令说明"><a href="#4-控制指令说明" class="headerlink" title="4.控制指令说明"></a>4.控制指令说明</h2><ul>
<li>叮咚<ul>
<li>打开/关闭<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#打开/关闭</span></span><br><span class="line"><span class="comment">#用途：一般为电源控制</span></span><br><span class="line"><span class="comment">#语义：打开/关闭&#123;设备名称&#125;</span></span><br><span class="line"><span class="comment">#例子：打开主卧灯</span></span><br></pre></td></tr></table></figure></li>
<li>查询状态<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#打开/关闭</span></span><br><span class="line"><span class="comment">#用途：查询设备状态</span></span><br><span class="line"><span class="comment">#语义：查询&#123;设备名称&#125;的&#123;状态/xx状态&#125;</span></span><br><span class="line"><span class="comment">#例子：查询主卧传感器的状态；查询主卧传感器的温度；查询主卧灯的电源状态</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：传感器信息需要挂靠到具体设备上进行查询。一般来说温度、湿度需要挂靠到空气净化器类型上。</strong></p>
</blockquote>
</li>
</ul>
</li>
<li>天猫精灵<ul>
<li>打开/关闭<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#打开/关闭</span></span><br><span class="line"><span class="comment">#用途：一般为电源控制</span></span><br><span class="line"><span class="comment">#语义：打开/关闭&#123;房间名&#125;的&#123;设备类型/别名&#125;</span></span><br><span class="line"><span class="comment">#例子：打开主卧的灯。</span></span><br><span class="line"><span class="comment">#备注：&#123;房间名&#125;、&#123;设备类型/别名&#125;需要指定，均为枚举值</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：优先匹配“位置（可为空）+别名”：例如有台灯、灯两个设备，“打开台灯”则精确匹配台灯；然后匹配“位置（可为空）+设备类型”，例如有一个台灯设备，“打开吸顶灯”、“打开床头灯”等都可控制。指令不带位置，如设备别名多个匹配，询问设备位置；当有相同匹配，一起执行。</strong></p>
</blockquote>
</li>
<li>查询状态<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#打开/关闭</span></span><br><span class="line"><span class="comment">#用途：查询设备状态</span></span><br><span class="line"><span class="comment">#语义：查询&#123;房间名&#125;&#123;设备类型/别名&#125;的&#123;状态/xx状态&#125;</span></span><br><span class="line"><span class="comment">#例子：查询主卧传感器的状态；查询主卧传感器的温度</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：查询传感器好像有个bug：查询所有状态不能正常播报；查询单个状态，发送的指令是查询所有状态的指令。</strong></p>
</blockquote>
</li>
</ul>
</li>
<li>小度<ul>
<li>打开/关闭<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#打开/关闭</span></span><br><span class="line"><span class="comment">#用途：一般为电源控制</span></span><br><span class="line"><span class="comment">#语义：打开/关闭&#123;设备名称&#125;</span></span><br><span class="line"><span class="comment">#例子：打开主卧灯</span></span><br><span class="line"><span class="string">```</span>   </span><br><span class="line"><span class="bullet">-</span> <span class="string">查询状态</span></span><br><span class="line"><span class="string">```yaml</span></span><br><span class="line"><span class="comment">#打开/关闭</span></span><br><span class="line"><span class="comment">#用途：查询设备状态</span></span><br><span class="line"><span class="comment">#语义：查询&#123;设备名称&#125;的&#123;xx状态&#125;/&#123;设备名称&#125;查询&#123;xx状态&#125;</span></span><br><span class="line"><span class="comment">#例子：查询主卧传感器的温度/主卧传感器查询温度</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：只能查询单一状态。</strong></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="4-停用插件"><a href="#4-停用插件" class="headerlink" title="4.停用插件"></a>4.停用插件</h2><p><del>插件初始化代码是抄官方组件的，启用后会默认继续加载，删除core.config_entries文件相关的内容即可。</del>新版已解决。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#&#123;HA配置目录&#125;/.storage/core.config_entries</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;data&quot;:</span> &#123;</span><br><span class="line">        <span class="attr">&quot;entries&quot;:</span> [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;connection_class&quot;:</span> <span class="string">&quot;local_push&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;data&quot;:</span> &#123;&#125;,</span><br><span class="line">                <span class="attr">&quot;domain&quot;:</span> <span class="string">&quot;aihome&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;entry_id&quot;:</span> <span class="string">&quot;8aa4ee3717771778f84e4ac4bdfe055b&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;options&quot;:</span> &#123;&#125;,</span><br><span class="line">                <span class="attr">&quot;source&quot;:</span> <span class="string">&quot;import&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;title&quot;:</span> <span class="string">&quot;configuration.yaml&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;version&quot;:</span> <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;key&quot;:</span> <span class="string">&quot;core.config_entries&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;version&quot;:</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-调试说明"><a href="#5-调试说明" class="headerlink" title="5.调试说明"></a>5.调试说明</h2><ul>
<li>把havcs插件日志级别提高，过滤其它插件输出日志，方便观察日志输出，调试后注意恢复<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># [HA配置目录]/configuration.yaml</span></span><br><span class="line"><span class="attr">logger:</span></span><br><span class="line">  <span class="attr">default:</span> <span class="string">error</span>  <span class="comment"># 提高所有组件的默认级别，调试完后改回info（预设）</span></span><br><span class="line">  <span class="attr">logs:</span>           <span class="comment"># 设定指定组件的级别，debug有更详细的输出</span></span><br><span class="line">    <span class="attr">custom_components.havcs:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li>根据<a href="https://ljr.im/articles/home-assistant-novice-question-set/#3-%E8%B0%83%E8%AF%95%E5%8F%8A%E6%9F%A5%E7%9C%8B%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%A5%E5%BF%97" title="调试及查看程序运行日志">教程</a>调整插件的调试级别查看详细的运行日志</li>
<li>配置好插件，启动HA，观看是否有mqtt连接成功信息（app技能接入方式）</li>
<li>授权过程，观看是否有相关的处理日志</li>
<li>说音响指令后，观看是否有相关的处理日志</li>
<li>web页面-&gt;开发者工具-&gt;服务-&gt;havcs.reload，观看是否生成设备信息</li>
</ol>
<blockquote>
<p><strong>WARN: 如需要帮助，请提供以上步骤相对应的日志信息方便定位原因。</strong></p>
</blockquote>
<hr>
<h2 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h2><ul>
<li>有了统一的设备信息定义，后续可以考虑做设备管理页面。</li>
</ul>
]]></content>
      <categories>
        <category>Home Assistant</category>
      </categories>
      <tags>
        <tag>Home Assistant</tag>
        <tag>插件</tag>
        <tag>智能音箱</tag>
      </tags>
  </entry>
  <entry>
    <title>【翻车系列】智能音箱通用接入平台</title>
    <url>/articles/rollover-series-universal-access-platform-for-smart-speakers/</url>
    <content><![CDATA[<p>去年买了echo、天猫精灵、小度、叮咚、小爱等智能音箱，想着使用语音控制家里的设备，折腾了好久智能家居技能，发现都有不少的局限：echo的需要用自家服务器、天猫精灵的房间名称太局限、叮咚没有智能家居技能。后来将目光转向了自定义技能，萌生了一个比较优雅接入的想法：音箱平台都统一语义语法，指令让中间服务解析，最后转化为HA的标准调用服务数据，交给HA执行。于是使用nodered初步对想法进行了验证，完成了echo、天猫精灵、小度、叮咚、小爱的接入测试。本来想着发布出来，但发现使用成本很高：需要各自部署http服务器、数据库、nodered，还要公网ip。于是乎为了更好的使用体验，只有继续填坑，折腾出了现在这个平台。虽然有点迟，也算交一份2018年学习HA的作业吧。</p>
<hr>
<a id="more"></a>
<h2 id="0-更新"><a href="#0-更新" class="headerlink" title="0.更新"></a>0.更新</h2><p><font color=red>2019.01.30 翻车了，自定义技能因不允许进行智能家居控制无法上线，只能自用了。</font></p>
<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p><strong>技术架构</strong></p>
<ul>
<li><strong>智能音箱技能平台</strong>&lt;=(skill对接，json指令)=&gt;<strong>ai-home平台</strong>&lt;=(mqtt消息，service指令)=&gt;<strong>Home Assistant</strong></li>
</ul>
<p><strong>特点</strong></p>
<ul>
<li>无需公网ip</li>
<li>多种智能音箱统一接入，只需维护一份设备信息</li>
<li>基于service指令控制，ai-home平台将语音指令转换成HA的service指令进行控制，更加灵活，例如通过语音调用自动化也是可以的</li>
<li>更低的权限要求，不用开放HA全部api权限，可设置控制设备白名单，仅处理白名单设备的控制指令</li>
</ul>
<h2 id="2-完成度"><a href="#2-完成度" class="headerlink" title="2.完成度"></a>2.完成度</h2><p><strong>控制指令</strong></p>
<ul>
<li>目前控制指暂时只有开/关操作</li>
</ul>
<p><strong>支持平台</strong></p>
<ul>
<li>alexa：已对接测试，提交技能审核</li>
<li>天猫精灵：已对接测试，提交技能审核</li>
<li>小度：已对接测试，提交技能审核</li>
<li>叮咚：已对接测试，提交技能审核</li>
<li>小爱：认证需要搞手持身份证，放弃</li>
<li>有其它音箱接入需求可以反馈我研究下</li>
</ul>
<p><strong>问题</strong></p>
<ul>
<li>多用户使用场景没有条件测试，估计有不少bug</li>
<li>多用户并发下服务器处理性能、带宽问题</li>
</ul>
<h2 id="3-隐私政策"><a href="#3-隐私政策" class="headerlink" title="3.隐私政策"></a>3.隐私政策</h2><p><strong>保存数据内容</strong></p>
<ul>
<li>需要保存用户名以及相应的设备信息</li>
</ul>
<p><strong>多用户安全性保障</strong></p>
<ul>
<li>mqtt启用TLS</li>
<li>acl来隔离不同用户的主题</li>
<li>对mqtt消息进行加密</li>
</ul>
<p><strong>服务不可用可能性申明</strong></p>
<ul>
<li>不可抗力自然因素</li>
<li>断电、断网</li>
<li>服务器宕机</li>
<li>本人偷懒</li>
</ul>
<p>综上所述，本接入方法仅当测试和学习使用，不建议录太多的设备使用。</p>
<h2 id="4-使用说明"><a href="#4-使用说明" class="headerlink" title="4.使用说明"></a>4.使用说明</h2><ol>
<li><p>打开<a href="https://ai-home.ljr.im/device/reg.php" title="注册">注册页面</a>，注册账号</p>
<blockquote>
<p><strong>INFO：注册好后请联系我设置mqtt消息权限。</strong></p>
</blockquote>
</li>
<li><p>进入<a href="https://ai-home.ljr.im/device/index.php" title="设备管理">设备管理页面</a>，添加设备</p>
<img src="/articles/rollover-series-universal-access-platform-for-smart-speakers/%E6%B7%BB%E5%8A%A0%E8%AE%BE%E5%A4%87.png" class="" title="[添加设备]"> </li>
</ol>
<ul>
<li>设备名称（中文）：语音指令用，指定控制的设备</li>
<li>设备名称（英文）：echo音箱用</li>
<li>位置：语音指令用，指定设备的位置</li>
<li>设备类型：暂时没用</li>
<li>设备ID：HA中设备的entity_id，如果服务不需要，可以随便填</li>
<li>控制指令类型：暂时只有打开、关闭，选中后需要继续填写指令内容</li>
<li>指令内容：填写语音指令对应的对应的HA service指令，格式为：’HA服务全称[键值对1][键值对2]’，如果要追加其他service数据，增加方括号[]填写键值对即可。  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#样例：switch.turn_on[a:1][b:2]，最终HA收到服务数据为</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;entity_id&quot;</span>:<span class="string">&quot;switch.test&quot;</span>,</span><br><span class="line">    <span class="string">&quot;a&quot;</span>:<span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;b&quot;</span>:<span class="string">&quot;2&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：键值对的值目前只支持字符串。</strong></p>
</blockquote>
</li>
<li>icon（图标）：展示的图标，设备管理页面显示</li>
</ul>
<ol start="3">
<li><p>HA配置</p>
<p>参见<a href="https://github.com/cnk700i/ai-home" title="插件">github</a></p>
</li>
<li><p>技能调用</p>
<p>技能调用名称为“家庭助手”（暂定），一般有两种方式调用：</p>
</li>
</ol>
<ul>
<li>待机状态下，先唤醒：“xxxx（音箱唤醒词），打开家庭助手”，然后说“打开主卧的灯”<blockquote>
<p><strong>INFO：天猫精灵不能这样用，会调用自己的智能家居技能。</strong></p>
</blockquote>
</li>
<li>待机状态下，直接：“xxxx（音箱唤醒词），让家庭助手打开主卧的灯”<blockquote>
<p><strong>INFO：具体有待正式测试确认。</strong></p>
</blockquote>
</li>
</ul>
<ol>
<li>控制指令说明</li>
</ol>
<ul>
<li>打开/关闭<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#打开/关闭</span></span><br><span class="line"><span class="comment">#用途：一般为电源控制</span></span><br><span class="line"><span class="comment">#语义：&#123;操作&#125;&#123;房间名&#125;的&#123;设备名&#125;</span></span><br><span class="line"><span class="comment">#例子：打开主卧的灯。</span></span><br><span class="line"><span class="comment">#备注：&#123;操作&#125;、&#123;房间名&#125;为枚举，&#123;设备名&#125;自定义</span></span><br></pre></td></tr></table></figure>
<h2 id="5-遇到的坑"><a href="#5-遇到的坑" class="headerlink" title="5.遇到的坑"></a>5.遇到的坑</h2></li>
<li>各音箱平台指令的解析</li>
<li>设备管理页面前端技术Vue、jQuery WeUI</li>
<li>多用户场景下mqtt消息发送、处理</li>
<li>HA中为不影响原有mqtt功能新起mqtt实例</li>
<li>安全性保障</li>
<li>搭建服务器系统环境、网络环境</li>
</ul>
<h2 id="6-Thanks-To"><a href="#6-Thanks-To" class="headerlink" title="6.Thanks To"></a>6.Thanks To</h2><ul>
<li><a href="https://bbs.hassbian.com/thread-2285-1-1.html">qebabe@瀚思彼岸</a> for 设备管理页面参考</li>
<li><a href="https://github.com/try-to/swoole_mqtt">try-to@github</a> for 接入平台端mqtt功能</li>
<li><a href="https://www.home-assistant.io/">mqtt组件@Home-assistant</a> for HA端mqtt功能</li>
</ul>
]]></content>
      <categories>
        <category>Home Assistant</category>
      </categories>
      <tags>
        <tag>Home Assistant</tag>
        <tag>插件</tag>
        <tag>智能音箱</tag>
      </tags>
  </entry>
  <entry>
    <title>【踩坑系列】Home Assistant中Aqara人体传感器的触发状态异常</title>
    <url>/articles/stepping-on-the-pit-series-trigger-status-of-aqara-human-sensor-in-home-assistant-is-abnormal/</url>
    <content><![CDATA[<blockquote>
<p>前不久将Aqara人体传感器接入了HA，联动控制楼梯灯，使用下来感觉除了感应距离和范围小了点，灵敏度还是可以的。另外发现了一个问题，HA中它的state有点迷，基本都是“触发”状态，不能够正常同步真实状态。</p>
</blockquote>
<hr>
<a id="more"></a>
<h2 id="1-环境"><a href="#1-环境" class="headerlink" title="1.环境"></a>1.环境</h2><p>Ubuntu18.04 + HA 0.71.0</p>
<hr>
<h2 id="2-过程"><a href="#2-过程" class="headerlink" title="2.过程"></a>2.过程</h2><p>{[HA安装目录]}/components/binary_sensor/xiaomi_aqara.py中XiaomiMotionSensor类的init方法增加一行代码即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#……省略……#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaomiMotionSensor</span>(<span class="params">XiaomiBinarySensor</span>):</span></span><br><span class="line"><span class="comment">#……省略……#</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, device, hass, xiaomi_hub</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Initialize the XiaomiMotionSensor.&quot;&quot;&quot;</span></span><br><span class="line">    self._hass = hass</span><br><span class="line">    self._no_motion_since = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;proto&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> device <span class="keyword">or</span> int(device[<span class="string">&#x27;proto&#x27;</span>][<span class="number">0</span>:<span class="number">1</span>]) == <span class="number">1</span>:</span><br><span class="line">        data_key = <span class="string">&#x27;status&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        data_key = <span class="string">&#x27;motion_status&#x27;</span></span><br><span class="line">    XiaomiBinarySensor.__init__(self, device, <span class="string">&#x27;Motion Sensor&#x27;</span>, xiaomi_hub,</span><br><span class="line">                                data_key, <span class="string">&#x27;motion&#x27;</span>)</span><br><span class="line">    self._should_poll = <span class="literal">True</span>		<span class="comment">#增加的代码行</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：HA启动过程会为binary_sensor.xiaomi_aqara这个platform注册一个更新数据的周期性任务（任务中通过should_poll属性判断该设备是否调用update方法去更新数据），前提是该platform下的设备的should_poll属性不能全为False。而代码中默认的should_poll属性都是False，所以导致无法正常更新数据。故需要在设备初始化的时候设置一下should_poll的值即可。</strong></p>
</blockquote>
<hr>
<h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h2><h3 id="3-1-接入HA"><a href="#3-1-接入HA" class="headerlink" title="3.1.接入HA"></a>3.1.接入HA</h3><p>Aqara人体传感器通过米家APP加入网关，HA使用xiaomi_aqara配置网关信息即可。HA启动会自动发现设备，然后生成一个binary_sensor.motion_sensor_xxxxxxxxxxxxxx的entity</p>
<h3 id="3-2-Aqara人体传感器工作方式"><a href="#3-2-Aqara人体传感器工作方式" class="headerlink" title="3.2.Aqara人体传感器工作方式"></a>3.2.Aqara人体传感器工作方式</h3><p>1）触发后，设备立刻报送移动状态[{“motion_status”:”motion”}] 以及光照度[{“lux”:100},{“illumination”:100}]</p>
<p>2）触发后的1分钟内是罢工状态，即不会监测是否有人</p>
<p>3）触发后1分钟，motion_status变为no_motion，但不会主动上报！（就是这么任性），需要主动去读取状态</p>
<hr>
]]></content>
      <categories>
        <category>Home Assistant</category>
      </categories>
      <tags>
        <tag>Home Assistant</tag>
        <tag>Aqara</tag>
        <tag>踩坑系列</tag>
      </tags>
  </entry>
  <entry>
    <title>【踩坑系列】Home Assistant中索尼x77无法播放tts</title>
    <url>/articles/stepping-on-the-pit-series-sony-x77-cannot-play-tts-in-home-assistant/</url>
    <content><![CDATA[<blockquote>
<p>最近逛瀚思彼岸学习，发现可以用上tts的场景挺多的。刚好手里有台充值信仰入的索尼SRX-X77音响，于是尝试进行接入，发现了问题：HA能自动识别出来，但无法播放；进一步测试发现，Kodi软件配置dlna服务后给HA调用功能正常、另外使用windows media调用X77也正常。由此开始了漫长的折腾，期间研读插件代码、学习dlna协议、还抓包对比分析，最后算是解决了，虽然不完美。</p>
</blockquote>
<hr>
<a id="more"></a>

<h2 id="1-准备"><a href="#1-准备" class="headerlink" title="1.准备"></a>1.准备</h2><ul>
<li>Ubuntu 16.04 + HA 0.68.0</li>
<li>dlna插件（自定义插件，<a href="https://bbs.hassbian.com/thread-2313-1-1.html" title="[插件发布] 【虫子DLNA插件小改版】TTS的福音来了，安桥功放机小爱">配置参考教程</a>）</li>
<li>tts插件（官方已集成插件，<a href="https://bbs.hassbian.com/thread-33-1-1.html" title="[进阶教程] 安装虫子神写的百度TTS">配置参考教程</a>）<blockquote>
<p><strong>DEBUG：dlna插件上有输入文本播放语音，需要调用tts插件完成</strong></p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="2-过程"><a href="#2-过程" class="headerlink" title="2.过程"></a>2.过程</h2><h3 id="2-1解决状态识别失败"><a href="#2-1解决状态识别失败" class="headerlink" title="2.1解决状态识别失败"></a>2.1解决状态识别失败</h3><ul>
<li>修改{[HA配置目录]}/custom_components/dlna.py  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#小改，改动地方见中文备注</span></span><br><span class="line"><span class="comment">#……省略……#</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register_device</span>(<span class="params">self,location_url</span>):</span></span><br><span class="line"><span class="comment">#……省略……#</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        SCPDURLpath = info.find(</span><br><span class="line">            <span class="string">&quot;./device/serviceList/service/[serviceType=&#x27;&#123;&#125;&#x27;]/SCPDURL&quot;</span>.format(</span><br><span class="line">                UPNP_DEFAULT_SERVICE_TYPE</span><br><span class="line">            )</span><br><span class="line">        ).text  <span class="comment">#增加&quot;.text&quot;</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        SCPDURLpath = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        eventSubURLpath = info.find(</span><br><span class="line">            <span class="string">&quot;./device/serviceList/service/[serviceType=&#x27;&#123;&#125;&#x27;]/eventSubURL&quot;</span>.format(           <span class="comment">#参考X77的配置xml，将原来的“eventSubURLpath”改成“eventSubURL”</span></span><br><span class="line">                UPNP_DEFAULT_SERVICE_TYPE</span><br><span class="line">            )</span><br><span class="line">        ).text  <span class="comment">#增加&quot;.text&quot;</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        eventSubURLpath = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#……省略……#</span></span><br></pre></td></tr></table></figure></li>
<li>{[HA配置目录]}/custom_components/media_player/dlna.py  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#小改，改动地方见中文备注</span></span><br><span class="line"><span class="comment">#……省略……#</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">soapRequest</span>(<span class="params">self,location, service, fnName, fnParams</span>):</span></span><br><span class="line">    bodyString = <span class="string">&#x27;&lt;?xml version=&quot;1.0&quot;?&gt;&#x27;</span></span><br><span class="line">    bodyString += <span class="string">&#x27;&lt;s:Envelope xmlns:s=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; s:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt;&#x27;</span><span class="comment">#s:encodingStyle段描述从&lt;s:Body&gt;上移</span></span><br><span class="line">    bodyString += <span class="string">&#x27;  &lt;s:Body&gt;&#x27;</span></span><br><span class="line">    bodyString += <span class="string">&#x27;    &lt;u:&#x27;</span> + fnName + <span class="string">&#x27; xmlns:u=&quot;&#x27;</span> + service + <span class="string">&#x27;&quot;&gt;&#x27;</span></span><br><span class="line">    bodyString += <span class="string">&#x27;      &#x27;</span> + fnParams</span><br><span class="line">    bodyString += <span class="string">&#x27;    &lt;/u:&#x27;</span> + fnName + <span class="string">&#x27;&gt;&#x27;</span></span><br><span class="line">    bodyString += <span class="string">&#x27;  &lt;/s:Body&gt;&#x27;</span></span><br><span class="line">    bodyString += <span class="string">&#x27;&lt;/s:Envelope&gt;&#x27;</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/xml; charset=&quot;utf-8&quot;&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Cache-Control&#x27;</span>: <span class="string">&#x27;no-cache&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Connection&#x27;</span>: <span class="string">&#x27;Close&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Pragma&#x27;</span>: <span class="string">&#x27;no-cache&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;text/xml&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;UPnP/1.0&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;SOAPAction&#x27;</span>: <span class="string">&#x27;&quot;&#x27;</span>+service + <span class="string">&#x27;#&#x27;</span> + fnName + <span class="string">&#x27;&quot;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        res = requests.post(location, data=bodyString.encode(<span class="string">&#x27;utf-8&#x27;</span>), headers=headers,timeout=<span class="number">10</span>)</span><br><span class="line">        res.encoding = <span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        _LOGGER.error(<span class="string">&quot;send Request Error:&#123;&#125;&quot;</span>.format(e))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"><span class="comment">#……省略……#</span></span><br></pre></td></tr></table></figure>
<h2 id="2-2解决无法播放tts"><a href="#2-2解决无法播放tts" class="headerlink" title="2.2解决无法播放tts"></a>2.2解决无法播放tts</h2></li>
<li>{[HA配置目录]}custom_components/media_player/dlna.py  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#……省略……#</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">play_media</span>(<span class="params">self, media_type, media_id, **kwargs</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Send play_media commmand.&quot;&quot;&quot;</span></span><br><span class="line">    self._device.Stop() <span class="comment">#增加停止方法</span></span><br><span class="line">    media_data=(<span class="string">&#x27;&amp;lt;DIDL-Lite xmlns=&quot;urn:schemas-upnp-org:metadata-1-0/DIDL-Lite/&quot; xmlns:upnp=&quot;urn:schemas-upnp-org:metadata-1-0/upnp/&quot; xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot;&amp;gt;&#x27;</span></span><br><span class="line">                <span class="string">&#x27;&amp;lt;item id=&quot;f-0&quot; parentID=&quot;0&quot; restricted=&quot;0&quot;&amp;gt;&#x27;</span></span><br><span class="line">                <span class="string">&#x27;&amp;lt;dc:title&amp;gt;Audio&amp;lt;/dc:title&amp;gt;&#x27;</span></span><br><span class="line">                <span class="string">&#x27;&amp;lt;dc:creator&amp;gt;Anonymous&amp;lt;/dc:creator&amp;gt;&#x27;</span></span><br><span class="line">                <span class="string">&#x27;&amp;lt;upnp:class&amp;gt;object.item.audioItem.musicTrack&amp;lt;/upnp:class&amp;gt;&#x27;</span></span><br><span class="line">                <span class="string">&#x27;&amp;lt;res duration=&quot;0:00:00.500&quot; bitrate=&quot;2000&quot; bitsPerSample=&quot;16&quot; sampleFrequency=&quot;16000&quot; nrAudioChannels=&quot;1&quot; protocolInfo=&quot;http-get:*:audio/mpeg:DLNA.ORG_PN=MP3;DLNA.ORG_OP=01;DLNA.ORG_FLAGS=01500000000000000000000000000000&quot;&amp;gt;&#123;&#125;&amp;lt;/res&amp;gt;&#x27;</span>  </span><br><span class="line">                <span class="string">&#x27;&amp;lt;/item&amp;gt;&#x27;</span></span><br><span class="line">                <span class="string">&#x27;&amp;lt;/DIDL-Lite&amp;gt;&#x27;</span>) <span class="comment">#增加设置media_data参数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self._device.SetAVTransportURI(media_id,media_data.format(media_id))[<span class="string">&#x27;status&#x27;</span>] == <span class="number">200</span>:  <span class="comment">#增加判断是否成功设置媒体URI</span></span><br><span class="line">        self._device.Play()</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment">#……省略……#</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：参考windows media player调用x77的dlna服务抓包设置的参数</strong></p>
</blockquote>
</li>
</ul>
<h2 id="3-解决播放tts不完整问题（播到最后两个字就中断了）"><a href="#3-解决播放tts不完整问题（播到最后两个字就中断了）" class="headerlink" title="3.解决播放tts不完整问题（播到最后两个字就中断了）"></a>3.解决播放tts不完整问题（播到最后两个字就中断了）</h2><ul>
<li>{[HA安装目录]}/components/http/view.py  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#小改，改动地方见中文备注</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeAssistantView</span>(<span class="params">object</span>):</span></span><br><span class="line"><span class="comment">#……省略……#</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">register</span>(<span class="params">self, router</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Register the view with a router.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">assert</span> self.url <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>, <span class="string">&#x27;No url set for view&#x27;</span></span><br><span class="line">        urls = [self.url] + self.extra_urls</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> method <span class="keyword">in</span> (<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;post&#x27;</span>, <span class="string">&#x27;delete&#x27;</span>, <span class="string">&#x27;put&#x27;</span>, <span class="string">&#x27;head&#x27;</span>): <span class="comment">#增加head处理方法</span></span><br><span class="line">            handler = getattr(self, method, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> handler:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            handler = request_handler_factory(self, handler)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">                router.add_route(method, url, handler)</span><br><span class="line"><span class="comment">#……省略……#</span></span><br></pre></td></tr></table></figure></li>
<li>{[HA安装目录]}/components/tts/<strong>init</strong>.py<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#增加head方法，同时响应断点续传的get请求</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextToSpeechView</span>(<span class="params">HomeAssistantView</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;TTS view to serve a speech audio.&quot;&quot;&quot;</span></span><br><span class="line">    requires_auth = <span class="literal">False</span></span><br><span class="line">    url = <span class="string">&#x27;/api/tts_proxy/&#123;filename&#125;&#x27;</span></span><br><span class="line">    name = <span class="string">&#x27;api:tts:speech&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, tts</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Initialize a tts view.&quot;&quot;&quot;</span></span><br><span class="line">        self.tts = tts</span><br><span class="line"></span><br><span class="line"><span class="meta">    @asyncio.coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request, filename</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Start a get request.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            content, data = <span class="keyword">yield</span> <span class="keyword">from</span> self.tts.async_read_tts(filename)</span><br><span class="line">        <span class="keyword">except</span> HomeAssistantError <span class="keyword">as</span> err:</span><br><span class="line">            _LOGGER.error(<span class="string">&quot;Error on load tts: %s&quot;</span>, err)</span><br><span class="line">            <span class="keyword">return</span> web.Response(status=<span class="number">404</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#旧方法 return web.Response(body=data, content_type=content)</span></span><br><span class="line">        <span class="comment">#至后面代码都是新增</span></span><br><span class="line">        headers = &#123;</span><br><span class="line">            <span class="string">&#x27;Accept-Ranges&#x27;</span>: <span class="string">&#x27;bytes&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;TransferMode.DLNA.ORG&#x27;</span>: <span class="string">&#x27;Streaming&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;ContentFeatures.DLNA.ORG&#x27;</span>: <span class="string">&#x27;DLNA.ORG_PN=MP3;DLNA.ORG_OP=01;DLNA.ORG_FLAGS=01500000000000000000000000000000&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> request.headers.get(<span class="string">&#x27;X-AV-Physical-Unit-Info&#x27;</span>) == <span class="string">&#x27;pa=&quot;SRS-X77&quot;&#x27;</span> <span class="keyword">and</span> request.headers.get(<span class="string">&#x27;Range&#x27;</span>) <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            exit()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> web.FileResponse(headers=headers, path=os.path.join(self.tts.cache_dir, filename))</span><br><span class="line"></span><br><span class="line"><span class="meta">    @asyncio.coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">head</span>(<span class="params">self, request, filename</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Start a head request.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            content, data = <span class="keyword">yield</span> <span class="keyword">from</span> self.tts.async_read_tts(filename)</span><br><span class="line">        <span class="keyword">except</span> HomeAssistantError <span class="keyword">as</span> err:</span><br><span class="line">            _LOGGER.error(<span class="string">&quot;Error on load tts: %s&quot;</span>, err)</span><br><span class="line">            <span class="keyword">return</span> web.Response(status=<span class="number">404</span>)</span><br><span class="line">        GMT_FORMAT = <span class="string">&#x27;%a, %d %b %Y %H:%M:%S GMT&#x27;</span></span><br><span class="line">        headers = &#123;</span><br><span class="line">            <span class="string">&#x27;Accept-Ranges&#x27;</span>: <span class="string">&#x27;bytes&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;TransferMode.DLNA.ORG&#x27;</span>: <span class="string">&#x27;Streaming&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Last-Modified&#x27;</span>: dt_util.utcnow().strftime(GMT_FORMAT),</span><br><span class="line">            <span class="string">&#x27;ContentFeatures.DLNA.ORG&#x27;</span>: <span class="string">&#x27;DLNA.ORG_PN=MP3;DLNA.ORG_OP=01;DLNA.ORG_FLAGS=01500000000000000000000000000000&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> web.Response(headers=headers, body=data, content_type=content)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：抓包发现X77get请求tts语音文件使用的是断点续传，所以改用web.FileResponse</strong></p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h2><ul>
<li>X77请求tts语音，会先发一个head请求，如果HA不处理，会导致播放不完整；虽然实现断点续传，测试下来好像不用效果是一样的。</li>
<li>最后还有个问题：文字（过短）过短还是没声音，5个数字内不行，超过5个数字就正常。但kodi是正常的，media player直接推送给X77播放正常，模拟与kodi交互以及media player直接推送交换问题一样，只能判断是bug范畴了。有个想法是给短语音加上静音延长时间，想着播放短语音的场景应该也不多，先搁浅了，毕竟还要花时间学一堆偏门的东西，ha的东西都还有很多没学。。。。</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>Home Assistant</category>
      </categories>
      <tags>
        <tag>Home Assistant</tag>
        <tag>踩坑系列</tag>
        <tag>tts</tag>
        <tag>dlna</tag>
      </tags>
  </entry>
  <entry>
    <title>【踩坑系列】Home Assistant中鸿雁IHC8340B插排开关复位</title>
    <url>/articles/stepping-on-the-pit-series-home-assistant-zhongyan-ihc8340b-plug-switch-reset/</url>
    <content><![CDATA[<blockquote>
<p>趁着618活动入了中草已久的鸿雁插排IHC8340B玩玩，4个独立分控，wifi插线板比wifi插座划算多了。看论坛以前的帖子，用官方的broadlink MP1插件即可。到手之后用broadlink的易控APP设置好网络，按官网的配置指引配置好后，发现控制是可以控制了，不过有点诡异，点开关图标经常回复先前的状态，控制倒是正常。比如开关是“关”状态，点开之后插线板接通了，但HA的开关状态立刻切回“关”状态，等一会后状态就切回为“开”了。于是又是一番研究代码折腾，算是找到初步解决方法了。</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>看了调试信息没发现什么异常，而且通过app学习、使用红外码就正常。孤寂了一段时间，意外在domoticz论坛一个[帖子][1]发现了[抓包分析方法][2]，于是继续分析，算是找到了原因和临时解决办法。</p>
</blockquote>
<hr>
<h2 id="1-准备"><a href="#1-准备" class="headerlink" title="1.准备"></a>1.准备</h2><ul>
<li>IHC8340B插线板，固件版本v10028</li>
<li>Ubuntu 18.04 + HA 0.70.1，</li>
<li>HA的configuration.yaml配置  <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">switch:</span>        </span><br><span class="line"><span class="bullet">-</span> <span class="attr">platform:</span> <span class="string">broadlink</span></span><br><span class="line">    <span class="attr">scan_interval:</span> <span class="number">15</span>   <span class="comment">#自动更新的间隔，默认30s</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">设备ip地址</span></span><br><span class="line">    <span class="attr">mac:</span> <span class="string">&#x27;设备mac地址&#x27;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">mp1</span></span><br><span class="line">    <span class="attr">slots:</span></span><br><span class="line">    <span class="attr">slot_1:</span> <span class="string">&#x27;slot1&#x27;</span>    <span class="comment">#HA会实例化一个switch.slot1设备，这里不要用中文，否则HA实例化的设备名称是switch.x（x是数字），有一定随机性</span></span><br><span class="line">    <span class="attr">slot_2:</span> <span class="string">&#x27;slot2&#x27;</span></span><br><span class="line">    <span class="attr">slot_3:</span> <span class="string">&#x27;slot3&#x27;</span></span><br><span class="line">    <span class="attr">slot_4:</span> <span class="string">&#x27;slot4&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="2-过程"><a href="#2-过程" class="headerlink" title="2.过程"></a>2.过程</h2><h3 id="2-1-工作流程分析"><a href="#2-1-工作流程分析" class="headerlink" title="2.1.工作流程分析"></a>2.1.工作流程分析</h3><p>1）web页面点击开关按钮，触发turn_on或turn_off service（前端js）</p>
<p>2）进行通信、发送控制指令（插件turn_on方法）</p>
<p>3）设置开关状态并调用schedule_update_ha_state通告状态变更（插件turn_on方法）</p>
<p>4）service调用完毕后触发通信查询状态并更新开关状态（系统entity组件）
 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">    <span class="comment">#ha安装目录/homeassistant/components/switch/__init__.py</span></span><br><span class="line">    <span class="comment">#SwitchDevice类async def async_setup(hass, config)函数 部分代码</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">async_handle_switch_service</span>(<span class="params">service</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Handle calls to the switch services.&quot;&quot;&quot;</span></span><br><span class="line">        target_switches = component.async_extract_from_service(service)</span><br><span class="line"></span><br><span class="line">        update_tasks = []</span><br><span class="line">        <span class="keyword">for</span> switch <span class="keyword">in</span> target_switches:</span><br><span class="line">            <span class="keyword">if</span> service.service == SERVICE_TURN_ON:</span><br><span class="line">                <span class="keyword">await</span> switch.async_turn_on()        <span class="comment">#步骤1</span></span><br><span class="line">            <span class="keyword">elif</span> service.service == SERVICE_TOGGLE:</span><br><span class="line">                <span class="keyword">await</span> switch.async_toggle()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">await</span> switch.async_turn_off()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> switch.should_poll:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            update_tasks.append(switch.async_update_ha_state(<span class="literal">True</span>)) <span class="comment">#步骤4，后续会调用broadlink.py中update方法</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> update_tasks:</span><br><span class="line">            <span class="keyword">await</span> asyncio.wait(update_tasks, loop=hass.loop)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">    <span class="comment">#ha安装目录/homeassistant/components/switch/broadlink.py</span></span><br><span class="line">    <span class="comment">#BroadlinkRMSwitch类 部分代码</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">turn_on</span>(<span class="params">self, **kwargs</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Turn the device on.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self._sendpacket(self._command_on):      <span class="comment">#步骤2</span></span><br><span class="line">            self._state = <span class="literal">True</span>                      <span class="comment">#步骤3</span></span><br><span class="line">            self.schedule_update_ha_state()         <span class="comment">#步骤3</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">turn_off</span>(<span class="params">self, **kwargs</span>):</span>               <span class="comment">#流程同turn_on</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Turn the device off.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self._sendpacket(self._command_off): </span><br><span class="line">            self._state = <span class="literal">False</span>                    </span><br><span class="line">            self.schedule_update_ha_state()        </span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：async_update_ha_state(True)参数带true，会调用update方法（会与设备通信）去更新state。__<br>__INFO：HA某个版本（0.80.0左右吧）后，entity的service处理方法统一改用EntityComponent.async_register_entity_service()注册了，相关的service处理代码改到了helpers.service.py的_handle_service_platform_call()方法。不过总体处理逻辑没变，调用完entity相对应的service操作代码后，会根据entity的should_poll属性调用一次entity.async_update_ha_state(True)更新状态。</strong></p>
</blockquote>
<h3 id="2-2-解决方法"><a href="#2-2-解决方法" class="headerlink" title="2.2.解决方法"></a>2.2.解决方法</h3><p>去掉BroadlinkMP1Switch类中的@Throttle(TIME_BETWEEN_UPDATES)即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BroadlinkMP1Switch</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Representation of a Broadlink switch - To fetch states of all slots.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, device</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Initialize the switch.&quot;&quot;&quot;</span></span><br><span class="line">        self._device = device</span><br><span class="line">        self._states = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_outlet_status</span>(<span class="params">self, slot</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Get status of outlet from cached status list.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self._states[<span class="string">&#x27;s&#123;&#125;&#x27;</span>.format(slot)]</span><br><span class="line">    <span class="comment">#注释掉不生效</span></span><br><span class="line">    <span class="comment">#@Throttle(TIME_BETWEEN_UPDATES)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Fetch new state data for this device.&quot;&quot;&quot;</span></span><br><span class="line">        self._update()</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：Throttle的存在，限制update()更新频率为5s，造成2种情况下开关复位：1、执行一次开关操作5s内执行另外一次开关操作。2、HA的周期更新（会调用update（））后5s内，刚好执行开关操作。</strong><br>__INFO：去掉Throttle副作用就是一个周期内，每个slot更新都会调用1次update()，建议适当调大scan_interval周期。__</p>
</blockquote>
<p>***   </p>
<h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h2><ul>
<li>之前错误分析问题原因：由于步骤3、步骤4执行时间基本一致，导致步骤4去向插线板获取状态时，插线板返回的状态有一定的滞后性，HA获取仍然是旧状态，最后导致开关状态复原，要等待一个scan_interval更新周期状态才会重新同步。还是要对插座单片机的处理性能有信心。</li>
<li>一个插座有4个slot，组件会将每一个slot实例化一个switch。当switch更新状态会调用父设备（即BroadlinkMP1Switch）的update()方法，插件作者设置TIME_BETWEEN_UPDATES就是为了限制不必要的通信。</li>
<li>HA有周期性的更新platform里的entities功能，配置文件通过scan_interval设置更新时间。scan_interval默认是15s（entity_component.py中定义DEFAULT_SCAN_INTERVAL），switch类默认是30s（switch/__init__.py中定义）</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>Home Assistant</category>
      </categories>
      <tags>
        <tag>Home Assistant</tag>
        <tag>踩坑系列</tag>
      </tags>
  </entry>
  <entry>
    <title>【踩坑系列】Home Assistant使用Aqara空调伴侣（升级版）红外码异常</title>
    <url>/articles/stepping-on-the-pit-series-home-assistant-using-aqara-air-conditioning-partner-upgraded-version-infrared-code-is-abnormal/</url>
    <content><![CDATA[<blockquote>
<p>去年刚接触智能家居中枢系统domoticz，为了学习学习，买了个博联RM PRO。后来改用HA了，使用现成的组件顺利完成了接入，控灯、控风扇都OK。想着以后每个房间都要布设一个红外控制设备来执行自动化控制，经过了解，空调伴侣是一个不错的选择，最主要是省地方，不用拉多一个USB电源供电，于是入手了两个Aqara空调伴侣。接入HA使用发现了一个问题：可以学到红外码，但发送红外码总是没效果（即使用博联RM也学习不到红外码）。</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>看了调试信息没发现什么异常，而且通过app学习、使用红外码就正常。孤寂了一段时间，意外在domoticz论坛一个<a href="https://www.domoticz.cn/forum/viewtopic.php?f=28&t=115" title="小米空调伴侣接入">帖子</a>发现了<a href="https://github.com/aholstenson/miio/blob/master/docs/protocol.md" title="python-miio">抓包分析方法</a>，于是继续分析，算是找到了原因和临时解决办法。</p>
</blockquote>
<hr>
<h2 id="1-准备"><a href="#1-准备" class="headerlink" title="1.准备"></a>1.准备</h2><ul>
<li>Ubuntu 18.04 + HA 0.69.0</li>
<li>wiresharks</li>
<li><a href="https://github.com/mac-zhou/homeassistant-mi-acpartner" title="mac-zhou空调伴侣插件">空调伴侣组件</a><br>##</li>
</ul>
<hr>
<h2 id="2-过程"><a href="#2-过程" class="headerlink" title="2.过程"></a>2.过程</h2><h3 id="2-1-部署解析环境"><a href="#2-1-部署解析环境" class="headerlink" title="2.1.部署解析环境"></a>2.1.部署解析环境</h3><ul>
<li>安装nodejs和npm（<a href="https://blog.csdn.net/wangtaoking1/article/details/78005038" title="Ubuntu环境下安装nodejs和npm">参考教程</a>）</li>
<li>安装miio应用  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g miio</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>DEBUG：可以整个ubuntu的虚拟机，不影响生产系统</strong></p>
</blockquote>
</li>
</ul>
<h3 id="2-2-抓包"><a href="#2-2-抓包" class="headerlink" title="2.2.抓包"></a>2.2.抓包</h3><p>电脑装安卓模拟器登陆米家app，进入空调伴侣界面，随便选一个空调型号，然后断开外网环境，电脑启用wiresharks抓包</p>
<blockquote>
<p><strong>WARN：不断网好像是直接米家APP下发指令，不是用局域网通信协议通信</strong></p>
<p><strong>DEBUG：具体过程不详述，不懂可百度。另外，如果交换机支持做个镜像端口，抓包的电脑连镜像端口，手机用APP，也是可以的。</strong></p>
</blockquote>
<p>进行学习自定义红外码，发送，重复2-3次。</p>
<blockquote>
<p><strong>DEBUG：一次抓取过程不用抓太多操作，容易分析。</strong></p>
</blockquote>
<p>导出JSON文件（点击wireshare菜单栏-&gt;文件-&gt;导出分组解析结果-&gt;为JSON）。</p>
<blockquote>
<p><strong>INFO：wireshare可以先设置过滤条件udp.dstport == 54321 or udp.srcport == 54321，减少不必要的数据包；</strong></p>
</blockquote>
<h3 id="2-3-解析抓包"><a href="#2-3-解析抓包" class="headerlink" title="2.3.解析抓包"></a>2.3.解析抓包</h3><ul>
<li><p>将2.2步骤的JSON文件传到解析服务器</p>
</li>
<li><p>执行命令</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">miio protocol json-dump &#123;[file.json]&#125; --token &#123;[tokenAsHex]&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>DEBUG：{[file.json]}即JSON文件路径，{[tokenAsHex]}是空调伴侣的token</strong></p>
</blockquote>
</li>
<li><p>在输出找到”method”:”send_ir_code”，后面”params”里面FE开头的字符串就是发送红外码。（<a href="https://github.com/takatost/homebridge-mi-ac-partner/issues/5" title="抓包分析结果样例">抓包分析结果样例</a>）</p>
</li>
</ul>
<h3 id="2-4-红外码使用"><a href="#2-4-红外码使用" class="headerlink" title="2.4.红外码使用"></a>2.4.红外码使用</h3><p>将2.3步骤获取的红外码字符前面36位（后续叫附加信息头）记录下来。以后Aqara空调伴侣学习到新的红外码，将红外码的附加信息头替换成之前记录的，然后就可以发送成功了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#附加信息头样例</span></span><br><span class="line">学习：FE0000000000000000000000000600422268</span><br><span class="line">发送：FE04870000714594701FFF7fFF060042274e</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h2><ul>
<li>APP学习到红外码，发送给空调伴侣前会进行一些处理，处理后前36位会发生改变，但无法得知具体算法。而HA直接将学习到的红外码发送给空调伴侣，空调伴侣无法识别导致失败。</li>
<li>附加信息头有2个规律：只要保证[22:24]和[34:36]（十六进制）的差值一致，都可以用；[2:14]包含一些型号信息（对比通过get_model_and_state命令获取的信息）。</li>
</ul>
<hr>
<h2 id="4-更新"><a href="#4-更新" class="headerlink" title="4.更新"></a>4.更新</h2><p>后来在github反馈信息给了syssi大神，syssi大神拿出了信息附加头的处理算法，并更新了插件，有兴趣的朋友可以看<a href="https://github.com/syssi/xiaomi_airconditioningcompanion" title="空调伴侣插件">代码</a>里面的具体处理算法。</p>
<hr>
]]></content>
      <categories>
        <category>Home Assistant</category>
      </categories>
      <tags>
        <tag>Home Assistant</tag>
        <tag>Aqara</tag>
        <tag>踩坑系列</tag>
      </tags>
  </entry>
  <entry>
    <title>【踩坑系列】Home Assistant无法识别Aqara无线开关（贴墙式）</title>
    <url>/articles/stepping-on-the-pit-series-home-assistant-cannot-recognize-aqara-wireless-switch-wallmounted/</url>
    <content><![CDATA[<blockquote>
<p>想起上次做光感+人体感应自动控灯的时候，用aqara无线开关（贴墙式）控灯遇到个小坑：像zigbee墙壁开关，接入空调伴侣后，HA会实例化switch.wall_switch_xxxxxxxx，但没找到无线开关。于是又苦逼去读代码了，还算顺利解决，惯例把解决过程理一理做个总结分享下。</p>
</blockquote>
<hr>
<a id="more"></a>

<h2 id="1-环境"><a href="#1-环境" class="headerlink" title="1.环境"></a>1.环境</h2><ul>
<li>Ubuntu18.04 + HA 0.71.0</li>
<li>aqara空调伴侣升级版（网关）</li>
<li>aqara无线开关（贴墙式）<img src="/articles/stepping-on-the-pit-series-home-assistant-cannot-recognize-aqara-wireless-switch-wallmounted/1.png" class="" title="[aqara无线开关（贴墙式）]"></li>
<li>python模块目录，即/srv/homeassistant/homeassistant_venv/lib/python3.6/site-packages/,后面用{[python模块目录]}代替。</li>
</ul>
<hr>
<h2 id="2-过程"><a href="#2-过程" class="headerlink" title="2.过程"></a>2.过程</h2><h3 id="Step1"><a href="#Step1" class="headerlink" title="Step1"></a>Step1</h3><blockquote>
<p>首先查看看HA日志，发现有错误信息：</p>
<p>ERROR (SyncWorker_8) [xiaomi_gateway] Unsupported device found! Please create an issue at <a href="https://github.com/Danielhiversen/PyXiaomiGateway/issues">https://github.com/Danielhiversen/PyXiaomiGateway/issues</a> and provide the following data: {‘cmd’: ‘read_rsp’, ‘model’: ‘sensor_86sw1’,…… </p>
<p>明显是说不支持sensor_86sw1的类型，还注意信息中的“[xiaomi_gateway]”说明是xiaomi_gateway模块。找到{[python模块目录]}/xiaomi_gateway/<strong>init</strong>.py，可以看到支持的设备类型是在device_types = {}中定义的，我们把sensor_86sw1、sensor_86sw2（双键开关）加进去。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#……省略……#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaomiGateway</span>(<span class="params">object</span>):</span></span><br><span class="line"><span class="comment">#……省略……#</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_discover_devices</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="comment">#……省略……#</span></span><br><span class="line">        device_types = &#123;</span><br><span class="line">        <span class="string">&#x27;sensor&#x27;</span>: [<span class="string">&#x27;sensor_ht&#x27;</span>, <span class="string">&#x27;gateway&#x27;</span>, <span class="string">&#x27;gateway.v3&#x27;</span>, <span class="string">&#x27;weather&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;weather.v1&#x27;</span>, <span class="string">&#x27;sensor_motion.aq2&#x27;</span>, <span class="string">&#x27;acpartner.v3&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;binary_sensor&#x27;</span>: [<span class="string">&#x27;magnet&#x27;</span>, <span class="string">&#x27;sensor_magnet&#x27;</span>, <span class="string">&#x27;sensor_magnet.aq2&#x27;</span>,</span><br><span class="line">                            <span class="string">&#x27;motion&#x27;</span>, <span class="string">&#x27;sensor_motion&#x27;</span>, <span class="string">&#x27;sensor_motion.aq2&#x27;</span>,</span><br><span class="line">                            <span class="string">&#x27;switch&#x27;</span>, <span class="string">&#x27;sensor_switch&#x27;</span>, <span class="string">&#x27;sensor_switch.aq2&#x27;</span>, <span class="string">&#x27;sensor_switch.aq3&#x27;</span>,</span><br><span class="line">                            <span class="string">&#x27;86sw1&#x27;</span>, <span class="string">&#x27;sensor_86sw1.aq1&#x27;</span>, <span class="string">&#x27;sensor_86sw1&#x27;</span>,</span><br><span class="line">                            <span class="string">&#x27;86sw2&#x27;</span>, <span class="string">&#x27;sensor_86sw2.aq1&#x27;</span>, <span class="string">&#x27;sensor_86sw2&#x27;</span>,</span><br><span class="line">                            <span class="string">&#x27;cube&#x27;</span>, <span class="string">&#x27;sensor_cube&#x27;</span>, <span class="string">&#x27;sensor_cube.aqgl01&#x27;</span>,</span><br><span class="line">                            <span class="string">&#x27;smoke&#x27;</span>, <span class="string">&#x27;sensor_smoke&#x27;</span>,</span><br><span class="line">                            <span class="string">&#x27;natgas&#x27;</span>, <span class="string">&#x27;sensor_natgas&#x27;</span>,</span><br><span class="line">                            <span class="string">&#x27;sensor_wleak.aq1&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;switch&#x27;</span>: [<span class="string">&#x27;plug&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;ctrl_neutral1&#x27;</span>, <span class="string">&#x27;ctrl_neutral1.aq1&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;ctrl_neutral2&#x27;</span>, <span class="string">&#x27;ctrl_neutral2.aq1&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;ctrl_ln1&#x27;</span>, <span class="string">&#x27;ctrl_ln1.aq1&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;ctrl_ln2&#x27;</span>, <span class="string">&#x27;ctrl_ln2.aq1&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;86plug&#x27;</span>, <span class="string">&#x27;ctrl_86plug&#x27;</span>, <span class="string">&#x27;ctrl_86plug.aq1&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;light&#x27;</span>: [<span class="string">&#x27;gateway&#x27;</span>, <span class="string">&#x27;gateway.v3&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;cover&#x27;</span>: [<span class="string">&#x27;curtain&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;lock&#x27;</span>: [<span class="string">&#x27;lock.aq1&#x27;</span>]&#125;</span><br><span class="line"><span class="comment">#……省略……#</span></span><br></pre></td></tr></table></figure>

<h3 id="Step2"><a href="#Step2" class="headerlink" title="Step2"></a>Step2</h3><blockquote>
<p>xiaomi_gateway模块只是完成把设备信息和网关关联起来，正式的创建设备是在{[python模块目录]}/homeassistant/components/binary_sensor/xiaomi_aqara.py中实现的。所以打开看里面代码可以看到无线开关是在elif model in [‘86sw1’, ‘sensor_86sw1.aq1’]、elif model in [‘86sw2’, ‘sensor_86sw2.aq1’]里面的，确是没有“sensor_86sw1”，那继续添加。</p>
<p><strong>INFO：单键开关是实例化一个XiaomiButton的，双开关是实例化成三个XiaomiButton的（一个同时按双键触发）。</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#……省略……#</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setup_platform</span>(<span class="params">hass, config, add_devices, discovery_info=None</span>):</span></span><br><span class="line"><span class="comment">#……省略……#</span></span><br><span class="line">    <span class="keyword">if</span> model <span class="keyword">in</span> [<span class="string">&#x27;motion&#x27;</span>, <span class="string">&#x27;sensor_motion&#x27;</span>, <span class="string">&#x27;sensor_motion.aq2&#x27;</span>]:</span><br><span class="line">        <span class="comment">#……省略……#</span></span><br><span class="line">    <span class="keyword">elif</span> model <span class="keyword">in</span> [<span class="string">&#x27;86sw1&#x27;</span>, <span class="string">&#x27;sensor_86sw1.aq1&#x27;</span>, <span class="string">&#x27;sensor_86sw1&#x27;</span>]:</span><br><span class="line">        devices.append(XiaomiButton(device, <span class="string">&#x27;Wall Switch&#x27;</span>, <span class="string">&#x27;channel_0&#x27;</span>,</span><br><span class="line">                                        hass, gateway))</span><br><span class="line">    <span class="keyword">elif</span> model <span class="keyword">in</span> [<span class="string">&#x27;86sw2&#x27;</span>, <span class="string">&#x27;sensor_86sw2.aq1&#x27;</span>, <span class="string">&#x27;sensor_86sw1&#x27;</span>]:    </span><br><span class="line">        devices.append(XiaomiButton(device, <span class="string">&#x27;Wall Switch (Left)&#x27;</span>,    </span><br><span class="line">                                        <span class="string">&#x27;channel_0&#x27;</span>, hass, gateway))</span><br><span class="line">        devices.append(XiaomiButton(device, <span class="string">&#x27;Wall Switch (Right)&#x27;</span>,</span><br><span class="line">                                        <span class="string">&#x27;channel_1&#x27;</span>, hass, gateway))</span><br><span class="line">        devices.append(XiaomiButton(device, <span class="string">&#x27;Wall Switch (Both)&#x27;</span>,</span><br><span class="line">                                        <span class="string">&#x27;dual_channel&#x27;</span>, hass, gateway))</span><br><span class="line">    <span class="comment">#……省略……#</span></span><br></pre></td></tr></table></figure>
<h3 id="Step3"><a href="#Step3" class="headerlink" title="Step3"></a>Step3</h3><blockquote>
<p>重启，查看HA可以成功识别出无线开关了。</p>
<p>但又有新问题：点击按钮什么反应都没有，看回调方法中所执行的parse_data()，正常是会有click事件生成的。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#……省略……#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaomiButton</span>(<span class="params">XiaomiBinarySensor</span>):</span></span><br><span class="line"><span class="comment">#……省略……#</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_data</span>(<span class="params">self, data, raw_data</span>):</span></span><br><span class="line"><span class="comment">#……省略……#</span></span><br><span class="line">        self._hass.bus.fire(<span class="string">&#x27;click&#x27;</span>, &#123;</span><br><span class="line">            <span class="string">&#x27;entity_id&#x27;</span>: self.entity_id,</span><br><span class="line">            <span class="string">&#x27;click_type&#x27;</span>: click_type</span><br><span class="line">        &#125;)</span><br><span class="line"><span class="comment">#……省略……#</span></span><br></pre></td></tr></table></figure>
<h3 id="Step4"><a href="#Step4" class="headerlink" title="Step4"></a>Step4</h3><blockquote>
<p>看了下<a href="http://docs.opencloud.aqara.cn/development/gateway-LAN-communication/#86" title="aqara网关局域网通讯协议">aqara网关局域网通讯协议</a>发现，无线开关的click_type是button_0、button_1，而不是channel_0、channel_1。所以要把Step2的修改的代码恢复，重新新增sensor_86sw1、sensor_86sw2设备类型的处理代码。</p>
<p>重启测试，日志有EVENT消息，可以正常使用了。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">……省略……</span><br><span class="line"><span class="keyword">elif</span> model <span class="keyword">in</span> [<span class="string">&#x27;86sw1&#x27;</span>, <span class="string">&#x27;sensor_86sw1.aq1&#x27;</span>]:</span><br><span class="line">    devices.append(XiaomiButton(device, <span class="string">&#x27;Wall Switch&#x27;</span>, <span class="string">&#x27;channel_0&#x27;</span>,</span><br><span class="line">                                hass, gateway))</span><br><span class="line"><span class="keyword">elif</span> model <span class="keyword">in</span> [<span class="string">&#x27;sensor_86sw1&#x27;</span>]:     <span class="comment">#增加sensor_86sw1</span></span><br><span class="line">    devices.append(XiaomiButton(device, <span class="string">&#x27;Wall Switch&#x27;</span>, <span class="string">&#x27;button_0&#x27;</span>,</span><br><span class="line">                                hass, gateway))</span><br><span class="line"><span class="keyword">elif</span> model <span class="keyword">in</span> [<span class="string">&#x27;86sw2&#x27;</span>, <span class="string">&#x27;sensor_86sw2.aq1&#x27;</span>]:    </span><br><span class="line">    devices.append(XiaomiButton(device, <span class="string">&#x27;Wall Switch (Left)&#x27;</span>,</span><br><span class="line">                                <span class="string">&#x27;channel_0&#x27;</span>, hass, gateway))</span><br><span class="line">    devices.append(XiaomiButton(device, <span class="string">&#x27;Wall Switch (Right)&#x27;</span>,</span><br><span class="line">                                <span class="string">&#x27;channel_1&#x27;</span>, hass, gateway))</span><br><span class="line">    devices.append(XiaomiButton(device, <span class="string">&#x27;Wall Switch (Both)&#x27;</span>,</span><br><span class="line">                                <span class="string">&#x27;dual_channel&#x27;</span>, hass, gateway))</span><br><span class="line"><span class="keyword">elif</span> model <span class="keyword">in</span> [<span class="string">&#x27;sensor_86sw2&#x27;</span>]:     <span class="comment">#增加sensor_86sw2</span></span><br><span class="line">    devices.append(XiaomiButton(device, <span class="string">&#x27;Wall Switch (Left)&#x27;</span>,</span><br><span class="line">                                <span class="string">&#x27;button_0&#x27;</span>, hass, gateway))</span><br><span class="line">    devices.append(XiaomiButton(device, <span class="string">&#x27;Wall Switch (Right)&#x27;</span>,</span><br><span class="line">                                <span class="string">&#x27;button_1&#x27;</span>, hass, gateway))</span><br><span class="line">    devices.append(XiaomiButton(device, <span class="string">&#x27;Wall Switch (Both)&#x27;</span>,</span><br><span class="line">                                <span class="string">&#x27;dual_channel&#x27;</span>, hass, gateway))</span><br><span class="line">……省略……</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h2><p>最后简单介绍下我所理解的网关工作流程吧，相关的工作是由{[python模块目录]}/homeassistant/components/xiaomi_aqara.py来完成的。</p>
<p>1）读取配置文件xiaomi_aqara:的信息，初始化网关发现对象XiaomiGatewayDiscovery（{[python模块目录]}/xiaomi_gateway/<strong>init</strong>.py），注意HA也用了全局变量hass.data[PY_XIAOMI_GATEWAY]存储所找到的网关，后续注册设备会用到。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">xiaomi = hass.data[PY_XIAOMI_GATEWAY] = XiaomiGatewayDiscovery(</span><br><span class="line">    hass.add_job, gateways, interface)</span><br></pre></td></tr></table></figure>
<p>2）通过udp通信发现、注册网关，同时读取网关的设备列表。这时候，网关对象已经存有设备信息，供后续不同组件（component）注册设备使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">xiaomi.discover_gateways()</span><br></pre></td></tr></table></figure>
<p>3）监听udp通信端口，网关接收到数据包会调用push_data()进行解析，再根据数据包中设备sid调用相应设备所定义的push_data()实现对应设备的回调处理。设备的push_data()会再调用parse_data()（不同的设备会定义不同的方法）来更新数据、调用parse_voltage（通用）来更新电量，最后调用async_schedule_update_ha_state()更新状态。这部分是实现和设备的通信。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">xiaomi.listen()</span><br></pre></td></tr></table></figure>
<p>4）调用不同组件（component）的setup_platform注册设备。（好像是通过discovery.load_platform()触发EVENT_PLATFORM_DISCOVERED事件，后续HA自行处理，具体会处理我也没了解。）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> component <span class="keyword">in</span> [<span class="string">&#x27;binary_sensor&#x27;</span>, <span class="string">&#x27;sensor&#x27;</span>, <span class="string">&#x27;switch&#x27;</span>, <span class="string">&#x27;light&#x27;</span>, <span class="string">&#x27;cover&#x27;</span>, <span class="string">&#x27;lock&#x27;</span>]:</span><br><span class="line">    discovery.load_platform(hass, component, DOMAIN, &#123;&#125;, config) </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Home Assistant</category>
      </categories>
      <tags>
        <tag>Home Assistant</tag>
        <tag>Aqara</tag>
        <tag>踩坑系列</tag>
      </tags>
  </entry>
  <entry>
    <title>【踩坑系列】天猫精灵接入Home Assistant的网关服务没有实现OAuth访问控制</title>
    <url>/articles/stepping-on-the-pit-series-gateway-service-of-tmall-genie-accessing-home-assistant-does-not-implement-oauth-access-control/</url>
    <content><![CDATA[<blockquote>
<p>最近在研究天猫精灵接入，根据大神的指引天猫精灵接入HomeAssistant【智能家居技能接入，非webhook调用】，也可以顺利控制yeelight。但发现有一个问题，没有实现OAuth访问控制。即天猫精灵服务器使用获取的token来访问gate.php，OAuth服务器应该进行校验，校验通过后才执行来自天猫精灵服务器的请求。</p>
</blockquote>
<hr>
<a id="more"></a>
<h2 id="1-准备"><a href="#1-准备" class="headerlink" title="1.准备"></a>1.准备</h2><ul>
<li>[系列教程][1]</li>
</ul>
<h2 id="2-过程"><a href="#2-过程" class="headerlink" title="2.过程"></a>2.过程</h2><h3 id="2-1-校验功能"><a href="#2-1-校验功能" class="headerlink" title="2.1.校验功能"></a>2.1.校验功能</h3><p>1）根据oauth2-server-php<a href="http://bshaffer.github.io/oauth2-server-php-docs/cookbook/" title="oauth2-server-php Step-By-Step Walkthrough">官方教程</a>，应该增加如下的Resource Controller代码进行校验。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include our OAuth2 Serverobject</span></span><br><span class="line"><span class="keyword">require_once</span> <span class="keyword">__DIR__</span>.<span class="string">&#x27;/server.php&#x27;</span>;</span><br><span class="line"><span class="comment">// Handle a request to a resourceand authenticate the access token</span></span><br><span class="line"><span class="keyword">if</span> (!$server-&gt;verifyResourceRequest(OAuth2\Request::createFromGlobals())) &#123;</span><br><span class="line">    $server-&gt;getResponse()-&gt;send();</span><br><span class="line">    <span class="keyword">die</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> json_encode(<span class="keyword">array</span>(<span class="string">&#x27;success&#x27;</span>=&gt; <span class="literal">true</span>, <span class="string">&#x27;message&#x27;</span>=&gt; <span class="string">&#x27;You accessed myAPIs!&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p>2）但将代码加到gate.php头部，总是验证不通过，经过分析天猫精灵对接api以及研读OAuth2的代码发现了问题。</p>
<ul>
<li>天猫精灵服务器使用POST方式，以JSON格式（CONTENT_TYPE=’application/json’）传递数据，其中token值在$json-&gt;payload-&gt;accessToken</li>
<li>而OAuth服务器处理方式是：<ul>
<li>接收保存JSON数据，通过标识符’access_token’，即$json-&gt;access_token取的token值来判断是否授权
  </li>
<li>verifyResourceRequest()进行方法校验时，判断是POST请求方式的话，需要满足CONTENT_TYPE=’application/x-www-form-urlencoded’，否则判断失败</li>
</ul>
</li>
</ul>
<p>3）最终Resource Controller的代码调整如下（当然也可以修改oauth2-server-php相关的处理逻辑代码处理）：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">require_once</span> <span class="keyword">__DIR__</span>.<span class="string">&#x27;/server.php&#x27;</span>;</span><br><span class="line"><span class="comment">// Handle a request to a resource and authenticate the access token</span></span><br><span class="line">$request = OAuth2\Request::createFromGlobals();</span><br><span class="line">$response =<span class="keyword">new</span> OAuth2\Response();</span><br><span class="line">$poststr = file_get_contents(<span class="string">&quot;php://input&quot;</span>);  <span class="comment">//获取天猫精灵服务器请求内容</span></span><br><span class="line">$obj = json_decode($poststr); <span class="comment">//转换成json对象</span></span><br><span class="line">$request-&gt;request=array_merge(<span class="keyword">array</span>(<span class="string">&#x27;access_token&#x27;</span>=&gt;$obj-&gt;payload-&gt;accessToken),$request-&gt;request);  <span class="comment">//根据天猫精灵服务器请求的token值，在OAuth2的request-&gt;request对象重新构建一个access_token值</span></span><br><span class="line">$request-&gt;server[<span class="string">&#x27;CONTENT_TYPE&#x27;</span>]=<span class="string">&quot;application/x-www-form-urlencoded&quot;</span>; <span class="comment">//重新设置request-&gt;server的CONTENT_TYPE值为&#x27;application/x-www-form-urlencoded&#x27;</span></span><br><span class="line"><span class="keyword">if</span>(!$server-&gt;verifyResourceRequest($request,$response)) &#123;</span><br><span class="line">    $server-&gt;getResponse()-&gt;send();</span><br><span class="line">    <span class="keyword">die</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4）最后，在所有需要访问控制的页面开头的地方都应该加上如上代码即可，比如gate.php。</p>
<h3 id="2-2-token问题"><a href="#2-2-token问题" class="headerlink" title="2.2.token问题"></a>2.2.token问题</h3><p>修改server.php</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//server.php</span></span><br><span class="line">$server = <span class="keyword">new</span> OAuth2\Server($storage, <span class="keyword">array</span>(</span><br><span class="line">        <span class="string">&#x27;access_lifetime&#x27;</span>=&gt;<span class="number">86400</span>  <span class="comment">//token有效期，单位s</span></span><br><span class="line">        ));</span><br><span class="line"><span class="comment">//顺便先把允许刷新token的功能开启了</span></span><br><span class="line">$server-&gt;addGrantType(<span class="keyword">new</span> OAuth2\GrantType\RefreshToken($storage, <span class="keyword">array</span>(</span><br><span class="line">    <span class="string">&#x27;always_issue_new_refresh_token&#x27;</span> =&gt; <span class="literal">true</span></span><br><span class="line">    )));</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：天猫精灵服务器貌似在token过期后不会自动刷新（虽然api上说是有），过期需要重新在网页登陆授权，所以可以设置有效期长一点，默认的是3600s。</strong></p>
</blockquote>
<hr>
<p>[1]: </p>
]]></content>
      <categories>
        <category>Home Assistant</category>
      </categories>
      <tags>
        <tag>Home Assistant</tag>
        <tag>天猫精灵</tag>
        <tag>OAuth</tag>
      </tags>
  </entry>
  <entry>
    <title>为pfSense的DDNS增加腾讯云的实现</title>
    <url>/articles/add-tencent-cloud-implementation-to-pfsense-ddns/</url>
    <content><![CDATA[<p>前几天刚换了电信宽带，终于有了公网IP，摆脱了移动的大内网，打通家里网络的方案又多几种选择。以前用过花生壳之类的免费DDNS，是挺方便的，但得用服务商的二级域名，没自己的域名用起来自由。家里的路由用的pfSense有DDNS服务，但不支持腾讯云。想着pfSense是开源的，之前申请Let’s encrypt泛域名证书的时候又调试过腾讯云的API了，改造改造难度应该不大，虽然没研究过pfSense的代码，但还是有信心约估个半天可以完成的。于是乎开工：读代码、定位功能模块还算顺利，但调试还是掉坑了，为了把php的调试日志调出来昨晚研究到近2点，最后不得不放弃。今天早上单独调试好模块后，再三确认嵌入的代码，运行后还好能正常工作了，哪天有空再回头研究调试的事情吧。</p>
<hr>
<a id="more"></a>


<h2 id="1-准备"><a href="#1-准备" class="headerlink" title="1.准备"></a>1.准备</h2><p>1)工作流程分析</p>
<p>配置DDNS服务-&gt;pfSense监测WANIP变化-&gt;调用API修改”A”记录-&gt;最后通过域名解析服务器获取最新IP</p>
<p>2)需要改造内容</p>
<ul>
<li>前台的编辑页面：增加腾讯云类型的选项、显示相关的输入选项</li>
<li>后台的处理逻辑：增加腾讯云类型的处理分支、相关的更新记录方法</li>
</ul>
<p>3)复用之前的腾讯云云解析接口</p>
<p><a href="https://ljr.im/articles/lets-encrypt-wildcard-certificate-renewal-and-distribution/" title="Let&#39;s Encrypt通配符证书续期及分发">文章传送门</a>和<a href="https://github.com/cnk700i/blog-attachment/blob/master/certbot-dns-hook/certbot-dns-qcloud/qcloud.php" title="腾讯云云解析接口封装">QcloudDns类下载</a></p>
<h2 id="2-过程"><a href="#2-过程" class="headerlink" title="2.过程"></a>2.过程</h2><h3 id="2-1-前端页面"><a href="#2-1-前端页面" class="headerlink" title="2.1. 前端页面"></a>2.1. 前端页面</h3><ul>
<li>修改/usr/local/www/services_dyndns_edit.php  <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 增加qcloud类型客户端的需要显示的选项</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setVisible</span>(<span class="params">service</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (service) &#123;</span><br><span class="line">            <span class="comment"># ……省略……               </span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;qcloud&quot;</span>:</span><br><span class="line">                hideGroupInput(<span class="string">&#x27;domainname&#x27;</span>, <span class="literal">false</span>); <span class="comment"># 域名</span></span><br><span class="line">                hideInput(<span class="string">&#x27;resultmatch&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">                hideInput(<span class="string">&#x27;updateurl&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">                hideInput(<span class="string">&#x27;requestif&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">                hideCheckbox(<span class="string">&#x27;curl_ipresolve_v4&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">                hideCheckbox(<span class="string">&#x27;curl_ssl_verifypeer&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">                hideInput(<span class="string">&#x27;host&#x27;</span>, <span class="literal">false</span>); <span class="comment"># 主机名</span></span><br><span class="line">                hideInput(<span class="string">&#x27;mx&#x27;</span>, <span class="literal">false</span>); <span class="comment"># mx值</span></span><br><span class="line">                hideCheckbox(<span class="string">&#x27;wildcard&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">                hideCheckbox(<span class="string">&#x27;proxied&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">                hideInput(<span class="string">&#x27;zoneid&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">                hideInput(<span class="string">&#x27;ttl&#x27;</span>, <span class="literal">false</span>); <span class="comment"># ttl值</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment"># ……省略……</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：该功能函数作用是根据不同类型的客户端，在页面显示不同的配置选项。另外用户名、密码选项默认显示，不需要设置</strong></p>
</blockquote>
</li>
</ul>
<h3 id="2-2-后端处理"><a href="#2-2-后端处理" class="headerlink" title="2.2. 后端处理"></a>2.2. 后端处理</h3><ul>
<li><p>修改/etc/inc/services.inc</p>
  <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># DYNDNS_PROVIDER_VALUES、DYNDNS_PROVIDER_DESCRIPTIONS两个字符串常量的定义中，加入qcloud。注意要加入分隔符，并且保证位置序号一致。</span></span><br><span class="line"><span class="comment"># ……省略……</span></span><br><span class="line">define(<span class="string">&#x27;DYNDNS_PROVIDER_VALUES&#x27;</span>, <span class="string">&#x27;all-inkl azure azurev6 citynetwork cloudflare cloudflare-v6 cloudns custom custom-v6 digitalocean dnsexit dnsimple dnsmadeeasy dnsomatic dreamhost dreamhost-v6 duiadns duiadns-v6 dyndns dyndns-custom dyndns-static dyns easydns eurodns freedns freedns-v6 glesys godaddy godaddy-v6 googledomains gratisdns he-net he-net-v6 he-net-tunnelbroker hover loopia namecheap noip noip-free ods opendns ovh-dynhost qcloud route53 route53-v6 selfhost spdyn spdyn-v6 zoneedit&#x27;</span>);</span><br><span class="line">define(<span class="string">&#x27;DYNDNS_PROVIDER_DESCRIPTIONS&#x27;</span>, <span class="string">&#x27;All-Inkl.com,Azure DNS,Azure DNS (v6),City Network,Cloudflare,Cloudflare (v6),ClouDNS,Custom,Custom (v6),DigitalOcean,DNSexit,DNSimple,DNS Made Easy,DNS-O-Matic,DreamHost,Dreamhost (v6),DuiaDns.net,DuiaDns.net (v6),DynDNS (dynamic),DynDNS (custom),DynDNS (static),DyNS,easyDNS,Euro Dns,freeDNS,freeDNS (v6),GleSYS,GoDaddy,GoDaddy (v6),Google Domains,GratisDNS,HE.net,HE.net (v6),HE.net Tunnelbroker,Hover,Loopia,Namecheap,No-IP,No-IP (free),ODS.org,OpenDNS,OVH DynHOST,qcloud,Route 53,Route 53 (v6),SelfHost,SPDYN,SPDYN (v6),ZoneEdit&#x27;</span>);</span><br><span class="line"><span class="comment"># ……省略……</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：services_dyndns_edit.php页面的根据这两个常量生成的类型列表。</strong></p>
</blockquote>
</li>
<li><p>修改/etc/inc/dyndns.class</p>
  <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一个switch ($this-&gt;_dnsService)，在&#x27;azurev6&#x27;分支前加入&#x27;qcloud&#x27;分支</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updatedns</span></span>&#123;</span><br><span class="line">    <span class="comment"># ……省略……</span></span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">$this</span>-&gt;_dnsService)&#123;</span><br><span class="line">        <span class="comment"># ……省略……</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;qcloud&#x27;</span>: <span class="comment"># 增加这个即可，会执行$this-&gt;_update();</span></span><br><span class="line">        <span class="keyword">case</span>  <span class="string">&#x27;azurev6&#x27;</span>:</span><br><span class="line">            <span class="keyword">$this</span>-&gt;_update();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;_dnsDummyUpdateDone == <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// If a dummy update was needed, then sleep a while and do the update again to put the proper address back.</span></span><br><span class="line">                <span class="comment">// Some providers (e.g. No-IP free accounts) need to have at least 1 address change every month.</span></span><br><span class="line">                <span class="comment">// If the address has not changed recently, or the user did &quot;Force Update&quot;, then the code does</span></span><br><span class="line">                <span class="comment">// a dummy address change for providers like this.</span></span><br><span class="line">                sleep(<span class="number">10</span>);</span><br><span class="line">                <span class="keyword">$this</span>-&gt;_update();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment"># ……省略……</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># ……省略……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：该处判断服务并出发更新操作。</strong></p>
</blockquote>
</li>
</ul>
<pre><code><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"> <span class="comment"># 第二个switch ($this-&gt;_dnsService)，加入&#x27;qcloud&#x27;分支，位置在&#x27;default&#x27;之前即可。</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">_update</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="comment"># ……省略……</span></span><br><span class="line">     <span class="keyword">switch</span> (<span class="keyword">$this</span>-&gt;_dnsService)&#123;</span><br><span class="line">         <span class="comment"># ……省略……</span></span><br><span class="line">         <span class="keyword">case</span> <span class="string">&#x27;qcloud&#x27;</span>:</span><br><span class="line">             <span class="comment">/* tencent cloud dyndns */</span></span><br><span class="line">             $secretId = <span class="keyword">$this</span>-&gt;_dnsUser; <span class="comment">#</span></span><br><span class="line">             $secretKey = <span class="keyword">$this</span>-&gt;_dnsPass; <span class="comment">#</span></span><br><span class="line">             $domain = <span class="keyword">$this</span>-&gt;_dnsDomain; <span class="comment">#</span></span><br><span class="line">             $subDomain = <span class="keyword">$this</span>-&gt;_dnsHost; <span class="comment">#</span></span><br><span class="line">             $recordType = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">             $ip = <span class="keyword">$this</span>-&gt;_dnsIP;</span><br><span class="line">             $ttl = <span class="keyword">$this</span>-&gt;_dnsTTL;</span><br><span class="line">             $mx = <span class="keyword">$this</span>-&gt;_dnsMX;</span><br><span class="line">             $obj = <span class="keyword">new</span> QcloudDns($secretId, $secretKey);</span><br><span class="line">	$data = $obj-&gt;ListRecords($domain);</span><br><span class="line">	$is_newRecord = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span>($data[<span class="string">&quot;code&quot;</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">		$data = $data[<span class="string">&quot;data&quot;</span>][<span class="string">&quot;records&quot;</span>];</span><br><span class="line">		<span class="keyword">if</span> (is_array($data)) &#123;</span><br><span class="line">			<span class="keyword">foreach</span> ($data <span class="keyword">as</span> $v) &#123;</span><br><span class="line">				<span class="keyword">if</span> ($v[<span class="string">&quot;name&quot;</span>] == $subDomain) &#123;</span><br><span class="line">					$recordId = $v[<span class="string">&quot;id&quot;</span>];</span><br><span class="line">					$result = $obj-&gt;UpdateRecord($domain, $recordId, $subDomain, $recordType, $recordLine = <span class="string">&#x27;默认&#x27;</span>, $ip, $ttl = <span class="number">600</span>, $mx = <span class="number">0</span>);</span><br><span class="line">					$is_newRecord = <span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>($is_newRecord)&#123;</span><br><span class="line">				$result = $obj-&gt;CreateRecord($domain, $subDomain, $recordType, $recordLine = <span class="string">&#x27;默认&#x27;</span>, $ip, $ttl = <span class="number">600</span>, $mx = <span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">$this</span>-&gt;_checkStatus(<span class="number">0</span>, $result, <span class="literal">null</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">$this</span>-&gt;_checkStatus(<span class="number">0</span>, $data,<span class="literal">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment"># ……省略……</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment"># ……省略……</span></span><br></pre></td></tr></table></figure>
&gt; __INFO：该处实现获取腾讯云API配置信息、更新IP操作。__

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第三个switch ($this-&gt;_dnsService)，加入&#x27;qcloud&#x27;分支，位置在&#x27;default&#x27;之前即可。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_checkStatus</span>(<span class="params">$ch, $data, $header</span>) </span>&#123;</span><br><span class="line">    <span class="comment"># ……省略……</span></span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">$this</span>-&gt;_dnsService)&#123;</span><br><span class="line">        <span class="comment"># ……省略……</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;qcloud&#x27;</span>:</span><br><span class="line">        $data = json_encode($data);</span><br><span class="line">        <span class="keyword">if</span> (preg_match(<span class="string">&quot;/Success/i&quot;</span>, $data)) &#123;</span><br><span class="line">            $status = $status_intro . $success_str . gettext(<span class="string">&quot;IP Address Updated Successfully!&quot;</span>);</span><br><span class="line">            $successful_update = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $status = $status_intro . <span class="string">&quot;(&quot;</span> . gettext(<span class="string">&quot;Unknown Response&quot;</span>) . <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            log_error($status_intro . gettext(<span class="string">&quot;PAYLOAD:&quot;</span>) . <span class="string">&quot; &quot;</span> . $data);</span><br><span class="line">            <span class="keyword">$this</span>-&gt;_debug($data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment"># ……省略……</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># ……省略……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
&gt; __INFO：该处根据腾讯云返回的信息判断是否更新成功并输出日志。为了简单点，这里不对错误原因一一分析。__

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将所有的if($this-&gt;_dnsService != &#x27;ods&#x27;)判断语句，加入&#x27;qcloud&#x27;类型</span></span><br><span class="line"><span class="comment"># ……省略……</span></span><br><span class="line"><span class="keyword">if</span> (!in_array(<span class="keyword">$this</span>-&gt;_dnsService, <span class="keyword">array</span>(<span class="string">&#x27;ods&#x27;</span>,<span class="string">&#x27;qcloud&#x27;</span>)))&#123;</span><br><span class="line">    <span class="comment"># ……省略……</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># ……省略……</span></span><br></pre></td></tr></table></figure>
&gt; __INFO：原来代码&#39;ods&#39;类型的服务使用特殊的处理流程，跳过通用的curl构造处理流程。新加的&#39;qcloud&#39;直接使用QcloudDns类方法，也不需要用到原来的curl处理流程，所以也加进忽略列表。__

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 最后加入QcloudDns类定义代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QcloudDns</span> </span>&#123;</span><br><span class="line">    <span class="comment"># ……省略……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
&gt; __INFO：也可以做个文件引用。__</code></pre>
<hr>
<h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h2><ul>
<li>php的配置文件php.ini由/etc/rc.php_ini_setup脚本生成，每次重启会覆盖。</li>
<li>sshd的配置文件sshd_config由/etc/sshd脚本生成，每次重启会覆盖；secureCRT7版本不支持默认的钥匙交换协议，可以在配置文件增加旧方法，简单点就升级secureCRT版本。</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>pfSense</tag>
        <tag>DDNS</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始认识hexo</title>
    <url>/articles/meet-hexo-from-scratch/</url>
    <content><![CDATA[<blockquote>
<p>不知不觉建站一个多月了，趁着记忆还新鲜，把之前折腾的经历做个总结吧。不过，本文不准备介绍具体的配置以及主题美化（自己也不够专业），只是分享下自己对hexo的理解，希望能让初接触hexo的朋友能快速构建一个初步的概念。</p>
</blockquote>
<hr>
<a id="more"></a>
<h2 id="1-hexo是什么"><a href="#1-hexo是什么" class="headerlink" title="1.hexo是什么"></a>1.hexo是什么</h2><blockquote>
<p>引用官方文档：<br>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
</blockquote>
<p>重点是两个：</p>
<ol>
<li><p>Markdown</p>
<p> 就是需要以markdown格式写文章。</p>
</li>
<li><p>静态网页</p>
<p>博客的网页平常在服务器上就存在，浏览器请求就可以直接读取展示。</p>
</li>
</ol>
<hr>
<h2 id="2-hexo的安装"><a href="#2-hexo的安装" class="headerlink" title="2.hexo的安装"></a>2.hexo的安装</h2><blockquote>
<p>再引用官方文档：<br>npm install hexo-cli -g<br>hexo init blog<br>cd blog<br>npm install<br>hexo server</p>
</blockquote>
<ol>
<li><p>虽然官方命令这么少，实际上还要先安装Node.js环境（NPM是其中的包管理工具）。</p>
</li>
<li><p><code>npm install hexo-cli -g</code>，安装hexo cli插件，hexo的管理工具，<code>-g</code>参数代表全局安装。</p>
</li>
<li><p><code>hexo init blog</code>，会在当前目录下，创建<code>blog</code>目录，里面带有博客框架的基础配置信息</p>
</li>
<li><p><code>cd blog</code> <code>npm install</code>，根据blog\node_modules目录下配置信息安装插件</p>
</li>
<li><p><code>hexo server</code>，启动服务器，默认监听4000端口。当然，如果自己安装了apache2、nginx等服务器，也可以不使用自带的服务器程序。</p>
</li>
</ol>
<hr>
<h2 id="3-hexo的使用"><a href="#3-hexo的使用" class="headerlink" title="3.hexo的使用"></a>3.hexo的使用</h2><blockquote>
<p>继续引用官方文档，安装完毕目录内的结构为：<br>.<br>├── _config.yml<br>├── package.json<br>├── scaffolds<br>├── public<br>├── source<br>|   ├── _drafts<br>|   └── _posts<br>└── themes</p>
</blockquote>
<ol>
<li><p>_config.yml</p>
<p>网站的配置信息。</p>
</li>
<li><p>public</p>
<p>网站目录文件夹，经过渲染后的文章页面也存放与此。</p>
</li>
<li><p>source</p>
<p>用户资源文件夹，_posts是存放markdown格式的文章。其它放在这个目录里面的文件（除了_开头的文件），在渲染操作后，会被直接拷贝过去public。</p>
</li>
<li><p>themes</p>
<p>主题文件夹，进行渲染操作的时候，也要渲染对应主题的文件生成网站页面。</p>
</li>
</ol>
<p>所以hexo使用流程大概为：</p>
<ol>
<li>写好markdown文章，放到_posts文件夹。</li>
<li>在blog目录中，执行渲染命令<code>hexo g</code>。</li>
<li>渲染过程根据主题文件以及文章文件，生成相应的html页面。</li>
<li>浏览器访问html静态页面，浏览blog。</li>
</ol>
<hr>
<h2 id="4-hexo与github-coding"><a href="#4-hexo与github-coding" class="headerlink" title="4.hexo与github/coding"></a>4.hexo与github/coding</h2><p>百度hexo建站文章，可以发现总是与github、coding联系起来。自己一开始也对这个有点疑惑：为什么放到github、coding上就能访问了；我的网站文件直接公开到github、coding上会不会有安全问题，特别是我的blog文件夹有文章原稿。</p>
<ol>
<li>其实可以把github、coding看作成免费的服务器主机，你把网站静态页面文件上传上去，当然就能浏览访问了。只不过，github、coding同时把你的网站目录当成一个项目进行管理，用户可以也能像普通文件下载。</li>
<li>执行命令<code>hexo d</code>部署到github、coding的操作，只会将public目录里面的内容上传到github、coding。正因为是静态页面，代码也不含什么数据库连接、业务操作之类的逻辑。浏览器加载的内容，和在github、coding里直接浏览项目代码是一样的，就不涉及什么私隐数据问题了。</li>
<li>部署到github、coding的优点就是有免费稳定的服务器放自己的博客，要挑个缺点，也是你的项目如果是公开的话，人家可以直接下载你的网站目录，自己架服务器山寨你的博客（话说山寨有什么用）。PS：虽然coding可以免费设置项目私有，但静态网页爬虫抓取也是分分钟的事情。</li>
</ol>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>初试Zabbix监控方案</title>
    <url>/articles/initial-test-zabbix-monitoring-program/</url>
    <content><![CDATA[<p>因工作需要搜了一些监控解决方案，发现zabbix还是挺多人推荐的，于是乎记录一下学习过程。本篇主要是搭建好zabbix环境，然后使用agent采集主机数据、使用SNMP v3接入c2960采集数据。</p>
<hr>
<a id="more"></a>

<h2 id="0-环境"><a href="#0-环境" class="headerlink" title="0.环境"></a>0.环境</h2><ul>
<li>ubuntu 18.04</li>
<li>docker-ce 19.03.1</li>
<li>docker-compose 1.24.1</li>
<li>zabbix server 4.2.5</li>
<li>zabbix agent 1:4.2.5-1+bionic</li>
</ul>
<h2 id="1-安装zabbix"><a href="#1-安装zabbix" class="headerlink" title="1.安装zabbix"></a>1.安装zabbix</h2><h3 id="1-1-docker-compose编排容器"><a href="#1-1-docker-compose编排容器" class="headerlink" title="1.1.docker-compose编排容器"></a>1.1.docker-compose编排容器</h3><ul>
<li><p>创建docker-compose.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.5&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">x-logging:</span> <span class="comment"># 日志配置的模板</span></span><br><span class="line">  <span class="string">&amp;logging-setting-template</span></span><br><span class="line">  <span class="attr">logging:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">&#x27;json-file&#x27;</span> <span class="comment"># 将容器内的stdout、stderr输出记录为json格式文件</span></span><br><span class="line">    <span class="attr">options:</span></span><br><span class="line">      <span class="attr">max-size:</span> <span class="string">&#x27;30m&#x27;</span> <span class="comment"># 单个日志文件大小</span></span><br><span class="line">      <span class="attr">max-file:</span> <span class="string">&#x27;1&#x27;</span> <span class="comment"># 最大日志文件数量  </span></span><br><span class="line">      <span class="attr">tag:</span> <span class="string">&#x27;<span class="template-variable">&#123;&#123;.Name&#125;&#125;</span>&#x27;</span> <span class="comment"># 日志记录加上容器名称信息，如使用ELK收集分析日志能方便识别日志类源</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span> <span class="comment"># 定义网络，供services使用</span></span><br><span class="line">  <span class="attr">monitor-app:</span> <span class="comment"># 名称随意</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">&#x27;bridge&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span> <span class="comment"># 定义数据卷，供services使用</span></span><br><span class="line">  <span class="attr">mysql-data:</span> <span class="comment"># 名称随意</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span> <span class="comment"># 定义服务</span></span><br><span class="line">  <span class="attr">mysql:</span> <span class="comment"># mysql数据库</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">&#x27;mysql&#x27;</span> <span class="comment"># &gt;&gt;指定容器名称，否则默认&quot;&#123;&#123;yaml所在文件夹名&#125;&#125;_&#123;&#123;服务名称&#125;&#125;_1&quot;，PS：在根目录文件夹名为&quot;default&quot;</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&#x27;mysql&#x27;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;/data/mysql:/var/lib/mysql&#x27;</span> <span class="comment"># 使用数据卷保存容器数据，PS：此处用mysql-data数据卷zabbix会初始化会失败，原因不明</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">&#x27;--default-authentication-plugin=mysql_native_password&#x27;</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">&#x27;always&#x27;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">&#x27;password&#x27;</span> <span class="comment"># root用户密码</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;monitor-app&#x27;</span></span><br><span class="line">    <span class="string">&lt;&lt;:</span> <span class="string">*logging-setting-template</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">adminer:</span> <span class="comment"># mysql的web管理客户端</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">&#x27;adminer&#x27;</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&#x27;adminer&#x27;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;/etc/localtime:/etc/localtime:ro&#x27;</span> <span class="comment"># 同步容器时间</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">&#x27;always&#x27;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;monitor-app&#x27;</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;8080:8080&#x27;</span></span><br><span class="line">    <span class="string">&lt;&lt;:</span> <span class="string">*logging-setting-template</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">zabbix-server:</span> <span class="comment"># zabbix的后端</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">&#x27;zabbix-server&#x27;</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&#x27;zabbix/zabbix-server-mysql&#x27;</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">&#x27;always&#x27;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;/data/zabbix/externalscripts:/usr/lib/zabbix/externalscripts:ro&#x27;</span> <span class="comment"># 监控脚本目录</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;/data/zabbix/alertscripts:/usr/lib/zabbix/alertscripts:ro&#x27;</span> <span class="comment"># 告警脚本目录</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;mysql&#x27;</span> <span class="comment"># 在mysql服务后启动，填服务名</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">DB_SERVER_HOST:</span> <span class="string">&#x27;mysql&#x27;</span> <span class="comment"># &gt;&gt;与mysql服务的容器名对应</span></span><br><span class="line">      <span class="attr">MYSQL_USER:</span> <span class="string">&#x27;zabbix&#x27;</span> <span class="comment"># &gt;&gt;数据库用户名称，与创建的对应</span></span><br><span class="line">      <span class="attr">MYSQL_PASSWORD:</span> <span class="string">&#x27;zabbix&#x27;</span> <span class="comment"># &gt;&gt;数据库用户密码，与创建的对应</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">&#x27;zabbix&#x27;</span> <span class="comment"># &gt;&gt;数据库名称，与用户的权限对应</span></span><br><span class="line">      <span class="comment"># ZBX_CACHESIZE: &#x27;512M&#x27; # 一些缓存参数，具体含义自行了解</span></span><br><span class="line">      <span class="comment"># ZBX_HISTORYCACHESIZE: &#x27;1024M&#x27;</span></span><br><span class="line">      <span class="comment"># ZBX_HISTORYINDEXCACHESIZE: &#x27;256M&#x27;</span></span><br><span class="line">      <span class="comment"># ZBX_TRENDCACHESIZE: &#x27;256M&#x27;</span></span><br><span class="line">      <span class="comment"># ZBX_VALUECACHESIZE: &#x27;512M&#x27;</span></span><br><span class="line">      <span class="comment"># ZBX_STARTVMWARECOLLECTORS: 2</span></span><br><span class="line">      <span class="comment"># ZBX_VMWAREFREQUENCY: 60 # 带VMWARE是采集ESXI或vCenter的相关参数，具体含义自行了解</span></span><br><span class="line">      <span class="comment"># ZBX_VMWAREPERFFREQUENCY: 60</span></span><br><span class="line">      <span class="comment"># ZBX_VMWARECACHESIZE: &#x27;80M&#x27;</span></span><br><span class="line">      <span class="comment"># ZBX_VMWARETIMEOUT: 10</span></span><br><span class="line">      <span class="attr">PYTHONUNBUFFERED:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;monitor-app&#x27;</span></span><br><span class="line">    <span class="comment"># ports:</span></span><br><span class="line">    <span class="comment">#   - &#x27;10051:10051&#x27;</span></span><br><span class="line">    <span class="string">&lt;&lt;:</span> <span class="string">*logging-setting-template</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">zabbix-web:</span> <span class="comment"># zabbix的前端</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">&#x27;zabbix-web&#x27;</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&#x27;zabbix/zabbix-web-nginx-mysql&#x27;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;/data/zabbix/fonts:/usr/share/zabbix/assets/fonts:ro&#x27;</span>  <span class="comment"># 复制字体文件到/data/zabbix/fonts/DejaVuSans.ttf，解决中文乱码问题</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">&#x27;always&#x27;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;mysql&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;zabbix-server&#x27;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">DB_SERVER_HOST:</span> <span class="string">&#x27;mysql&#x27;</span> <span class="comment"># &gt;&gt;与mysql服务的容器名对应</span></span><br><span class="line">      <span class="attr">MYSQL_USER:</span> <span class="string">&#x27;zabbix&#x27;</span> <span class="comment"># &gt;&gt;数据库用户名称，与创建的对应</span></span><br><span class="line">      <span class="attr">MYSQL_PASSWORD:</span> <span class="string">&#x27;zabbix&#x27;</span> <span class="comment"># &gt;&gt;数据库用户密码，与创建的对应</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">&#x27;zabbix&#x27;</span> <span class="comment"># &gt;&gt;数据库名称，与用户的权限对应</span></span><br><span class="line">      <span class="attr">ZBX_SERVER_HOST:</span> <span class="string">&#x27;zabbix-server&#x27;</span> <span class="comment"># &gt;&gt;与zabbix-server服务的容器名对应</span></span><br><span class="line">      <span class="attr">PHP_TZ:</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;monitor-app&#x27;</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;80:80&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;433:433&#x27;</span></span><br><span class="line">    <span class="string">&lt;&lt;:</span> <span class="string">*logging-setting-template</span>  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：使用zabbix需要两个镜像，zabbix-server负责采集数据，zabbix-web负责管理、配置。</strong><br><strong>INFO：建议新建一个特定的目录放置yaml文件，以项目名命名目录。</strong></p>
</blockquote>
</li>
<li><p>启动容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 假设文件位于/home/docker/monitor/docker-compose.yaml</span></span><br><span class="line"><span class="built_in">cd</span> /home/docker/monitor/</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>WARN：首次初始化zabbix是启动不起来的，因为还没有数据库的相关权限。</strong><br><strong>INFO：如配置文件名不为docker-compose.yaml，可以使用-f参数指定。</strong></p>
</blockquote>
<h3 id="1-2-mysql配置"><a href="#1-2-mysql配置" class="headerlink" title="1.2.mysql配置"></a>1.2.mysql配置</h3></li>
<li><p>http://宿主机ip:8080，登录adminer</p>
 
  <img src="/articles/initial-test-zabbix-monitoring-program/c1.2_p1_%E7%99%BB%E5%BD%95adminer.png" class="" title="登录adminer">
</li>
<li><p>创建用户</p>
 
  <img src="/articles/initial-test-zabbix-monitoring-program/c1.2_p2_%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7.png" class="" title="创建用户">

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create user <span class="string">&#x27;zabbix&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified by <span class="string">&#x27;zabbix&#x27;</span>;</span><br><span class="line">grant all privileges on zabbix.* to <span class="string">&#x27;zabbix&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：此步骤可以跳过创建zabbix数据库，只授权即可，后续zabbix-server初始化会自行创建数据库以及建表。</strong></p>
</blockquote>
</li>
<li><p>更改root密码（根据需要）</p>
 
  <img src="/articles/initial-test-zabbix-monitoring-program/c1.2_p3_%E6%9B%B4%E6%94%B9mysql%20root%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81.png" class="" title="更改mysql root用户密码">

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alter user <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified by <span class="string">&#x27;newpassword&#x27;</span>;</span><br><span class="line">alter user <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified by <span class="string">&#x27;newpassword&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-zabbix配置"><a href="#1-3-zabbix配置" class="headerlink" title="1.3.zabbix配置"></a>1.3.zabbix配置</h3></li>
<li><p>重启zabbix服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose restart zabbix-server</span><br><span class="line">docker-compose restart zabbix-web</span><br></pre></td></tr></table></figure></li>
<li><p>访问http://宿主机ip，登录。默认用户密码为<code>Admin</code>:<code>zabbix</code></p>
 
  <img src="/articles/initial-test-zabbix-monitoring-program/c1.3_p1_zabbix%20web%E7%99%BB%E9%99%86%E9%A1%B5%E9%9D%A2.png" class="" title="zabbix web登陆页面">
</li>
<li><p>更改中文、修改密码</p>
 
  <img src="/articles/initial-test-zabbix-monitoring-program/c1.3_p2_%E6%9B%B4%E6%94%B9%E4%B8%AD%E6%96%87%E5%85%A5%E5%8F%A3.png" class="" title="更改中文入口">

 
  <img src="/articles/initial-test-zabbix-monitoring-program/c1.3_p2_%E6%9B%B4%E6%94%B9%E4%B8%AD%E6%96%87%E8%AE%BE%E7%BD%AE.png" class="" title="更改中文设置">

<h2 id="2-zabbix采集数据"><a href="#2-zabbix采集数据" class="headerlink" title="2.zabbix采集数据"></a>2.zabbix采集数据</h2><p>zabbix支持四大类接口采集数据：agent代理程序的接口、SNMP接口、JMX接口、IPMI接口，目前暂时只接触过前两种接入方式，接下来以实例简单介绍。</p>
</li>
</ul>
<h3 id="2-1-通过agent监控Linux-Win主机"><a href="#2-1-通过agent监控Linux-Win主机" class="headerlink" title="2.1.通过agent监控Linux/Win主机"></a>2.1.通过agent监控Linux/Win主机</h3><ul>
<li><p>安装agent，详见<a href="https://www.zabbix.com/documentation/4.0/zh/manual/installation/install_from_packages/debian_ubuntu" title="agent安装">官方教程</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加源</span></span><br><span class="line">wget https://repo.zabbix.com/zabbix/4.2/ubuntu/pool/main/z/zabbix-release/zabbix-release_4.2-2+bionic_all.deb</span><br><span class="line">dpkg -i zabbix-release_4.2-2+bionic_all.deb</span><br><span class="line">apt update</span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">apt install zabbix-agent</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置agent，agent有两种工作模式：主动模式和被动模式，主动模式是agent主动联系server上报数据，被动模式则agent启用监听等待server通信再提供数据。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置文件：/etc/zabbix/zabbix_agentd.conf</span></span><br><span class="line"><span class="comment"># ---被动模式设置---</span></span><br><span class="line"><span class="string">Server=&#123;&#123;zabbix</span> <span class="string">server</span> <span class="string">IP&#125;&#125;</span> <span class="comment"># 被动模式的zabbix server ip</span></span><br><span class="line"><span class="comment"># Hostname=zabbix server # 注释掉则默认系统主机名</span></span><br><span class="line"><span class="comment"># ---被动模式设置---</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---主动模式设置---</span></span><br><span class="line"><span class="comment"># Server=127.0.0.1 # 注释则禁用被动模式</span></span><br><span class="line"><span class="string">StartAgents=0</span> <span class="comment"># 禁用被动模式需要将监听进程设为0否则启动报错</span></span><br><span class="line"><span class="string">ServerActive=&#123;&#123;zabbix</span> <span class="string">server</span> <span class="string">IP&#125;&#125;</span> <span class="comment"># 主动模式的zabbix server ip</span></span><br><span class="line"><span class="comment"># Hostname=zabbix server # 注释掉则默认系统主机名</span></span><br><span class="line"><span class="comment"># RefreshActiveChecks=120 # 默认的上报间隔是120s，可自行设置</span></span><br><span class="line"><span class="comment"># ---主动模式设置---</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：可以同时启动被动模式以及主动模式，一般使用被动模式，zabbix自带模板也是被动模式。</strong></p>
</blockquote>
</li>
<li><p>启动agent</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">service zabbix-agent start</span><br><span class="line"><span class="comment"># 确认正常工作，PS：被动模式下会看到监听10050端口</span></span><br><span class="line">netstat -tulpn | grep zabbix_agent</span><br></pre></td></tr></table></figure>
</li>
<li><p>在zabbix server上创建监控主机</p>
 
  <img src="/articles/initial-test-zabbix-monitoring-program/c2.1_p1_%E6%96%B0%E5%BB%BA%E4%B8%BB%E6%9C%BA%E5%85%A5%E5%8F%A3.png" class="" title="新建主机入口">

 
  <img src="/articles/initial-test-zabbix-monitoring-program/c2.1_p1_%E4%B8%BB%E6%9C%BA%E5%9F%BA%E7%A1%80%E4%BF%A1%E6%81%AF%E8%AE%BE%E7%BD%AE.png" class="" title="主机基础信息设置">

 
  <img src="/articles/initial-test-zabbix-monitoring-program/c2.1_p2_%E4%B8%BB%E6%9C%BA%E6%A8%A1%E6%9D%BF%E8%AE%BE%E7%BD%AE.png" class="" title="主机模板设置">


</li>
</ul>
<blockquote>
<p><strong>INFO：这里接口配置使用了DNS名称，是因为测试环境下agent和server容器是在同一个docker网络，可通过容器名通信。</strong></p>
</blockquote>
<ul>
<li><p>过一会能看到数据了</p>
 
  <img src="/articles/initial-test-zabbix-monitoring-program/c2.1_p3_%E4%B8%BB%E6%9C%BA%E6%8E%A5%E5%85%A5%E6%88%90%E5%8A%9F%E6%95%B0%E6%8D%AE.png" class="" title="主机接入成功数据">

<h3 id="2-2-通过SNMP监控交换机"><a href="#2-2-通过SNMP监控交换机" class="headerlink" title="2.2.通过SNMP监控交换机"></a>2.2.通过SNMP监控交换机</h3></li>
<li><p>交换机启用SNMPv3</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C2960&gt; <span class="built_in">enable</span></span><br><span class="line">C2960<span class="comment"># configure terminal </span></span><br><span class="line">C2960(config)<span class="comment">#ip access-list standard ACL_demo</span></span><br><span class="line">C2960(config-std-nacl)<span class="comment">#permit host 128.8.39.121</span></span><br><span class="line">C2960(config-std-nacl)<span class="comment">#deny any log</span></span><br><span class="line">C2960(config-std-nacl)<span class="comment">#exit</span></span><br><span class="line">C2960(config)<span class="comment">#</span></span><br><span class="line">c2960(config)<span class="comment">#snmp-server view VIEW_demo mib-2 included</span></span><br><span class="line">c2960(config)<span class="comment">#snmp-server view VIEW_demo cisco included</span></span><br><span class="line">c2960(config)<span class="comment">#snmp-server view VIEW_demo snmpEngine included</span></span><br><span class="line">c2960(config)<span class="comment">#snmp-server group GROUP_demo v3 priv read VIEW_demo</span></span><br><span class="line">c2960(config)<span class="comment">#snmp-server user USER_demo GROUP_demo v3 auth sha PWD_auth priv aes 128 PWD_priv access ACL_demo</span></span><br><span class="line">(config)<span class="comment">#exit</span></span><br><span class="line">C2960<span class="comment">#copy running-config startup-config</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>准备模板，自带的模板只有SNMPv2的，不过官方的模板库有大神做了比较好用的<a href="https://share.zabbix.com/zabbix-tools-and-utilities/zabbix-template-for-lld-snmpv3-cisco-network-devices-switches-and-routers-with-authentication-and-aes-des-encryption" title="cisco snmpv3模板">模板</a></p>
</li>
<li><p>导入模板<br>解压得到Template SNMPv3 AES - EN.xml，在web页面进行上传即可。</p>
 
  <img src="/articles/initial-test-zabbix-monitoring-program/c2.2_p1_%E5%AF%BC%E5%85%A5%E6%A8%A1%E6%9D%BF%E5%85%A5%E5%8F%A3.png" class="" title="导入模板入口">

 
  <img src="/articles/initial-test-zabbix-monitoring-program/c2.2_p2_%E5%AF%BC%E5%85%A5%E6%A8%A1%E6%9D%BF.png" class="" title="导入模板">

 
  <img src="/articles/initial-test-zabbix-monitoring-program/c2.2_p3_%E6%A8%A1%E6%9D%BF%E5%AF%BC%E5%85%A5%E5%AE%8C%E6%AF%95.png" class="" title="模板导入完毕">
</li>
<li><p>导入脚本文件（模板中使用该脚本获取监控项数据）<br>解压getSnmpPrivAes_EN.sh，改名为getSnmpPrivAes.sh放置到宿主机的/data/zabbix/externalscripts/目录，执行<code>chmod 755 getSnmpPrivAes.sh</code>添加执行权限。</p>
</li>
</ul>
<blockquote>
<p><strong>INFO：docker-compose.yaml中对zabbix-server插件目录进行了映射，脚本文件放到宿主机即可使用。</strong></p>
</blockquote>
<ul>
<li>在zabbix server上创建监控主机 
  <img src="/articles/initial-test-zabbix-monitoring-program/c2.2_p4_%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9F%BA%E7%A1%80%E4%BF%A1%E6%81%AF%E8%AE%BE%E7%BD%AE.png" class="" title="交换机基础信息设置">

 
  <img src="/articles/initial-test-zabbix-monitoring-program/c2.2_p5_%E4%BA%A4%E6%8D%A2%E6%9C%BA%E6%A8%A1%E6%9D%BF%E8%AE%BE%E7%BD%AE.png" class="" title="交换机模板设置">

 
  <img src="/articles/initial-test-zabbix-monitoring-program/c2.2_p6_%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%AE%8F%E8%AE%BE%E7%BD%AE.png" class="" title="交换机宏设置">
</li>
<li>过一会能看到数据了 
  <img src="/articles/initial-test-zabbix-monitoring-program/c2.2_p7_%E4%BA%A4%E6%8D%A2%E6%9C%BA%E6%8E%A5%E5%85%A5%E6%88%90%E5%8A%9F%E6%95%B0%E6%8D%AE.png" class="" title="交换机接入成功数据">


</li>
</ul>
<blockquote>
<p><strong>INFO：需要定义交换机的SNMP信息。</strong></p>
</blockquote>
<h2 id="3-快速入门理解"><a href="#3-快速入门理解" class="headerlink" title="3.快速入门理解"></a>3.快速入门理解</h2><ul>
<li>自动发现<br>zabbix里面有两种自动发现：一种是在“配置-&gt;自动发现”设置，是用于生成主机清单的；一种是在“配置-&gt;主机-&gt;主机列表中点击一台主机进详情-&gt;自动发现规则”设置，用于生成该主机的监控项。</li>
<li>监控项<br>主机的特定监控指标，可以是文字比如交换机端口1的名称，也可以是数字比如CPU占用率。</li>
<li>应用集<br>定义监控项的类别。</li>
<li>触发器<br>为监控项设置一定规则，当符合条件比如内存使用率达到90，则生成告警。</li>
<li>图形<br>将监控项可视化展示。</li>
</ul>
<h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><ul>
<li>zabbix的界面不太友好，感觉信息量特别大，熟悉花了不少时间，上手还是要耐心。</li>
<li>自动发现规则很好用，不过涉及宏功能，还需要慢慢学习。</li>
<li>模板是一个核心功能，可以克隆系统自带模板根据实际情况调整，只需在主机重新关联新模板，就会整体更新监控项。</li>
</ul>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2>]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Appdaemon+Home Assistant的Sonoff basic开关刷Tasmota搭载光照度+红外传感器实现自动化控灯</title>
    <url>/articles/sonoff-basic-switch-brush-based-on-appdaemon-home-assistanttasmota-is-equipped-with-illuminance-infrared-sensor-to-realize-automatic-light-control/</url>
    <content><![CDATA[<blockquote>
<p>前不久逛瀚思彼岸<a href="https://bbs.hassbian.com/thread-2826-1-1.html" title="[修仙教程] Appdaemon实现空调伴侣的万能遥控功能">帖子</a>，被安利了Appdaemon。最近腾出时间痛着并快乐着看了几天官方的E文教程，然后想来实践下。于是翻出角落里N久前刷好了Tasmota固件然后吃灰的Sonoff、一时兴起买的光照度传感器和红外传感器，就决定做个简单的走廊灯自动控制吧。期间还是折腾了一番，感觉Tasmota还有Appdaemon还有太多的东西要学了，还是先写点东西作个总结吧。</p>
</blockquote>
<a id="more"></a>

<blockquote>
<p>本来只想简单附个Appdaemon代码算了，结果强迫症发作还是把整个流程都介绍了。所参考的教程都标注出来了，涉及的东西有点多，自行按需食用。</p>
</blockquote>
<hr>
<h2 id="0-说明"><a href="#0-说明" class="headerlink" title="0.说明"></a>0.说明</h2><blockquote>
<p><strong>INFO：代码中”{[中文]}”的内容需要自行确认进行替换。</strong></p>
<p><strong>DEBUG：因为实践时间跨度有点长，估计会有遗漏的地方，建议也观看参考教程。</strong></p>
<p><strong>PS：DEBUG、INFO、WARN代表提醒的重要程度。</strong></p>
</blockquote>
<h2 id="1-环境"><a href="#1-环境" class="headerlink" title="1.环境"></a>1.环境</h2><h3 id="1-1-硬件（买买买）"><a href="#1-1-硬件（买买买）" class="headerlink" title="1.1.硬件（买买买）"></a>1.1.硬件（买买买）</h3><ul>
<li>sonoff basic（淘宝28元左右那款）</li>
<li>BH1750光照度传感器（6元左右）</li>
<li>HC-SR501人体传感器（6元左右）</li>
<li>CH340G USB转TTL模块（8元左右）</li>
<li>杜邦线7条</li>
<li>排针（2.54MM间距，17MM长，买长点容易掰弯走线）</li>
<li>电烙铁+焊锡+松香</li>
</ul>
<h3 id="1-2-软件环境"><a href="#1-2-软件环境" class="headerlink" title="1.2.软件环境"></a>1.2.软件环境</h3><ul>
<li>Ubuntu 18.04（自行百度安装）</li>
<li>mosquitto 1.4.15（<a href="https://bbs.hassbian.com/thread-28-1-1.html" title="[进阶教程] Ubuntu安装Mosquitto也就是MQTT（无坑版）">安装参考教程</a>）</li>
<li>Homeassistant 0.71.0 （<a href="https://bbs.hassbian.com/thread-27-1-1.html" title="[基础教程] （20180630更新）Ubuntu安装HomeAssistant教程（ubuntu17.10无坑版）">安装参考教程</a>）</li>
<li>Docker 18.03.1-ce（<a href="https://ljr.im/articles/docker-installation-using-nodered-practice/" title="docker安装使用Node-RED实践">安装参考教程</a>）</li>
<li>Appdaemon 3.0.1</li>
</ul>
<h3 id="1-3-预期效果"><a href="#1-3-预期效果" class="headerlink" title="1.3.预期效果"></a>1.3.预期效果</h3><ul>
<li><p>光线暗并且感应到人，开灯</p>
</li>
<li><p>感应到没人，延时一段时间（自定义）后关灯</p>
<blockquote>
<p><strong>DEBUG：HC-SR501检测到人之后设置一个计时器，计时器结束后才输出低电平。期间检测到人活动，会重置计时器，所以关灯的时间是HC-SR501的计时器（可通过旋钮调）+自定义时间。</strong></p>
</blockquote>
</li>
<li><p>使用无线开关进行物理控制</p>
</li>
</ul>
<hr>
<h2 id="2-Sonoff"><a href="#2-Sonoff" class="headerlink" title="2.Sonoff"></a>2.Sonoff</h2><h3 id="Step1-刷固件"><a href="#Step1-刷固件" class="headerlink" title="Step1.刷固件"></a>Step1.刷固件</h3><p>先把排针焊接在中间的5个孔上</p>
<blockquote>
<p><strong>DEBUG：我买的两个模块焊盘都是堵上的，如果没有吸锡器（其实吸锡器没想象中好用），可以把排针拆成一个一个，加热锡盘时候把排针顶进去。</strong></p>
</blockquote>
<p>然后按<a href="https://bbs.hassbian.com/thread-419-1-1.html" title="[智能传感] Sonoff开关刷Tasmota基础教程（环境配置篇）">教程</a>刷好固件</p>
<blockquote>
<p><strong>WARN：com参数的Flash Mode:DIO要改成DOUT！</strong><br><strong>INFO：按住开关接电才能进入刷机模式。</strong></p>
</blockquote>
<h3 id="Step2-接线"><a href="#Step2-接线" class="headerlink" title="Step2.接线"></a>Step2.接线</h3><p>    光照传感器 &lt;–&gt; Sonoff<br>    VCC - 3.3V    <br>    SCL - GPIO 3    <br>    SDA - GPIO 1    <br>    GND - GND</p>
<p>    人体传感器 &lt;–&gt; Sonoff<br>    VCC - 3.3V    <br>    OUT - GPIO 14  <br>    GND - GND</p>
<blockquote>
<p>INFO：人体传感器一般供电是5V，可能是3.3V供电影响，距离旋钮不能调大，不然好像工作不正常，具体请自行测试。</p>
<p>DEBUG：两个传感器需要共用3.3V和GND供电，有美观强迫症的朋友可以把杜邦线的头抽出来（挑起条形的挡片就能抽出来了），然后把另一根线的头剪掉、剥线绕在前一根的金属头上，再放回去就好看了。</p>
</blockquote>
<h3 id="Step3-配置"><a href="#Step3-配置" class="headerlink" title="Step3.配置"></a>Step3.配置</h3><ul>
<li>设置时区  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#主页&gt;Console</span></span><br><span class="line">$ Timezone 8</span><br></pre></td></tr></table></figure></li>
<li>设置switch2的模式  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#主页&gt;Console</span></span><br><span class="line">$ SwitchMode2 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>DEBUG：默认工作模式是0，详细解释可见<a href="https://bbs.hassbian.com/thread-1358-1-1.html" title="[经验分享] Sonoff Tasmota 使用指南">帖子</a></p>
</blockquote>
</li>
<li>设置传感器上报间隔  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#主页&gt;Configuration&gt;Configure Logging</span></span><br><span class="line">配置Telemetry period，最小是10，一般60就可以</span><br></pre></td></tr></table></figure>
<blockquote>
<p>DEBUG：这个只影响照度的上传频率，因为代码可以通过http接口主动取数据，不用担心设置过大影响准确率
    </p>
</blockquote>
</li>
<li>设置mqtt  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#主页&gt;Configuration&gt;Configure MQTT</span></span><br><span class="line">按mosquitto的设置配置Host、Port、User、Password</span><br><span class="line"><span class="comment">#主页&gt;Configuration&gt;Configure Other</span></span><br><span class="line">勾上<span class="string">&quot;MQTT enable&quot;</span>选项</span><br></pre></td></tr></table></figure></li>
<li>设置数据端口（<a href="https://bbs.hassbian.com/thread-1120-1-1.html" title="[智能传感] Sonoff Tasmota接入温湿度+光照+人体传感器并支持物理开关控制">参考教程</a>）  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#主页&gt;Configuration&gt;Configure Module</span></span><br><span class="line"><span class="comment">#人体传感器数据</span></span><br><span class="line">GPIO 4：Relay2。</span><br><span class="line">GPIO 14：Switch2。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>DEBUG：原理应该是借助Relay的状态来间接传递人体传感器的输出（有人&gt;高电平&gt;Switch2接通&gt;Relay2接通&gt;MQTT传递状态）。</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 光照传感器数据</span></span><br><span class="line">GPIO 3：I2C SCL</span><br><span class="line">GPIO 1：I2C SDA</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<hr>
<h2 id="3-Homeassistant"><a href="#3-Homeassistant" class="headerlink" title="3.Homeassistant"></a>3.Homeassistant</h2><p>{[HA配置目录]}/Configuration.yaml下，增加一个sensor，用于接收光照度信息；增加一个binary_sensor，用于接收触发状态；增加一个mqtt，与mosquitto主机通信；增加一个light/switch，Sonoff控制的灯。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sensor:</span></span><br><span class="line">  <span class="string">-</span> <span class="attr">platform:</span> <span class="string">mqtt</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">illuminance_hallway</span></span><br><span class="line">    <span class="attr">state_topic:</span> <span class="string">&quot;tele/sonoff/SENSOR&quot;</span></span><br><span class="line">    <span class="attr">value_template:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; value_json[&#x27;BH1750&#x27;].Illuminance &#125;&#125;</span>&quot;</span></span><br><span class="line">    <span class="attr">unit_of_measurement:</span> <span class="string">&quot;lux&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">binary_sensor:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">platform:</span> <span class="string">mqtt</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">motion_hallway</span></span><br><span class="line">    <span class="attr">qos:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">state_topic:</span> <span class="string">&quot;stat/sonoff/POWER2&quot;</span></span><br><span class="line">    <span class="attr">payload_on:</span> <span class="string">&quot;ON&quot;</span></span><br><span class="line">    <span class="attr">payload_off:</span> <span class="string">&quot;OFF&quot;</span></span><br><span class="line">    <span class="attr">device_class:</span> <span class="string">motion</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mqtt:</span></span><br><span class="line">  <span class="comment"># MQTT Broker的IP地址或者域名</span></span><br><span class="line">  <span class="attr">broker:</span> &#123;[<span class="string">mosquitto主机的ip</span>]&#125;</span><br><span class="line">  <span class="comment"># MQTT Broker的端口号，缺省为1883</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">1883</span></span><br><span class="line">  <span class="comment"># 用户名</span></span><br><span class="line">  <span class="attr">username:</span> &#123;[<span class="string">自定义</span>]&#125;</span><br><span class="line">  <span class="comment"># 密码</span></span><br><span class="line">  <span class="attr">password:</span> &#123;[<span class="string">自定义</span>]&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="4-Appdaemon"><a href="#4-Appdaemon" class="headerlink" title="4.Appdaemon"></a>4.Appdaemon</h2><h3 id="4-1-安装"><a href="#4-1-安装" class="headerlink" title="4.1.安装"></a>4.1.安装</h3><p>安装好docker后，直接运行一条命令即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name=appdaemon -d -p 5050:5050 \</span><br><span class="line">--restart=always \</span><br><span class="line">-v &#123;[你的配置目录]&#125;:/conf \</span><br><span class="line">-v /etc/localtime:/etc/localtime \</span><br><span class="line">/appdaemon:latest</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：-v 是映射宿主的目录到docker实例中去，不用进docker实例去修改配置文件。</strong></p>
</blockquote>
<h3 id="4-2-配置"><a href="#4-2-配置" class="headerlink" title="4.2.配置"></a>4.2.配置</h3><ul>
<li><p>{[appdaemon配置目录]}/appdaemon.yaml</p>
  <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">secrets:</span> <span class="string">/conf/secrets.yaml</span></span><br><span class="line"><span class="attr">log:</span></span><br><span class="line">  <span class="attr">accessfile:</span> <span class="string">/conf/logs/access.log</span></span><br><span class="line">  <span class="attr">errorfile:</span> <span class="string">/conf/logs/error.log</span></span><br><span class="line">  <span class="attr">logfile:</span> <span class="string">/conf/logs/appdaemon.log</span></span><br><span class="line">  <span class="attr">log_generations:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">log_size:</span> <span class="number">1000000</span></span><br><span class="line"><span class="attr">appdaemon:</span></span><br><span class="line">  <span class="attr">threads:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">time_zone:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">  <span class="attr">api_port:</span> <span class="number">5000</span></span><br><span class="line">  <span class="attr">api_key:</span> &#123;[<span class="string">api访问密码，自定义</span>]&#125;</span><br><span class="line">  <span class="comment"># api_ssl_certificate: &lt;path/to/root/CA/cert&gt;</span></span><br><span class="line">  <span class="comment"># api_ssl_key: &lt;path/to/root/CA/key&gt;</span></span><br><span class="line">  <span class="attr">plugins:</span></span><br><span class="line">    <span class="attr">HASS:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">hass</span></span><br><span class="line">      <span class="attr">ha_url:</span> &#123;[<span class="string">ha的http地址</span>]&#125;</span><br><span class="line">      <span class="attr">ha_key:</span> &#123;[<span class="string">ha的密码</span>]&#125;</span><br><span class="line">      <span class="comment"># cert_path: &lt;path/to/root/CA/cert&gt;</span></span><br><span class="line">      <span class="comment"># cert_verify: True</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">hadashboard:</span></span><br><span class="line">  <span class="attr">dash_url:</span> <span class="string">http://&#123;[docker宿主ip]&#125;:5050</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>DEBUG：3.x版本相对2.x版本配置文件有了调整。</strong></p>
</blockquote>
</li>
<li><p>{[appdaemon配置目录]}/apps/motion_light.py</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> appdaemon.plugins.hass.hassapi <span class="keyword">as</span> hass</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MotionLights</span>(<span class="params">hass.Hass</span>):</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._resource=self.args[<span class="string">&quot;resource&quot;</span>]        <span class="comment">#Sonoff的http接口</span></span><br><span class="line">        self._delay=self.args[<span class="string">&quot;delay&quot;</span>]</span><br><span class="line">        self._light=self.args[<span class="string">&quot;light_id&quot;</span>]</span><br><span class="line">        self._illuminance=self.args[<span class="string">&quot;illuminance_id&quot;</span>]</span><br><span class="line">        self._motion_sensor=self.args[<span class="string">&quot;motion_sensor_id&quot;</span>]</span><br><span class="line">        self.listen_state(self.motion, self._motion_sensor, new = <span class="string">&quot;on&quot;</span>)</span><br><span class="line">        self.listen_state(self.no_motion, self._motion_sensor, new = <span class="string">&quot;off&quot;</span>)</span><br><span class="line">        self._last_motion_time=datetime.datetime.now()</span><br><span class="line">        self._last_no_motion_time=datetime.datetime.now()</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">motion</span>(<span class="params">self, entity, attribute, old, new, kwargs</span>):</span></span><br><span class="line">        self._last_motion_time=datetime.datetime.now()</span><br><span class="line">        res = requests.get(self._resource)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            illuminance=res.json()[<span class="string">&quot;StatusSNS&quot;</span>][<span class="string">&quot;BH1750&quot;</span>][<span class="string">&quot;Illuminance&quot;</span>]    <span class="comment">#通过Sonoff的http接口获取最新的照度数据</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            illuminance=self.get_state(self._illuminance)                   <span class="comment">#如果通过http获取失败，则取mqtt的数据</span></span><br><span class="line">        <span class="keyword">if</span> illuminance &lt; <span class="number">20</span> <span class="keyword">and</span> self.get_state(self._light) == <span class="string">&quot;off&quot;</span>:       <span class="comment">#亮度低于20并且灯处于关闭状态才执行</span></span><br><span class="line">            self.turn_on(self._light)   <span class="comment">#开灯</span></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">no_motion</span>(<span class="params">self, entity, attribute, old, new, kwargs</span>):</span></span><br><span class="line">        self._last_no_motion_time=datetime.datetime.now()</span><br><span class="line">        self.run_in(self.light_off,self._delay)         <span class="comment">#无人，经过设定的延时时间后执行关灯</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">light_off</span>(<span class="params">self, kwargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self._last_no_motion_time &gt; self._last_motion_time <span class="keyword">and</span> self.get_state(self._light) == <span class="string">&quot;on&quot;</span>:    <span class="comment">#无新触发情况（on-&gt;off后，在delay时间内发生off-&gt;on情况）并且灯处于开状态才执行</span></span><br><span class="line">            self.turn_off(self._light)  <span class="comment">#关灯</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>DEBUG：3.x版本相对2.x版本import的模块发生了变化。</strong></p>
</blockquote>
</li>
<li><p>{appdaemon配置目录}/apps/apps.yaml</p>
  <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">hallway_motion_light:</span></span><br><span class="line">  <span class="attr">module:</span> <span class="string">motion_light</span></span><br><span class="line">  <span class="attr">class:</span> <span class="string">MotionLights</span></span><br><span class="line">  <span class="attr">resource:</span> <span class="string">&quot;http://&#123;[Sonoff的IP]&#125;/cm?cmnd=Status 10&amp;user=admin&amp;password=[Sonoff设置的密码]&quot;</span>  <span class="comment">#http查询接口</span></span><br><span class="line">  <span class="attr">light_id:</span> <span class="string">light.hallway</span>                            <span class="comment">#所控制的灯,HA配置</span></span><br><span class="line">  <span class="attr">illuminance_id:</span> <span class="string">sensor.illuminance_hallway</span>         <span class="comment">#光照度传感器,HA配置</span></span><br><span class="line">  <span class="attr">motion_sensor_id:</span> <span class="string">binary_sensor.motion_hallway</span>     <span class="comment">#移动传感器,HA配置</span></span><br><span class="line">  <span class="attr">delay:</span> <span class="number">10</span>                                          <span class="comment">#无感应后延时关灯时间(s)</span></span><br><span class="line"><span class="attr">hallway_switch:</span></span><br><span class="line">  <span class="attr">module:</span> <span class="string">aqara_switch</span></span><br><span class="line">  <span class="attr">class:</span> <span class="string">Switchs</span></span><br><span class="line">  <span class="attr">switch_id:</span> <span class="string">binary_sensor.wall_switch_xxxxxxxxxxxx_2</span>           <span class="comment">#无线开关id,我用的是aqara墙壁开关</span></span><br><span class="line">  <span class="attr">target_device:</span> <span class="string">light.hallway</span>                                  <span class="comment">#所控制的灯,HA配置</span></span><br><span class="line">  <span class="attr">click_type:</span> <span class="string">single</span>                                            <span class="comment">#按键类型</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>DEBUG：resource是Sonoff的http获取光照度的接口，如果Sonoff没有设置密码去掉”&amp;user=admin&amp;password=[Sonoff设置的密码]”即可。</strong></p>
</blockquote>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>Home Assistant</category>
      </categories>
      <tags>
        <tag>Home Assistant</tag>
        <tag>Appdaemon</tag>
        <tag>Sonoff</tag>
      </tags>
  </entry>
  <entry>
    <title>智障家居初战-对接篇</title>
    <url>/articles/intellectually-impaired-home-battlematching/</url>
    <content><![CDATA[<p>本篇主要讲解与天猫精灵服务器的认证对接：将会在VPS上安装nginx做反向代理，并申请SSL证书以便启用https功能；同时，在本地服务器上部署oauth认证服务，满足与天猫精灵服务器对接的认证需要。</p>
<hr>
<a id="more"></a>
<img src="/articles/intellectually-impaired-home-battlematching/1.png" class="">
<h2 id="1-VPS部分"><a href="#1-VPS部分" class="headerlink" title="1.VPS部分"></a>1.VPS部分</h2><h3 id="1-1nginx反向代理"><a href="#1-1nginx反向代理" class="headerlink" title="1.1nginx反向代理"></a>1.1nginx反向代理</h3><p>①安装nginx</p>
<p>1）<code>#apt-get install nginx</code></p>
<p>会有提示是否安装，按y继续即可</p>
<img src="/articles/intellectually-impaired-home-battlematching/2.png" class="">

<p>2）在浏览器测试一下访问域名或者IP，看到这个界面已经正常安装</p>
<img src="/articles/intellectually-impaired-home-battlematching/3.png" class="">

<p>3）<code>#vi /etc/nginx/sites-enabled/default</code><br>编辑配置文件</p>
<img src="/articles/intellectually-impaired-home-battlematching/4.png" class="">

<p>4）代理https访问家用服务器<br>配置文件末位加入，依然注意修改对应的域名以及IP</p>
<img src="/articles/intellectually-impaired-home-battlematching/5.png" class="">

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">server</span> &#123;</span><br><span class="line">        <span class="string">listen</span> <span class="number">443</span><span class="string">;</span></span><br><span class="line">        <span class="string">server_name</span> <span class="string">www.example.com;</span> <span class="comment">#填写绑定证书的域名</span></span><br><span class="line">        <span class="string">ssl</span> <span class="string">on;</span></span><br><span class="line">        <span class="string">ssl_certificate</span> <span class="string">/etc/letsencrypt/live/example.com/fullchain.pem;</span></span><br><span class="line">        <span class="string">ssl_certificate_key</span> <span class="string">/etc/letsencrypt/live/example.com/privkey.pem;</span></span><br><span class="line">        <span class="string">ssl_session_timeout</span> <span class="string">5m;</span></span><br><span class="line">        <span class="string">ssl_protocols</span> <span class="string">TLSv1</span> <span class="string">TLSv1.1</span> <span class="string">TLSv1.2;</span> <span class="comment">#按照这个协议配置</span></span><br><span class="line">        <span class="string">ssl_ciphers</span> <span class="string">ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置</span></span><br><span class="line">        <span class="string">ssl_prefer_server_ciphers</span> <span class="string">on;</span></span><br><span class="line"> <span class="string">location</span> <span class="string">/</span> &#123;</span><br><span class="line">        <span class="string">proxy_pass</span>  <span class="string">https://10.8.0.2;</span></span><br><span class="line">        <span class="string">proxy_set_header</span> <span class="string">Host</span>      <span class="string">$host;</span></span><br><span class="line">        <span class="string">proxy_set_header</span> <span class="string">X-Real-IP</span> <span class="string">$remote_addr;</span></span><br><span class="line">        <span class="string">proxy_redirect</span> <span class="string">http://</span> <span class="string">$scheme://;</span> <span class="comment">#做https跳转</span></span><br><span class="line">        <span class="string">proxy_set_header</span> <span class="string">X-Forwarded-For</span> <span class="string">$proxy_add_x_forwarded_for;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5）代理http访问家用服务器（可省略）</p>
<p>如果想做80的代理，可以如下进行设置。配置文件已经有80 http服务器的设置了，修改server _name、location的内容。</p>
<p>i修改前</p>
<img src="/articles/intellectually-impaired-home-battlematching/6.png" class="">

<p>ii修改后</p>
<img src="/articles/intellectually-impaired-home-battlematching/7.png" class="">

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">server</span> &#123;</span><br><span class="line">        <span class="string">listen</span> <span class="number">80</span> <span class="string">default_server;</span></span><br><span class="line">        <span class="string">listen</span> [<span class="string">::</span>]<span class="string">:80</span> <span class="string">default_server;</span></span><br><span class="line">        <span class="string">root</span> <span class="string">/var/www/html;</span></span><br><span class="line">        <span class="string">server_name</span> <span class="string">www.example.com;</span></span><br><span class="line">        <span class="string">location</span> <span class="string">/</span> &#123;</span><br><span class="line">                <span class="comment"># First attempt to serve request as file, then</span></span><br><span class="line">                <span class="comment"># as directory, then fall back to displaying a 404.</span></span><br><span class="line">                <span class="string">proxy_pass</span> <span class="string">http://10.8.0.2;</span></span><br><span class="line">                <span class="string">proxy_redirect</span> <span class="string">off;</span></span><br><span class="line">                <span class="string">proxy_set_header</span> <span class="string">X-Real-IP</span> <span class="string">$remote_addr;</span></span><br><span class="line">                <span class="string">proxy_set_header</span> <span class="string">X-Forwarded-For</span> <span class="string">$proxy_add_x_forwarded_for;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-申请SSL证书"><a href="#1-2-申请SSL证书" class="headerlink" title="1.2.申请SSL证书"></a>1.2.申请SSL证书</h3><p>我们申请Let’s Encrypt的SSL证书，有自动化申请脚本，虽然有效期只有90天，不过到期我们再执行一下一次脚本就行了。</p>
<p>1）<code>#git clone https://github.com/letsencrypt/letsencrypt</code><br>下载</p>
<img src="/articles/intellectually-impaired-home-battlematching/8.png" class="">

<blockquote>
<p>Tips：要注意一下当前的安装目录，#pwd可以查看，后续还需要到该目录执行一遍命令来给证书延期</p>
</blockquote>
<p>2）<code>#cd cd letsencrypt</code></p>
<p>进入letsencrpt目录</p>
<p>3）<code>#./letsencrypt-auto -d example.com -d www.example.com</code></p>
<p>example.com换成你自己的域名</p>
<img src="/articles/intellectually-impaired-home-battlematching/9.png" class="">

<p>4）脚本执行完后，会在/etc/letsencrypt/live/目录下生成一个example.com命名的目录，里面有相应的证书文件了</p>
<img src="/articles/intellectually-impaired-home-battlematching/10.png" class="">

<blockquote>
<p>Tips：注意检查证书的目录是否与配置enginx设置的证书目录一致</p>
</blockquote>
<p>5）<code>#/etc/init.d/nginx reload</code><br>重启nginx，正常运行如下</p>
<img src="/articles/intellectually-impaired-home-battlematching/11.png" class="">

<blockquote>
<p>Tips：如有错误提示可以#tail /var/log/syslog查看系统日志看错误原因</p>
</blockquote>
<h2 id="2-家用服务器"><a href="#2-家用服务器" class="headerlink" title="2.家用服务器"></a>2.家用服务器</h2><h3 id="2-1-启用https"><a href="#2-1-启用https" class="headerlink" title="2.1.启用https"></a>2.1.启用https</h3><p>1）<code>#a2enmod ssl</code></p>
<p>启用apache2的ssl配置</p>
<img src="/articles/intellectually-impaired-home-battlematching/12.png" class="">

<blockquote>
<p>Tips:这条命令相当于<br><code>sudo ln -s /etc/apache2/mods-available/ssl.load /etc/apache2/mods-enabled</code><br><code>sudo ln -s /etc/apache2/mods-available/ssl.conf /etc/apache2/mods-enabled</code></p>
</blockquote>
<p>2）<code>#ln -s /etc/apache2/sites-available/default-ssl.conf /etc/apache2/sites-enabled</code></p>
<p>加入ssl站点的配置</p>
<img src="/articles/intellectually-impaired-home-battlematching/13.png" class="">

<blockquote>
<p>Tips：Ubuntu安装LAMP套件，apache2已自带证书了，default-ssl.conf里面也设置好，直接就可以使用。也可以自己用openssl重新生成自签证书，在default-ssl.conf设置新生成的证书。</p>
</blockquote>
<p>3）<code>#service apache2 restart</code></p>
<p>重启生效。</p>
<img src="/articles/intellectually-impaired-home-battlematching/14.png" class="">

<p>4）这时，在浏览器使用<a href="https://www.你的域名/">https://www.你的域名</a> 进行访问，可以看到apache2的页面，说明已经成功访问到家用服务器了。</p>
<img src="/articles/intellectually-impaired-home-battlematching/15.png" class="">

<h3 id="2-2-oauth认证服服务"><a href="#2-2-oauth认证服服务" class="headerlink" title="2.2.oauth认证服服务"></a>2.2.oauth认证服服务</h3><p>oauth认证流程如下，我们将会使用三个php来实现相关功能：server.php（oauth服务器配置，为后面两个php提供环境）、authorize.php（认证页面，A、B、C步骤）、token.php（认证client，生成toke，D步骤n）。</p>
<img src="/articles/intellectually-impaired-home-battlematching/16.png" class="">

<p>①下载oauth2<br>1）<code>#cd /var/www</code></p>
<p>准备把oauth2安装到该目录</p>
<img src="/articles/intellectually-impaired-home-battlematching/17.png" class="">

<blockquote>
<p>Tips：看别的教程是放在/var/www/html，该目录外部可以访问，感觉会有风险</p>
</blockquote>
<p>2）<code>#git clone https://github.com/bshaffer/oauth2-server-php.git -b master</code></p>
<p>下载oauth2基础环境包</p>
<img src="/articles/intellectually-impaired-home-battlematching/18.png" class="">

<p>②配置数据库</p>
<p>1）<code>#mysql -u root -p</code></p>
<p>会要求输入密码，这个是在安装Ubuntu时候有要求设置的</p>
<img src="/articles/intellectually-impaired-home-battlematching/19.png" class="">

<p>2）<code>&gt;create database oauth;</code></p>
<p>创建一个名为oauth的数据库</p>
<img src="/articles/intellectually-impaired-home-battlematching/20.png" class="">

<p>3）<code>&gt;use oauth;</code></p>
<p>进入数据库</p>
<img src="/articles/intellectually-impaired-home-battlematching/21.png" class="">

<p>4）建表，直接复制运行以下代码即可。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> oauth_clients (</span><br><span class="line">  client_id             <span class="built_in">VARCHAR</span>(<span class="number">80</span>)   <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  client_secret         <span class="built_in">VARCHAR</span>(<span class="number">80</span>),</span><br><span class="line">  redirect_uri          <span class="built_in">VARCHAR</span>(<span class="number">2000</span>),</span><br><span class="line">  grant_types           <span class="built_in">VARCHAR</span>(<span class="number">80</span>),</span><br><span class="line">  <span class="keyword">scope</span>                 <span class="built_in">VARCHAR</span>(<span class="number">4000</span>),</span><br><span class="line">  user_id               <span class="built_in">VARCHAR</span>(<span class="number">80</span>),</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (client_id)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> oauth_access_tokens (</span><br><span class="line">  access_token         <span class="built_in">VARCHAR</span>(<span class="number">40</span>)    <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  client_id            <span class="built_in">VARCHAR</span>(<span class="number">80</span>)    <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  user_id              <span class="built_in">VARCHAR</span>(<span class="number">80</span>),</span><br><span class="line">  expires              <span class="built_in">TIMESTAMP</span>      <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="keyword">scope</span>                <span class="built_in">VARCHAR</span>(<span class="number">4000</span>),</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (access_token)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> oauth_authorization_codes (</span><br><span class="line">  authorization_code  <span class="built_in">VARCHAR</span>(<span class="number">40</span>)     <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  client_id           <span class="built_in">VARCHAR</span>(<span class="number">80</span>)     <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  user_id             <span class="built_in">VARCHAR</span>(<span class="number">80</span>),</span><br><span class="line">  redirect_uri        <span class="built_in">VARCHAR</span>(<span class="number">2000</span>),</span><br><span class="line">  expires             <span class="built_in">TIMESTAMP</span>       <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="keyword">scope</span>               <span class="built_in">VARCHAR</span>(<span class="number">4000</span>),</span><br><span class="line">  id_token            <span class="built_in">VARCHAR</span>(<span class="number">1000</span>),</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (authorization_code)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> oauth_refresh_tokens (</span><br><span class="line">  refresh_token       <span class="built_in">VARCHAR</span>(<span class="number">40</span>)     <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  client_id           <span class="built_in">VARCHAR</span>(<span class="number">80</span>)     <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  user_id             <span class="built_in">VARCHAR</span>(<span class="number">80</span>),</span><br><span class="line">  expires             <span class="built_in">TIMESTAMP</span>       <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="keyword">scope</span>               <span class="built_in">VARCHAR</span>(<span class="number">4000</span>),</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (refresh_token)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> oauth_users (</span><br><span class="line">  username            <span class="built_in">VARCHAR</span>(<span class="number">80</span>),</span><br><span class="line">  <span class="keyword">password</span>            <span class="built_in">VARCHAR</span>(<span class="number">80</span>),</span><br><span class="line">  first_name          <span class="built_in">VARCHAR</span>(<span class="number">80</span>),</span><br><span class="line">  last_name           <span class="built_in">VARCHAR</span>(<span class="number">80</span>),</span><br><span class="line">  email               <span class="built_in">VARCHAR</span>(<span class="number">80</span>),</span><br><span class="line">  email_verified      <span class="built_in">BOOLEAN</span>,</span><br><span class="line">  <span class="keyword">scope</span>               <span class="built_in">VARCHAR</span>(<span class="number">4000</span>),</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (username)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> oauth_scopes (</span><br><span class="line">  <span class="keyword">scope</span>               <span class="built_in">VARCHAR</span>(<span class="number">80</span>)     <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  is_default          <span class="built_in">BOOLEAN</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="keyword">scope</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> oauth_jwt (</span><br><span class="line">  client_id           <span class="built_in">VARCHAR</span>(<span class="number">80</span>)     <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  subject             <span class="built_in">VARCHAR</span>(<span class="number">80</span>),</span><br><span class="line">  public_key          <span class="built_in">VARCHAR</span>(<span class="number">2000</span>)   <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>5）<code>&gt;show tables;</code></p>
<p>检查一下是否成功建表</p>
<img src="/articles/intellectually-impaired-home-battlematching/22.png" class="">

<p>6）<code>&gt;INSERT INTO oauth_clients (client_id, client_secret, redirect_uri) VALUES(&quot;smzdm&quot;,&quot;smzdm&quot;,&quot;https://open.bot.tmall.com/oauth/callback&quot;);</code></p>
<p>插入一条认证客户端需记录，我这id和密码都是smzdm。记住这个，迟点会在天猫精灵开发者平台进行配置。</p>
<img src="/articles/intellectually-impaired-home-battlematching/23.png" class="">

<p>6）<code>&gt;grant all on oauth.* to &#39;oauth&#39;@&#39;localhost&#39; identified by &#39;password&#39;;</code></p>
<p>创建一个oauth的用户，可以使用oauth数据库，本地登陆使用</p>
<img src="/articles/intellectually-impaired-home-battlematching/24.png" class="">

<p>7）<code>&gt;flush privileges;</code></p>
<p>使用户生效</p>
<img src="/articles/intellectually-impaired-home-battlematching/25.png" class="">

<p>8）<code>&gt;exit</code></p>
<p>退出mysql</p>
<img src="/articles/intellectually-impaired-home-battlematching/26.png" class="">

<p>③新建php页面</p>
<p>1）<code>#cd /var/www/html</code></p>
<p>进入网站根目录</p>
<img src="/articles/intellectually-impaired-home-battlematching/27.png" class="">

<p>2）<code>#vi server.php</code></p>
<p>内容复制相应附件的内容即可，红圈地方是可能变化的地方</p>
<img src="/articles/intellectually-impaired-home-battlematching/28.png" class="">

<p>3）类似地创建好token.php、authorize.php</p>
<p>④天猫精灵开发者平台配置</p>
<p>1）打开网址<a href="https://open.bot.tmall.com/%EF%BC%8C%E5%8F%B3%E4%B8%8A%E8%A7%92%E7%99%BB%E9%99%86%E5%B9%B3%E5%8F%B0">https://open.bot.tmall.com/，右上角登陆平台</a></p>
<p>2）添加一个新技能</p>
<img src="/articles/intellectually-impaired-home-battlematching/29.png" class="">

<p>3）技能类型选智能家居，其它随便填，下一步</p>
<img src="/articles/intellectually-impaired-home-battlematching/30.png" class="">

<p>4）填写好保存，继续下一步</p>
<img src="/articles/intellectually-impaired-home-battlematching/31.png" class="">

<p>5）点击按钮开始测试，然后点账户配置</p>
<img src="/articles/intellectually-impaired-home-battlematching/32.png" class="">

<p>6）可以看到authorize.php的提示页面</p>
<img src="/articles/intellectually-impaired-home-battlematching/33.png" class="">

<blockquote>
<p>Tips：在authorize.php里修改提示信息，随你喜欢改成中文</p>
</blockquote>
<img src="/articles/intellectually-impaired-home-battlematching/34.png" class="">

<p>7）点击yes，有如下信息返回说明成功认证。</p>
<img src="/articles/intellectually-impaired-home-battlematching/35.png" class="">


<h3 id="附1：下载"><a href="#附1：下载" class="headerlink" title="附1：下载"></a>附1：下载</h3><ul>
<li><a href="https://pan.baidu.com/s/1Hqx70PlgcB5RT2e7HaCIjA" title="php文件">php文件</a>（提取码: 7u1f）</li>
</ul>
<h3 id="附2：参考文章传送门"><a href="#附2：参考文章传送门" class="headerlink" title="附2：参考文章传送门"></a>附2：参考文章传送门</h3><ul>
<li><a href="http://bshaffer.github.io/oauth2-server-php-docs/cookbook/" title="oauth2-server-php-docs">oauth2-server-php-docs</a></li>
<li><a href="https://bbs.hassbian.com/thread-1912-1-1.html%E2%80%8B" title="[智能音箱] 天猫精灵接入HA【docker】【lamp】【oauth2】【ssl】">[智能音箱] 天猫精灵接入HA【docker】【lamp】【oauth2】【ssl】</a></li>
<li><a href="https://bbs.hassbian.com/thread-1862-1-1.html" title="[智能音箱] 天猫精灵接入HomeAssistant【智能家居技能接入，非webhook调用】">[智能音箱] 天猫精灵接入HomeAssistant【智能家居技能接入，非webhook调用】</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" title="理解OAuth 2.0">理解OAuth 2.0</a></li>
<li><a href="http://bbs.elecfans.com/jishu_1470800_1_1.html" title="[经验] 跟着小狂玩天猫精灵智能设备对接--服务器篇（二）">[经验] 跟着小狂玩天猫精灵智能设备对接–服务器篇（二）</a></li>
<li><a href="http://blog.csdn.net/newjueqi/article/details/9789659" title="Ubuntu下APACHE HTTPS安装和配置">Ubuntu下APACHE HTTPS安装和配置</a></li>
<li><a href="http://bbs.qcloud.com/thread-12061-1-1.html" title="如何在 Apache 上部署 Let&#39;s Encrypt 证书 &amp;&amp;自动续期脚本">如何在 Apache 上部署 Let’s Encrypt 证书 &amp;&amp;自动续期脚本</a></li>
</ul>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>天猫精灵</tag>
        <tag>oauth</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>智障家居初战-方案篇</title>
    <url>/articles/intellectually-impaired-home-battlenetwork/</url>
    <content><![CDATA[<blockquote>
<p>去年搬了新家，萌生了给新家打造一套智能家居控制系统，然后踏上了学习的不归之路。参考张大妈的种草文章，经过一番学习与折腾，测试验证了domoticz+rm-pro+esp8266的控制方式是可行的。</p>
</blockquote>
<hr>
<a id="more"></a>
<blockquote>
<p>根据理想中规划的应用场景，前端控制方式应该采取语音控制，不过贫穷的我既没有苹果设备（siri），又买不起echo、小爱等智能音箱。手里只有一个双去年十一99捡回来的破烂，哦不，是天猫精灵。不过那时候也搜索过，天猫精灵是没有实现接入domoticz的，倒是能直接控制rm-pro。本着相信马云爸爸日后会完善开放接口以及对语音识别技术的向往，好吧，其实还是价格便宜，最后还是入手了。也如所料，买回来之后玩过几天，然后就吃灰去了。。。<br>后来在3月初，过完年稍微闲下来的时候，无意搜索到了这篇<a href="http://bbs.elecfans.com/jishu_1471090_1_1.html" title="[经验] 跟着小狂玩天猫精灵智能设备对接--导航帖">文章</a>，发现原来天猫精灵早已经开放接口，不仅又燃起了我对新生活的向往。按着教程，算是跌跌撞撞初步实现了对接（吐槽下虽说前人栽树后人乘凉，但其实很多前人只是挖坑没种树的，按照教程去做遇到了不少问题，感觉作者是没有进行完整实践，最终结合瀚思彼岸的<a href="https://bbs.hassbian.com/thread-1862-1-1.html" title="[智能音箱] 天猫精灵接入HomeAssistant【智能家居技能接入，非webhook调用】">帖子</a>才逐渐摸索清楚），有了一些心得，写下文章分享也顺带整理知识做个备份。因琐碎的事情确实多，为此折腾不少，作为智能家居尽然要主人如此费心费力，最终达到的结果也没有理想中的智能，因此命名智障家居小小吐槽一下。<br>好了，废话不多说，进入正题，本篇先介绍下整体方案。</p>
</blockquote>
<h2 id="0-硬件介绍"><a href="#0-硬件介绍" class="headerlink" title="0.硬件介绍"></a>0.硬件介绍</h2><p>近些年陆陆续续购入了服务器、网络设备、一些智能家居产品，不知不觉就具备了折腾智能家居方案的条件。<br>①HP microserver gen8， 2016年1月15日，computeruniverse购入，首次海淘被税300。</p>
<img src="/articles/intellectually-impaired-home-battlenetwork/1.png" class="">
<p>②R6300v2，2015年11月3日，京东购入，基本最低价买的。</p>
<img src="/articles/intellectually-impaired-home-battlenetwork/2.png" class="">
<p>③博联RM pro，2017年11月11日，京东购入，价格一般，当时为研究智能家居方案就买了。</p>
<img src="/articles/intellectually-impaired-home-battlenetwork/3.png" class="">
<p>④天猫精灵，2017年11月11日，天猫购入，12月底才发货，等到花儿都谢了。</p>
<h2 id="1-关于我的智能家居设想方案"><a href="#1-关于我的智能家居设想方案" class="headerlink" title="1.关于我的智能家居设想方案"></a>1.关于我的智能家居设想方案</h2><ul>
<li>核心控制系统：domoticz</li>
<li>控制方式：语音</li>
<li>硬件：天猫精灵、rm-pro、灯具（非智能）、电视（非智能）</li>
<li>初期应用场景：通过天猫精灵控制rm-pro来实现普通灯具、电视的控制</li>
<li>后续应用场景：增加各类传感器，esp8266传输数据，domoticz自动化联动家电</li>
</ul>
<h2 id="2-技术难点及分析"><a href="#2-技术难点及分析" class="headerlink" title="2.技术难点及分析"></a>2.技术难点及分析</h2><p>方案难点在于domoticz控制体系的搭建、天猫精灵接入。domoticz相关方面的文章现成的文章较多，所以我也就侧重介绍天猫精灵接入，先看官方的接入示意图：</p>
<img src="/articles/intellectually-impaired-home-battlenetwork/4.png" class="">
<p>由图可见我们需要准备的东西有：</p>
<p>①天猫精灵</p>
<p>②天猫精灵home NLU<br>马云爸爸提供</p>
<p>③设备控制云<br>可以让天猫精灵home NLU通过公网访问得到，设备控制云其实包括两部分：<br>1）认证；<br>2）控制协议网关，即将天猫精灵过来的命令解析，然后发给domoticz；将domoticz的命令解析，转换后发送给天猫精灵。</p>
<p>④宽带</p>
<p>⑤domoticz<br>家庭智能家居控制系统，根据天猫精灵home NLU的控制指令控制家电并返回家电状态。</p>
<h2 id="3-部署方案"><a href="#3-部署方案" class="headerlink" title="3.部署方案"></a>3.部署方案</h2><p>根据家里的宽带能否提供公网IP，部署方案可以分两大类：</p>
<p>①有公网IP<br>设备控制云部署在家庭网络内，使用DDNS提供对外访问。<br>1）申请DDNS域名（需要支持SSL证书申请，与天猫精灵home NLU对接）<br>2）路由器配置DDNS、端口转发<br>3）家用服务器（部署oauth认证服务、控制协议网关、domoticz）</p>
<p>②无公网IP<br>核心思路是解决天猫精灵home NLU与我们的oauth认证服务、控制协议网关通信；控制协议网关与domoticz通信。可采用VPS+VPN的方式，申请一个域名解析到VPS主机上，通过VPN实现VPS与家庭服务器通信。<br>1）申请域名<br>2）配置VPN网络<br>VPS作为VPN服务器，家里的路由器/软路由/家用服务器作为客户端<br>3）部署oauth认证服务、控制协议网关、domoticz</p>
<p>根据oauth认证服务、控制协议网关的部署位置，又可以分两种：<br>②.①oauth认证服务、控制协议网关部署在VPS<br>VPS作为真正意义上的设备云服务器，协助处理业务<br>②.②oauth认证服务、控制协议网关部署在家用服务器<br>VPS只做代理转发，不作为业务节点处理数据<br>②.③其实网络打通后，你想把domoticz放到VPS上再控制家里的设备都行…</p>
<p>由于我家里开通的是“大内网”移动宽带，自然是没有公网IP的，所以只能采取VPS+VPN方案。不过目前国内VPS都挺贵的（除非碰上腾讯、阿里推广活动，大概能做到10元/月），国外VPS时延虽然高，不过也能将就用一下，可以薅下Google、amazon一年免费的羊毛。考虑到免费VPS会中止，要是部署东西在VPS上日后迁移还得折腾，还会有意外登陆不上的情况（有过照着教程不小心把防火墙开了但没把ssh端口加进去结果登陆不了只能重装的悲痛经历了），最终还是采用②.②方案。至于域名，阿里、腾讯云一般都有几块钱首年的。整体部署方案如下，后续篇章将展开讲述：</p>
<img src="/articles/intellectually-impaired-home-battlenetwork/5.png" class="">
<h2 id="4-任务分解"><a href="#4-任务分解" class="headerlink" title="4.任务分解"></a>4.任务分解</h2><p>接下来会分三篇来介绍，内容概要如下：</p>
<p>1)网络篇</p>
<p>VPS申请、域名申请、VPN部署</p>
<p>2)对接篇</p>
<p>部署nginx反向代理、部署oauth认证服服务</p>
<p>3)控制篇</p>
<p>安装Domoticz、控制esp8266、天猫精灵联动</p>
<h2 id="5-低能提醒"><a href="#5-低能提醒" class="headerlink" title="5.低能提醒"></a>5.低能提醒</h2><p>本系列简单粗暴阐述实践过程为主，尽量将每一步的操作过程都写出来，顺带介绍些基础知识，具备一定的LAMP基础食用更佳，老司机请随意超车。</p>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>天猫精灵</tag>
      </tags>
  </entry>
  <entry>
    <title>智障家居初战-网络篇</title>
    <url>/articles/home-for-the-mentally-retardedplan/</url>
    <content><![CDATA[<p>本篇主要讲解网络方面的准备：将会申请一台配备公网IP的VPS，并申请域名进行解析。然后，通过部署VPN，打通VPS访问家庭内网的网络访问通道。</p>
<hr>
<a id="more"></a>
<img src="/articles/home-for-the-mentally-retardedplan/1.png" class="">
<h2 id="1-VPS申请"><a href="#1-VPS申请" class="headerlink" title="1.VPS申请"></a>1.VPS申请</h2><p>目前谷歌VPS可以免费试用一年，不过申请有点复杂，需要自备梯子以及visa/master信用卡（预扣费1美元认证，不入账的）。其它VPS的开通请自行百度。</p>
<h3 id="1-1申请账号"><a href="#1-1申请账号" class="headerlink" title="1.1申请账号"></a>1.1申请账号</h3><p>访问<a href="https://cloud.google.com/" title="谷歌云">谷歌云</a>，右上角点击免费试用。按照提示填写注册信息、绑卡即可。</p>
<img src="/articles/home-for-the-mentally-retardedplan/2.png" class="">

<p>注册完后登陆控制台，点击左上角可以展开菜单栏，常用的有三项：结算、Compute Engine、VPC网络。</p>
<img src="/articles/home-for-the-mentally-retardedplan/3.png" class="">

<p>要注意的是，谷歌的免费一年指的就是赠送300$，有效期一年，期间按实际使用资源计费（扣完赠金不会自动扣信用卡的）。所以我们就不要乱用资源了，也可以常常点“结算”看到账户余额有及有效期了。一般我们启用最低配的VM是5$一个月，12个月60$，然后240$作为流量开销，大概240$/(0.23$/GB)=1043GB，完全足够使用了，详细可看<a href="https://cloud.google.com/compute/pricing" title="谷歌云价目表">价格表</a></p>
<img src="/articles/home-for-the-mentally-retardedplan/4.png" class="">

<h3 id="1-2初步配置"><a href="#1-2初步配置" class="headerlink" title="1.2初步配置"></a>1.2初步配置</h3><p>接下来进行初步的设置，使得我们可以使用客户端登陆进行管理，毕竟谷歌自带的是网页版工具，得爬梯子才能用，十分的不方便。</p>
<p>①菜单栏-&gt;Compute Engine-&gt;VM实例-&gt;创建实例</p>
<img src="/articles/home-for-the-mentally-retardedplan/5.png" class="">

<blockquote>
<p>Tips：我实测asia-east1系列节点已经没有以前人们说的那么低时延，地区us-weast1系列时延还低点（好像目前还能免费使用），所以根据个人爱好选择吧。</p>
</blockquote>
<p>②创建SSH密钥，添加到谷歌云</p>
<p>1）打开SecureCRT（7.1.1版本），Tools-&gt;Create Public Key</p>
<img src="/articles/home-for-the-mentally-retardedplan/6.png" class="">

<p>2）Key type选择RSA</p>
<img src="/articles/home-for-the-mentally-retardedplan/7.png" class="">

<p>3）填写Passphrase，不用填，填了的话secureCRT貌似有时候会要求输这个东东，如果设置的话别忘记了。</p>
<img src="/articles/home-for-the-mentally-retardedplan/8.png" class="">

<p>4）默认1024即可</p>
<img src="/articles/home-for-the-mentally-retardedplan/9.png" class="">

<p>5）选择目录保存，目录会生成一个Private key和一个Public key，Public key是我们要上传到谷歌云的</p>
<img src="/articles/home-for-the-mentally-retardedplan/10.png" class="">

<p>6）最后会提示是否作为SecureCRT的全局公匙，先选择否，我们稍后建立连接的时候再关联</p>
<img src="/articles/home-for-the-mentally-retardedplan/11.png" class="">

<p>7）找到刚才的目录，用记事本打开Identity.pub，可以看到一串ssh-rsa开头的字符串</p>
<img src="/articles/home-for-the-mentally-retardedplan/12.png" class="">

<p>8）返回谷歌云控制台，菜单栏-&gt;Compute Engine-&gt;元数据</p>
<img src="/articles/home-for-the-mentally-retardedplan/13.png" class="">

<p>9）点SSH密钥选项卡，添加一项，然后填入步骤7）的字符串+“空格”+用户名（自定义一个，比如smzdm），保存</p>
<img src="/articles/home-for-the-mentally-retardedplan/14.png" class="">

<p>10）菜单栏-&gt;VPC网络-&gt;外部IP地址，可以找到VPS主机的IP地址35.229.245.242。设置静态（类型下拉选择静态即可，提示输入名称随便输即可），不然重启后VPS主机的IP可能发生变化</p>
<img src="/articles/home-for-the-mentally-retardedplan/15.png" class="">

<img src="/articles/home-for-the-mentally-retardedplan/16.png" class="">

<p>11）菜单栏-&gt;VPC网络-&gt;防火墙规则</p>
<img src="/articles/home-for-the-mentally-retardedplan/17.png" class="">

<p>12）新增一条openvpn入站规则</p>
<img src="/articles/home-for-the-mentally-retardedplan/18.png" class="">

<p>13）新增一条出站不限制的规则</p>
<img src="/articles/home-for-the-mentally-retardedplan/19.png" class="">

<p>③securteCRT登陆</p>
<p>1）打开securtCRT，File-&gt;Quick Connect</p>
<img src="/articles/home-for-the-mentally-retardedplan/20.png" class="">

<p>2）Hostname填VPS地址，选中PublicKey，点Properties</p>
<img src="/articles/home-for-the-mentally-retardedplan/21.png" class="">

<p>3）选择之前创建的私匙</p>
<img src="/articles/home-for-the-mentally-retardedplan/22.png" class="">

<p>4）添加完私匙后会回到Quick Connect面板，点Connect连接</p>
<img src="/articles/home-for-the-mentally-retardedplan/23.png" class="">

<p>5）输入谷歌云添加SSH密钥步骤第9）步定义的用户名（公用电脑上请勿勾选Save username，并不要保留私匙）</p>
<img src="/articles/home-for-the-mentally-retardedplan/24.png" class="">

<p>6）成功登陆界面</p>
<img src="/articles/home-for-the-mentally-retardedplan/25.png" class="">

<h2 id="2-域名申请"><a href="#2-域名申请" class="headerlink" title="2.域名申请"></a>2.域名申请</h2><h3 id="2-1-购买域名"><a href="#2-1-购买域名" class="headerlink" title="2.1.购买域名"></a>2.1.购买域名</h3><p>腾讯云、阿里云经常有活动，club、xyz首年都是几块钱。</p>
<img src="/articles/home-for-the-mentally-retardedplan/26.png" class="">

<p>注册过程不再详述，购买过程有个实名认证的步骤，微信扫码支付1分钱即可，很方便。</p>
<h3 id="2-2实名审核"><a href="#2-2实名审核" class="headerlink" title="2.2实名审核"></a>2.2实名审核</h3><p>购买后腾讯云会邮件通知域名审核，点击链接前往即可，需要填写个人联系信息以及上传身份证拍照。虽然是写着要几个工作日，我提交之后大概2小时就通过审核了，效率不错。</p>
<img src="/articles/home-for-the-mentally-retardedplan/27.png" class="">

<h3 id="2-3配置域名解析"><a href="#2-3配置域名解析" class="headerlink" title="2.3配置域名解析"></a>2.3配置域名解析</h3><p>①登陆<a href="https://console.cloud.tencent.com/" title="腾讯云控制台">控制台</a>主页，在使用中的云产品点击域名管理。</p>
<img src="/articles/home-for-the-mentally-retardedplan/28.png" class="">

<p>②点击解析</p>
<img src="/articles/home-for-the-mentally-retardedplan/29.png" class="">

<p>③添加www主机记录，记录值填VPS地址35.229.245.242，用于后续与天猫精灵home NLU对接</p>
<img src="/articles/home-for-the-mentally-retardedplan/30.png" class="">

<p>④点击添加记录，主机记录选直接解析主机域名，记录值填VPS地址35.229.245.242，用于后续VPN互联</p>
<img src="/articles/home-for-the-mentally-retardedplan/31.png" class="">

<p>⑤win+r，运行cmd，输入ping 你的域名，可以看到解析已生效（有时候生效时间会需要几分钟）</p>
<img src="/articles/home-for-the-mentally-retardedplan/32.png" class="">

<img src="/articles/home-for-the-mentally-retardedplan/33.png" class="">

<p>⑥这时，secureCRT可以改用域名登陆，在新的电脑上用就不用输IP啦</p>
<img src="/articles/home-for-the-mentally-retardedplan/34.png" class="">

<h2 id="3-VPN部署"><a href="#3-VPN部署" class="headerlink" title="3.VPN部署"></a>3.VPN部署</h2><h3 id="3-0-securCRT设置"><a href="#3-0-securCRT设置" class="headerlink" title="3.0.securCRT设置"></a>3.0.securCRT设置</h3><p>①把终端的编码改成UTF-8，不然中文字符会显示乱码</p>
<img src="/articles/home-for-the-mentally-retardedplan/35.png" class="">

<p>②可以顺便改下显示效果，个人习惯黑底绿字</p>
<img src="/articles/home-for-the-mentally-retardedplan/36.png" class="">

<h3 id="3-1-VPS部分"><a href="#3-1-VPS部分" class="headerlink" title="3.1.VPS部分"></a>3.1.VPS部分</h3><p>①打开secureCRT，登陆VPS。可以看到命令提示符前的是$，是处于普通用户模式</p>
<img src="/articles/home-for-the-mentally-retardedplan/37.png" class="">

<p>②登陆VPS，输入sudo su，切换到特权模式，光标会出现#号（登陆后默认执行一次即可，后续不再提及此操作）</p>
<img src="/articles/home-for-the-mentally-retardedplan/38.png" class="">

<p>②时间同步<br>VPS安装系统默认开启了，就不用另外设置了。我们另外设置一下时区，不然时间看起来怪怪的。</p>
<p>1）<code>#tzselect</code></p>
<p>依次输入数字选Asia-&gt;China-&gt;Beijing</p>
<img src="/articles/home-for-the-mentally-retardedplan/39.png" class="">

<p>2）<code>#cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</code></p>
<blockquote>
<p>Tips：secureCRT粘贴的快捷键是SHIFT+INS（DEL上面的按键）。复制命令不需要复制”#”号</p>
</blockquote>
<p>3）<code>#vi /etc/timezone</code><br>删除原内容</p>
<img src="/articles/home-for-the-mentally-retardedplan/40.png" class="">

<p>增加Asia/Shanghai，保存退出</p>
<img src="/articles/home-for-the-mentally-retardedplan/41.png" class="">

<blockquote>
<p>Tips：在这简单简单普及下vi命令，vi是一个linux下的文本编辑工具，像常用windows的记事本。由于系统没有图形界面，只能用键盘操作，所以一开始会十分的不习惯，不过后续的配置都需要使用到vi。打开vi后，默认是非编辑模式的，也就是敲字是敲不进的，往往还会触发vi的快捷键，导致莫名其妙的结果。所以建议打开vi后，立刻按下i键进入编辑模式，就可以正常地敲字了；编辑完毕后，先按Esc退出编辑模式，然后输”:wq”回车保存或者”:q!”不保存退出。</p>
</blockquote>
<p>③开启由转发功能</p>
<p>1）<code>#vi /etc/sysctl.conf</code></p>
<p>找到#net.ipv4.ip_forward = 1行，删除”#”，保存退出 Tips：#是注释符，注释后程序不会读取这条配置项。</p>
<img src="/articles/home-for-the-mentally-retardedplan/42.png" class="">

<p>2）<code>#sysctl -p</code></p>
<p>使能配置</p>
<p>③防火墙添加允许ssh</p>
<p>1）<code>#ufw allow ssh</code><br>默认防火墙是关的，我们也不用开了，这只是防止意外开了防火墙连不上去</p>
<p>④增加软件源</p>
<p>1）<code>#vi /etc/apt/sources.list</code></p>
<p>在末位增加一行<code>deb http://mirrors.kernel.org/ubuntu artful main</code>，保存。</p>
<img src="/articles/home-for-the-mentally-retardedplan/43.png" class="">

<blockquote>
<p>Tips：增加这个源是为了安装最新版本的OpenVPN，不然安装版本是2.3.10</p>
</blockquote>
<img src="/articles/home-for-the-mentally-retardedplan/44.png" class="">

<p>2）<code>#apt-get update</code></p>
<p>apt-get update 更新软件源中的所有软件列表</p>
<img src="/articles/home-for-the-mentally-retardedplan/45.png" class="">

<p>⑤安装openvpn以及easy-rsa</p>
<p>1）<code>#apt-get install openvpn easy-rsa</code></p>
<p>按y确认就会自动完成安装，so easy</p>
<img src="/articles/home-for-the-mentally-retardedplan/46.png" class="">

<p>⑥创建CA证书</p>
<p>1）<code>#make-cadir ~/openvpn-ca</code></p>
<p>复制 easy-rsa 模板到 home 目录</p>
<img src="/articles/home-for-the-mentally-retardedplan/47.png" class="">

<blockquote>
<p>Tips：等同#mkdir ~/openvpn-ca；#cp -r /usr/share/easy-rsa/*  ~/openvpn-ca </p>
</blockquote>
<p>2）<code>#cd ~/openvpn-ca</code></p>
<p>进入 openvpn-ca 目录</p>
<img src="/articles/home-for-the-mentally-retardedplan/48.png" class="">

<p>3）<code>#vi vars</code></p>
<p>vi编辑目录下的vars文件，设置CA证书参数</p>
<img src="/articles/home-for-the-mentally-retardedplan/49.png" class="">

<p>末尾找到</p>
<img src="/articles/home-for-the-mentally-retardedplan/50.png" class="">

<p>将=号后面修改为任意的值</p>
<img src="/articles/home-for-the-mentally-retardedplan/51.png" class="">

<p>保存(Esc-&gt;:wq-&gt;回车)</p>
<p>4）<code>#source vars</code></p>
<p>会有NOTE提示</p>
<img src="/articles/home-for-the-mentally-retardedplan/52.png" class="">

<p>5）<code>#./clean-all</code></p>
<p>清除之前的配置以及生成的证书</p>
<p>6）<code>#./build-ca</code></p>
<p>启动创建过程</p>
<img src="/articles/home-for-the-mentally-retardedplan/53.png" class="">

<p>一路回车即可，即完成了CA证书的创建</p>
<p>⑦创建服务器端证书、密钥</p>
<p>1）<code>#./build-key-server server</code></p>
<img src="/articles/home-for-the-mentally-retardedplan/54.png" class="">

<p>​继续一路回车，直到出现这个确认提示（不小心按多了回车的话就要重复执行一次命令了。。）</p>
<img src="/articles/home-for-the-mentally-retardedplan/55.png" class="">

<p>最后会让你确认两次，输入y，回车即可</p>
<img src="/articles/home-for-the-mentally-retardedplan/56.png" class="">

<p>2）<code>#./build-dh</code></p>
<p>生成HMAC 签名，好像是加密通讯通道的东东，可能需要等待几分钟</p>
<img src="/articles/home-for-the-mentally-retardedplan/57.png" class="">

<p>3）<code>#openvpn --genkey --secret keys/ta.key</code></p>
<p>生成ta.key</p>
<img src="/articles/home-for-the-mentally-retardedplan/58.png" class="">

<p>⑦创建客户端证书、密钥</p>
<p>1）<code>#./build-key clientA</code></p>
<img src="/articles/home-for-the-mentally-retardedplan/59.png" class="">

<p>依然一路回车，最后输两次y确认</p>
<img src="/articles/home-for-the-mentally-retardedplan/60.png" class="">

<blockquote>
<p>Tips：可以多创建多几组证书、密钥对<br><code>./build-key clientB</code><br><code>./build-key clientC</code></p>
</blockquote>
<p>⑧检查刚刚生成的证书、密钥对</p>
<p>1）<code>#cd ~/openvpn-ca/keys</code></p>
<p>该目录是之前步骤生成的证书及密钥保存目录</p>
<p>2）<code>#ls</code></p>
<p>ls一下，看到ca、server、clientA等名字的文件</p>
<img src="/articles/home-for-the-mentally-retardedplan/61.png" class="">

<blockquote>
<p>Tips：<br>服务器端需要用到的文件有：<br>1    ca.crt<br>2    ca.key<br>3    dh2048.pem (如果最初的变量KEY_SIZE设为1024，这里就是dh1024.pem)<br>4    server.crt<br>5    server.key<br>6    ta.key (如果不开启tls-auth，则无需该文件)<br>客户端clientA需要用到的文件有：<br>1    ca.crt<br>2    clientA.crt<br>3    clientA.key (名称clientA根据个人设置可能有所不同)<br>4    ta.key (如果不开启tls-auth，则无需该文件)</p>
</blockquote>
<p>⑨配置OpenVPN服务器端</p>
<p>1）<code>#cp ca.crt ca.key server.crt server.key ta.key dh2048.pem /etc/openvpn</code></p>
<p>注意当前目录是~/openvpn-ca/keys，是生成证书保存的目录，后续需要回到该目录拷贝证书到客户端机器</p>
<img src="/articles/home-for-the-mentally-retardedplan/62.png" class="">

<p>2）<code>#gunzip -c /usr/share/doc/openvpn/examples/sample-config-files/server.conf.gz | sudo tee /etc/openvpn/server.conf</code></p>
<p>复制一个配置模板文件</p>
<p>3）<code>#vi /etc/openvpn/server.conf</code></p>
<p>修改配置文件</p>
<p>i.网段默认是10.8.0.0，如果网段与你家的网段一样就需要修改。</p>
<img src="/articles/home-for-the-mentally-retardedplan/63.png" class="">

<p>ii.找一行client-config-dir ccd，去掉前面的”;”取消注释</p>
<img src="/articles/home-for-the-mentally-retardedplan/64.png" class="">

<p>4）<code>#mkdir /etc/openvpn/ccd</code><br>创建客户端配置目录</p>
<img src="/articles/home-for-the-mentally-retardedplan/65.png" class="">

<p>5）<code>#vi /etc/openvpn/ccd/clientA</code></p>
<p>新建一个命名为客户端名字的配置文件，指定该客户端的IP，内容填ifconfig-push 10.8.0.2 10.8.0.1</p>
<img src="/articles/home-for-the-mentally-retardedplan/66.png" class="">

<blockquote>
<p>Tips：服务器IP是网段第一个IP，10.8.0.1，10.8.0.2是客户端IP</p>
</blockquote>
<p>4）<code>#systemctl start openvpn@server</code></p>
<p>启动OpenVPN服务</p>
<p>5）<code>#systemctl enable openvpn@server</code></p>
<p>设置自启动</p>
<h3 id="2、家庭服务器部分"><a href="#2、家庭服务器部分" class="headerlink" title="2、家庭服务器部分"></a>2、家庭服务器部分</h3><p>服务器系统大家自行发挥，这里以Ubuntu 16.04为例。为什么选Ubuntu，因为简单，安装过程可以选上LAMP部件，直接为后面的对接做好准备。</p>
<p>①安装</p>
<p>具体过程省略，下载<a href="https://www.ubuntu.com/download/server" title="ubuntu下载地址">服务器版本</a>即可。安装过程注意选上LAMP以及OpenSSH即可。</p>
<img src="/articles/home-for-the-mentally-retardedplan/67.png" class="">

<p>①secureCRT登陆家庭服务器</p>
<p>1）安装好Ubuntu，SSH服务是已经开启了，直接连接登陆即可。</p>
<blockquote>
<p>Tips：如果不知道服务器IP，输入ifconfig命令查看eth0</p>
</blockquote>
<p>②安装VPN</p>
<p>1）<code>#vi /etc/apt/sources.list</code></p>
<p>同VPS安装同一版本的OpenVPN，增加软件源，在末位增加一行deb <code>http://mirrors.kernel.org/ubuntu artful main</code>，保存。</p>
<img src="/articles/home-for-the-mentally-retardedplan/68.png" class="">

<p>2）<code>#apt-get update</code></p>
<p>apt-get update 更新软件源中的所有软件列表</p>
<img src="/articles/home-for-the-mentally-retardedplan/69.png" class="">

<p>3）<code>#apt-get install openvpn</code></p>
<p>客户端只安装openvpn即可</p>
<img src="/articles/home-for-the-mentally-retardedplan/70.png" class="">

<p>③拷贝证书、钥匙</p>
<p>由于证书、钥匙是在VPS上，通过sftp取有点麻烦，我们可以用图形化的工具winscp来拷贝，还有一种省事的办法就是直接拷贝文件的内容。如先前介绍，我们需要VPS的~/openvpn-ca/keys目录下ca.crt、clientA.crt、clientA.key、ta.key这四个文件。</p>
<p>1）<code>#vi /etc/openvpn/ca.crt</code></p>
<p>新建空白的ca.crt</p>
<img src="/articles/home-for-the-mentally-retardedplan/71.png" class="">

<p>2）VPS上：<code>#vi ~/openvpn-ca/keys/ca.crt</code></p>
<img src="/articles/home-for-the-mentally-retardedplan/72.png" class="">

<p>鼠标拖选，CTRL+INS复制</p>
<p>3）回到本地服务器，SHIFT+INS粘贴，保存</p>
<img src="/articles/home-for-the-mentally-retardedplan/73.png" class="">

<p>4）类似地，新建好clientA.crt、clientA.key、ta.key</p>
<p>5)<code>#ls /etc/openvpn/</code></p>
<p>最后ls检查一下是否齐全</p>
<img src="/articles/home-for-the-mentally-retardedplan/74.png" class="">

<p>④配置</p>
<p>1）<code>#cp /usr/share/doc/openvpn/examples/sample-config-files/client.conf /etc/openvpn/client.conf</code></p>
<p>拷贝一份模板文件</p>
<img src="/articles/home-for-the-mentally-retardedplan/75.png" class="">

<p>2）<code>#vi /etc/openvpn/server.conf</code></p>
<p>修改配置文件，有两处要改动的</p>
<p>i.<br>remote my-server-1 1194，”my-server-1”替换成你的VPS IP地址或者域名</p>
<img src="/articles/home-for-the-mentally-retardedplan/76.png" class="">

<p>ii.<br>Cert client.crt, “ client.crt”替换成步骤③复制证书的名称（clientA.crt)<br>Key client.key, “client.key”替换成步骤③复制钥匙的名称（clientA.key)</p>
<img src="/articles/home-for-the-mentally-retardedplan/77.png" class="">

<p>⑤启用连接</p>
<p>1）<code>#systemctl restart openvpn@client</code></p>
<p>Tips：client是/etc/openvpn目录下配置文件的名称</p>
<p>2）<code>#systemctl enable openvpn@client</code></p>
<p>设置自启动</p>
<p>3）<code>#ping 10.8.0.1</code></p>
<p>测试连通，如配置无误可以正常访问</p>
<img src="/articles/home-for-the-mentally-retardedplan/78.png" class="">

<blockquote>
<p>Tips：可以用securCRT新打开一个连接，使用#tail -f /var/log/syslog即时显示日志来观察错误提示。</p>
</blockquote>
<img src="/articles/home-for-the-mentally-retardedplan/79.png" class="">

<p>​至此，基础网络已经准备完毕。</p>
<p>参考文章传送门：</p>
<p>1、<a href="http://blog.51cto.com/ljohn/1961343" title="OpenVPN2.4.3 安装部署文档（实战）">OpenVPN2.4.3 安装部署文档（实战）</a></p>
<p>2、<a href="https://zhuanlan.zhihu.com/p/21434968" title="怎样在 Ubuntu 16.04 上安装 OpenVPN 服务">怎样在 Ubuntu 16.04 上安装 OpenVPN 服务 </a></p>
<p>3、<a href="http://blog.csdn.net/cai742925624/article/details/45483571" title="深入OpenVPN的配置 ">深入OpenVPN的配置</a></p>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>天猫精灵</tag>
        <tag>智能家居</tag>
        <tag>openvpn</tag>
      </tags>
  </entry>
  <entry>
    <title>智障家居初战-语音控制篇(基于Node-RED对接)</title>
    <url>/articles/home-for-the-mentally-retardedvoice-control-based-on-nodered-docking/</url>
    <content><![CDATA[<p>现在的整体方案较当初设想有不少变化，首先是中控系统由domoticz换成了Home Assistant（Home Assistant的界面更好看）；另外是语音控制终端由天猫精灵换成了Echo音箱（阿里搞什么实人认证，不想折腾了）；控制点、采集点由esp8266模块换成了sonoff模块（sonoff集成度更好、取电也更方便）和米家的产品（米家的使用体验好是好，就是贵）。<br>本篇主要介绍：Echo音箱与Home Assistant的对接以及全流程测试。</p>
<hr>
<a id="more"></a>
<h2 id="1-HA"><a href="#1-HA" class="headerlink" title="1.HA"></a>1.HA</h2><h3 id="1-1安装"><a href="#1-1安装" class="headerlink" title="1.1安装"></a>1.1安装</h3><p>建议ubuntu环境安装，<a href="https://bbs.hassbian.com/thread-27-1-1.html" title="[基础教程] （20180630更新）Ubuntu安装HomeAssistant教程（ubuntu17.10无坑版）">参考教程</a>。</p>
<h3 id="2-2终端设备"><a href="#2-2终端设备" class="headerlink" title="2.2终端设备"></a>2.2终端设备</h3><p>准备一个可控制的“智能”设备，在此以sonoff为例，可以<a href="https://ljr.im/articles/sonoff-basic-switch-brush-based-on-appdaemonhome-assistant-tasmota-equipped-with-illuminance-infrared-sensor-for-automatic-control-of-lights/" title="基于Appdaemon+Homeassistant的Sonoff basic开关刷Tasmota搭载光照度+红外传感器实现自动化控灯">参考教程</a>章节1-3准备一个。</p>
<h3 id="3-3控制api"><a href="#3-3控制api" class="headerlink" title="3.3控制api"></a>3.3控制api</h3><p>后续对接服务调用HA的api进行控制，使用chrome浏览器的postman插件进行测试。</p>
<p><code>http://&#123;[HA服务器ip]&#125;:8123/api/services/switch/turn_on?api_password=&#123;[HA密码]&#125;</code></p>
<p><code>&#123;&#39;entity_id&#39;:&#39;switch.template&#39;&#125;</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//响应样例</span></span><br><span class="line">[&#123;</span><br><span class="line">  <span class="string">&quot;attributes&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;friendly_name&quot;</span>: <span class="string">&quot;测试&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;context&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;id&quot;</span>: <span class="string">&quot;1898701755c24dd58c41df43d32fa4d1&quot;</span>,</span><br><span class="line">      <span class="string">&quot;user_id&quot;</span>: <span class="literal">null</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;entity_id&quot;</span>: <span class="string">&quot;switch.template&quot;</span>,</span><br><span class="line">  <span class="string">&quot;last_changed&quot;</span>: <span class="string">&quot;2018-09-14T03:32:28.422597+00:00&quot;</span>,</span><br><span class="line">  <span class="string">&quot;last_updated&quot;</span>: <span class="string">&quot;2018-09-14T03:32:28.422597+00:00&quot;</span>,</span><br><span class="line">  <span class="string">&quot;state&quot;</span>: <span class="string">&quot;on&quot;</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

<h2 id="2-Echo音箱"><a href="#2-Echo音箱" class="headerlink" title="2.Echo音箱"></a>2.Echo音箱</h2><p>前往开发者平台创建一个自定义技能，并关联到Echo，这样Echo就能将我们的语音指令翻译成Json格式指令并发送到我们指定的接口服务器。后续再根据指令调用HA的api来对终端设备进行控制。</p>
<h3 id="2-1创建skill"><a href="#2-1创建skill" class="headerlink" title="2.1创建skill"></a>2.1创建skill</h3><ul>
<li><p><a href="https://developer.amazon.com/alexa/console/ask" title="Amazon开发者平台">登陆开发者平台</a></p>
</li>
<li><p>点击右侧”Create Skill”按钮</p>
</li>
</ul>


<ul>
<li>输入技能名称，类型选”Custom”，点击”Create Skill”按钮。</li>
</ul>


<blockquote>
<p><strong>DEBUG：其实更建议选”Smart Home”，Amazon定义好了很多标准属性，更加适合智能家居场景，不过指令的处理需要使用AWS Lamaba，不能用自己的服务。</strong></p>
</blockquote>
<ul>
<li>默认第一个即可，点击”Choose”继续。</li>
</ul>


<ul>
<li>“Build”标签页加载如下，在这我们对Skill进行配置，可以看到1-4步骤是必须的。</li>
</ul>


<h4 id="2-1-1-Invocation"><a href="#2-1-1-Invocation" class="headerlink" title="2.1.1 Invocation"></a>2.1.1 Invocation</h4><ul>
<li>点击左侧面板”Invocation”，设置调用名称，默认是和技能名称一样。</li>
</ul>


<blockquote>
<p><strong>INFO：设置完毕点击”Save Model”保存，后续不再提及。</strong></p>
</blockquote>
<h4 id="2-1-2-Intent"><a href="#2-1-2-Intent" class="headerlink" title="2.1.2 Intent"></a>2.1.2 Intent</h4><ul>
<li>点击左侧面板”Intents”，打开页面中点击”Add Intent”。</li>
</ul>


<ul>
<li>创建一个意图。假设我们目的是控制灯，创建一个”LightControll”意图。</li>
</ul>


<blockquote>
<p><strong>DEBUG：意图（intent）是在语言处理模块与执行模块之间传递信息的一种比较通用的格式标准，可以简单认为是用户命令的形式化描述。</strong></p>
</blockquote>
<blockquote>
<p><strong>INFO：意图名称”LightControll”会传递给接口服务器，然后我们就知道这是控制灯。</strong></p>
</blockquote>
<ul>
<li>一个意图需要设置Sample Utterances和Intent Slots。</li>
</ul>


<blockquote>
<p><strong>INFO：Sample Utterances是不同的说话样例，比如我们关灯可以说“打开厨房的灯”和“把厨房的灯打开”。然后Intent Slots是说话样例中的变量，我们“打开厨房的灯”、“打开客厅的灯”，“客厅”、“厨房”就是一个位置变量，用一个Slot代替。</strong></p>
</blockquote>
<ul>
<li>在这我创建两种话例：”turn {sate} the {zone} light”、”turn the {zone} light {state}”Utterances。其中包含两个变量{state}，代表开灯还是关灯；{zone}，代表灯的位置。</li>
</ul>


<blockquote>
<p><strong>DEBUG：当增加的话例中含有{xxx}，会自动创建对应名称的slot。</strong></p>
</blockquote>
<ul>
<li>还要为slot设置类型，点击左侧面板”Slot Types”，然后点击”Add Slot Type”。</li>
</ul>


<ul>
<li>自定义即可，输入名称”CUSTOM_ZONE”，点击”Create custom slot type”。</li>
</ul>


<ul>
<li>依次添加”kitchen”和”living room”，作为测试就不添加多了。</li>
</ul>


<blockquote>
<p><strong>DEBUG：如果设置同义词”SYNONYMS”，那应该设置”ID”，这样对接服务器根据”ID”来判断具体位置。</strong></p>
</blockquote>
<ul>
<li>类似添加”CUSTOM_STATE”，两个值”on”、”off”分别对应开、关，。</li>
</ul>


<ul>
<li>点击左侧面板”LightControll” Intent返回先前页面，为”zone”、”state”设置SLOT TYPE。</li>
</ul>


<ul>
<li>点击上方”Save Model”，再点击”Build Model”，需要等待一段时间。</li>
</ul>



<h3 id="2-2配置"><a href="#2-2配置" class="headerlink" title="2.2配置"></a>2.2配置</h3><h4 id="2-2-1-Endpoint"><a href="#2-2-1-Endpoint" class="headerlink" title="2.2.1 Endpoint"></a>2.2.1 Endpoint</h4><ul>
<li>点击左侧面板”Endpoint”，点击HTTPS，输入接口服务器的API地址<code>https://&#123;[你的域名]&#125;/gate</code>。下拉框是选择证书类型，一般选<code>My development endpoint is a sub-domain of a domain that has a wildcard certificate from a certificate authority.</code></li>
</ul>


<blockquote>
<p><strong>DEBUG：我们服务器与Alexa Skill服务器对接的网址，负责处理Json指令请求，具体实现见4.2章节。</strong><br><strong>WARN：需要使用HTTPS以及默认的443端口。</strong></p>
</blockquote>
<h4 id="2-2-2-ACCOUNT-LINKING"><a href="#2-2-2-ACCOUNT-LINKING" class="headerlink" title="2.2.2 ACCOUNT LINKING"></a>2.2.2 ACCOUNT LINKING</h4><ul>
<li>点击左侧面板”ACCOUNT LINKING”，打开开关，选择”Auth Code Grant”</li>
</ul>


<ul>
<li>“Authorization URI”填<code>https://&#123;[你的域名]&#125;/authorize.php</code>；”Access Token URI”填<code>https://&#123;[你的域名]&#125;/token.php</code>；”Client ID”填<code>alexa</code>；”Client Secret”填<code>alexa</code>；”Client Authentication Scheme”选择<code>Credentials in request body</code>；”Redirect URLs”中挑选一个（选择一个可以ping通的域名即可）。</li>
</ul>
<blockquote>
<p><strong>INFO：认证服务网址的内容见3.1章节</strong></p>
</blockquote>


<h4 id="2-2-3-Oauth服务"><a href="#2-2-3-Oauth服务" class="headerlink" title="2.2.3 Oauth服务"></a>2.2.3 Oauth服务</h4><p>参考<a href="https://ljr.im/articles/mentally-retarded-home-first-battle-docking-articles/" title="智障家居初战-对接篇">教程2.2.②章节</a>创建好数据库，增加一个用户即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Ubuntu</span></span><br><span class="line">mysql -u root -p <span class="comment">#登陆Mysql</span></span><br><span class="line">&gt; use oauth; <span class="comment">#选择数据库</span></span><br><span class="line">&gt; INSERT INTO oauth_clients (client_id, client_secret, redirect_uri) VALUES(<span class="string">&quot;alexa&quot;</span>,<span class="string">&quot;alexa&quot;</span>,<span class="string">&quot;https://pitangui.amazon.com/api/skill/link/xxx&quot;</span>); <span class="comment">#增加认证用户（信息与上小节设置一致）</span></span><br></pre></td></tr></table></figure>

<h2 id="3-对接"><a href="#3-对接" class="headerlink" title="3.对接"></a>3.对接</h2><h3 id="3-1公网服务"><a href="#3-1公网服务" class="headerlink" title="3.1公网服务"></a>3.1公网服务</h3><p>参考<a href="https://ljr.im/articles/mentally-retarded-home-first-battle-network-articles/" title="智障家居初战-网络篇">教程</a>部署公网访问服务器，其中oauth认证服务采用之前的即可。之前设置接口服务器的API网址为<code>https://&#123;[你的域名]&#125;/gate</code>，接下来只要apache2将请求转发给Node-Red服务器即可。<br><a href="https://ljr.im/articles/docker-installation-using-nodered-practice/" title="docker安装使用Node-RED实践">Node-Red安装参考教程</a></p>
<ul>
<li>apache2配置，假设Node-Red的访问地址是<code>http://192.168.0.100:1880</code>。<ol>
<li><code># a2enmod proxy</code></li>
<li><code># vi /etc/apache2/sites-available/default-ssl.conf</code></li>
<li>在&lt;VirtualHost&gt;&lt;/VirtualHost&gt;标签内加入<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">ProxyPass</span> <span class="string">/gate</span> <span class="string">http://192.168.0.100:1880/gate</span></span><br><span class="line"><span class="string">ProxyPassReverse</span> <span class="string">/gate</span> <span class="string">http://192.168.0.100:1880/gate</span></span><br></pre></td></tr></table></figure></li>
<li><code># service apache2 restart</code><blockquote>
<p><strong>WARN：注意不要把根目录/进行反向代理，不然外网可以访问Node-Red了。</strong></p>
</blockquote>
</li>
</ol>
</li>
</ul>
<ul>
<li><p>Node-red配置，设置登陆密码，加强安全。</p>
<ol>
<li><code># docker exec -it &#123;[Node-Red容器名]&#125; bash</code></li>
<li><code>root@xxxx# node -e &quot;console.log(require(&#39;bcryptjs&#39;).hashSync(process.argv[1], 8));&quot; password</code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@xxxx<span class="comment"># $2a$08$BpwjQlfQEtuT8z5ZfwiTqeDBauNkMeVYMl4vbNrmxd89o1/WeGtRm</span></span><br></pre></td></tr></table></figure></li>
<li><code>root@xxxx# vi /data/settings.js</code></li>
<li>找到adminAuth，注释掉adminAuth，password处填第2步生成的字符串。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">adminAuth: &#123;</span><br><span class="line">type: <span class="string">&quot;credentials&quot;</span>,</span><br><span class="line">users: [&#123;</span><br><span class="line">    username: <span class="string">&quot;&#123;[用户名]&#125;&quot;</span>,</span><br><span class="line">    password: <span class="string">&quot;&#123;[密码]&#125;&quot;</span>,</span><br><span class="line">    permissions: <span class="string">&quot;*&quot;</span></span><br><span class="line">&#125;]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
<li>返回到宿主机，<code># doecker restart &#123;[Node-Red容器名]&#125;</code>使配置生效。<blockquote>
<p><strong>DEBUG：配置password保存的是加密后的字符串。</strong></p>
</blockquote>
</li>
</ol>
</li>
</ul>
<h2 id="4-业务处理"><a href="#4-业务处理" class="headerlink" title="4.业务处理"></a>4.业务处理</h2><p>Node-Red搭建业务处理节点，因篇幅有限，加上本人对Alexa的交互了解有限，所以在此只介绍下大体处理流程，详细的实现还是要耐心去看看官方的文档。</p>


<blockquote>
<p><strong>DEBUG：采用Node-Red进行对接的最大的好处就是灵活扩展，基本流程上扩充即可，可以一边学习一边不断完善。</strong></p>
</blockquote>
<h2 id="5-联调"><a href="#5-联调" class="headerlink" title="5.联调"></a>5.联调</h2><ul>
<li>打开<a href="https://alexa.amazon.com/" title="Echo设备管理页面">Echo设备管理页面</a>，左侧点击’Skills’，然后点击右上角’Your Skills’。</li>
</ul>


<ul>
<li>点击’ALL SKILLS’，可以看到开发的技能。</li>
</ul>


<ul>
<li>点击’ENABLE’启用技能，会跳转到授权页面。</li>
</ul>


<ul>
<li>认证成功会返回如下页面。</li>
</ul>


<ul>
<li>返回开发者平台的技能页面，在上方点击’Test’标签打开测试页面，输入指令可以进行测试。</li>
</ul>


<ul>
<li>文字指令测试正常，可以进行真机测试。</li>
</ul>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>Home Assistant</tag>
        <tag>Node-RED</tag>
        <tag>智能家居</tag>
        <tag>Alexa</tag>
        <tag>Echo</tag>
      </tags>
  </entry>
  <entry>
    <title>精简下斐讯TC1固件</title>
    <url>/articles/streamline-the-fixon-tc1-firmware/</url>
    <content><![CDATA[<p>某天百度发现有大佬把斐讯TC1的<a href="https://github.com/a2633063/zTC1" title="zTC1">固件</a>(基于MiCO开发)给做出来了，犹豫再三还是剁手了，因为家里的排插真的好多了，又需要新的编程器。不过真香，六插孔+USB充电确实实用。想着原来固件的功能有的自己用不上，看了下代码结构挺简单的，于是精简了一下功能，分享下折腾记录吧。</p>
<hr>
<a id="more"></a>
<h2 id="0-update"><a href="#0-update" class="headerlink" title="0. update"></a>0. update</h2><ul>
<li>2019-09-27<br>经反馈会有断外网重启的bug，查看代码貌似只有SNTP同步时间会联外网，于是尝试调整了一下SNTP相关代码（编译固件也可以把<code>main.c</code>的<code>sntp_init();</code>去掉不要sntp功能），要是还解决不了我也木办法了{摊手}</li>
</ul>
<h2 id="1-改动说明"><a href="#1-改动说明" class="headerlink" title="1. 改动说明"></a>1. 改动说明</h2><p>基于原固件v0.10进行修改：</p>
<ul>
<li>设定WIFI和MQTT设置直接烧录，懒得再装APP了</li>
<li>去掉UDP通信功能，只保留MQTT通信功能</li>
<li>去掉插座命名、定时功能，这块用Home Assistant来管理</li>
<li>MQTT通信协议根据自己使用习惯进行了调整：调整topic、增加上线下线通知、使用qos</li>
<li>把编译的warning警告基本去掉了</li>
</ul>
<blockquote>
<p><strong>WARING：因为精简掉UDP通信协议，使用上会造成不方便，精简带来的好处实际也不明显，请自行权衡。</strong></p>
</blockquote>
<hr>
<h2 id="2-编译环境"><a href="#2-编译环境" class="headerlink" title="2. 编译环境"></a>2. 编译环境</h2><p>使用docker，docker安装方法<a href="https://ljr.im/articles/docker-installation-using-nodered-practice/" title="docker安装使用Node-RED实践">传送门</a>。</p>
<ul>
<li><p>拉一个python2.7的镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull python:2-slim-stretch</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动容器并进入容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#自己调整主机映射目录/home/mico；容器内工程目录设置为/workdir，可根据喜好调整，但注意后续命令也要调整。</span></span><br><span class="line">docker run -it --name mico -v /home/mico:/workdir python:2-slim-stretch bash</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>DEBUG：后续进入容器可以用命令docker exec -it mico bash，更多docker命令介绍<a href="https://ljr.im/articles/the-four-stages-of-docker-from-entry-to-pit/" title="docker从入门到入坑的四个阶段">传送门</a>。</strong></p>
</blockquote>
</li>
<li><p>更新源、安装软件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#容器bash</span></span><br><span class="line">apt update &amp;&amp; apt install git wget lib32ncurses5</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：一个坑，不安装lib32ncurses5库编译会报”arm-none-eabi-gcc: not found”错误。</strong></p>
</blockquote>
</li>
<li><p>python bin</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ln -s /usr/<span class="built_in">local</span>/bin/python /usr/bin/python</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：一个坑，不设置软链接编译会报”/usr/bin/python: not found”错误。</strong></p>
</blockquote>
</li>
<li><p>安装MiCo编译环境（mico-cube、MiCoder）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#容器bash</span></span><br><span class="line">pip install mico-cube &amp;&amp; \</span><br><span class="line"><span class="built_in">cd</span> /workdir &amp;&amp; \</span><br><span class="line">wget http://firmware.mxchip.com/MiCoder_v1.1.Linux.tar.gz &amp;&amp; \</span><br><span class="line">tar -zxf MiCoder_v1.1.Linux.tar.gz &amp;&amp; \</span><br><span class="line">rm MiCoder_v1.1.Linux.tar.gz &amp;&amp; \</span><br><span class="line">mico config --global MICODER /workdir/MiCoder</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>DEBUG：mico-cube是MXCHIP的MiCO项目开发管理工具包；MiCoder是MiCO编译和调试系统必须的工具软件包。</strong></p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="3-编译固件"><a href="#3-编译固件" class="headerlink" title="3.编译固件"></a>3.编译固件</h2><ul>
<li><p>创建一个空项目，名为TC1，自己开发则自定义</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#容器bash</span></span><br><span class="line"><span class="built_in">cd</span> /workdir &amp;&amp; \</span><br><span class="line">mico new TC1 --create-only</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：命令执行完后，会在当前目录生成名称为TC1项目目录。</strong></p>
</blockquote>
</li>
<li><p>添加mico-os组件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#容器bash</span></span><br><span class="line"><span class="built_in">cd</span> /workdir/TC1 &amp;&amp; \</span><br><span class="line">mico add https://code.aliyun.com/mico/mico-os.git/<span class="comment">#6c465211d3ff8797cd835e400ec54a06530dd476</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：需要在项目目录下执行。</strong></p>
</blockquote>
</li>
<li><p>添加项目代码，代码目录在项目目录下的<code>项目同名目录</code>，/workdir/TC1/TC1，自己开发则自定义</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#容器bash</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/cnk700i/tc1_mqtt.git &amp;&amp; \</span><br><span class="line">mv tc1_mqtt/TC1 . &amp;&amp; \</span><br><span class="line">rm tc1_mqtt -r</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>DEBUG：下载zip解压后再拷贝进去也可以。</strong></p>
</blockquote>
</li>
<li><p>设置WiFi及MQTT，修改项目代码main.h文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZTC_NAME <span class="meta-string">&quot;tc1_%s&quot;</span>                       <span class="comment">//设备名称模板，默认生成的设备名称为tc1_&#123;&#123;MAC地址&#125;&#125;，PS：如修改要保留%s，将填充MAC地址</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SSID <span class="meta-string">&quot;wifi_ssid&quot;</span>                 <span class="comment">//WiFi名称</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_USER_KEY <span class="meta-string">&quot;wifi_password&quot;</span>         <span class="comment">//WiFi密码</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_MQTT_IP <span class="meta-string">&quot;mqtt_ip&quot;</span>                <span class="comment">//MQTT服务器IP</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_MQTT_PORT 1883                   <span class="comment">//MQTT服务器端口     </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_MQTT_USER <span class="meta-string">&quot;mqtt_user&quot;</span>            <span class="comment">//MQTT用户名</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_MQTT_PASSWORD <span class="meta-string">&quot;mqtt_password&quot;</span>    <span class="comment">//MQTT密码</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATE_UPDATE_INTERVAL 10000             <span class="comment">//功率上报间隔，单位ms</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MQTT_CLIENT_SUB_TOPIC   <span class="meta-string">&quot;cmnd/%s&quot;</span>       <span class="comment">//命令控制接收topic，%s取ZTC_NAME（默认tc1_&#123;&#123;MAC地址&#125;&#125;），PS：请勿修改此处，可修改ZTC_NAME</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MQTT_CLIENT_PUB_TOPIC   <span class="meta-string">&quot;stat/%s&quot;</span>       <span class="comment">//状态信息topic，%s取ZTC_NAME（默认tc1_&#123;&#123;MAC地址&#125;&#125;），PS：请勿修改此处，可修改ZTC_NAME</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USER_CONFIG_VERSION 3                   <span class="comment">//修改为与上次固件不同，触发重新加载信息（线刷可忽略）</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编译项目代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#容器bash</span></span><br><span class="line"><span class="comment">#/workdir/TC1</span></span><br><span class="line">mico make TC1@MK3031@moc</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="4-刷固件"><a href="#4-刷固件" class="headerlink" title="4.刷固件"></a>4.刷固件</h2><ul>
<li>编译成功后的固件文件<ul>
<li><code>/workdir/TC1/build/TC1@MK3031@moc/binary/TC1@MK3031@moc.all.bin</code>，用于线刷</li>
<li><code>/workdir/TC1/build/TC1@MK3031@moc/binary/TC1@MK3031@moc.ota.bin</code>，用于OTA</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>INFO：主机映射目录/home/mico/TC1/build/TC1@MK3031@moc/binary内可找到固件。</strong></p>
</blockquote>
<ul>
<li><p>线刷方法略，见原固件教程的<a href="https://github.com/a2633063/zTC1/wiki/%E5%9B%BA%E4%BB%B6%E7%83%A7%E5%BD%95" title="固件烧录">固件烧录</a></p>
</li>
<li><p>OTA则使用MQTT客户端，例如MQTT.fx，发送消息给TC1触发OTA。</p>
<ul>
<li>topic<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;cmnd/tc1_&#123;&#123;MAC地址&#125;&#125;&quot;（如修改设备名称模板ZTC_NAME，则填写&quot;cmnd/&#123;&#123;设备名称&#125;&#125;&quot;）</span><br></pre></td></tr></table></figure></li>
<li>content<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;setting&quot;</span>:</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;ota&quot;</span>:<span class="string">&quot;&#123;&#123;ota.bin的http下载地址&#125;&#125;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>WARN：可以用Http File Server之类的免安装工具搭建http服务器，使用浏览器测试打开链接可以直接下载bin文件。另外文件名不要含特殊符号。</strong></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="5-接入homeassistant"><a href="#5-接入homeassistant" class="headerlink" title="5.接入homeassistant"></a>5.接入homeassistant</h2><p>启用homeassistant的mqtt组件的自动发现，重启HA，再重启TC1（断电再接电）。<br>  <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">&#123;&#123;<span class="string">HA配置目录</span>&#125;&#125;<span class="string">/configuration.yaml</span></span><br><span class="line"><span class="attr">mqtt:</span></span><br><span class="line"><span class="attr">mqtt:</span></span><br><span class="line">  <span class="comment"># MQTT Broker的IP地址或者域名</span></span><br><span class="line">  <span class="attr">broker:</span> <span class="string">xx</span></span><br><span class="line">  <span class="comment"># MQTT Broker的端口号，缺省为1883</span></span><br><span class="line">  <span class="attr">port:</span> <span class="string">xx</span></span><br><span class="line">  <span class="comment"># 用户名</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">xx</span></span><br><span class="line">  <span class="comment"># 密码</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">xx</span></span><br><span class="line">  <span class="comment"># 自动发现</span></span><br><span class="line">  <span class="attr">discovery:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 自动发现topic前缀，与固件设置的一致</span></span><br><span class="line">  <span class="attr">discovery_prefix:</span> <span class="string">homeassistant</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>__INFO：TC1在启动的时候往&#123;&#123;discovery_prefix&#125;&#125;/&#123;&#123;component&#125;&#125;/&#123;&#123;node_id&#125;&#125;/&#123;&#123;object_id&#125;&#125;/config发送配置信息，HA根据配置信息生成entity。__</p>
</blockquote>
<hr>
<h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h2><ul>
<li>MiCo开发平台比之前DC1用的ESPHome容易上手好多，搭建环境也简单些，遇到一些小坑还是比较快就解决了。</li>
<li>C语言看着真的头大，又感觉到了被指针支配的恐惧，还好原固件作者代码的业务逻辑还是比较清晰，于是就简单地改一改。</li>
</ul>
]]></content>
      <categories>
        <category>Home Assistant</category>
      </categories>
      <tags>
        <tag>MQTT</tag>
        <tag>TC1</tag>
        <tag>MiCO</tag>
      </tags>
  </entry>
  <entry>
    <title>【插件】基于Appdaemon的通用定时器</title>
    <url>/articles/plugin-universal-timer-based-on-appdaemon/</url>
    <content><![CDATA[<p>家里卫生间是暗卫，通风全靠抽风机，洗完澡都得开着一、两个小时。但通常晚上睡觉去了，往往得开着一宿，有点浪费电。很久很久之前肉痛地换了个aqara墙壁开关，想做个自动化解决这一痛点，但发现洗澡场景不好判断，定点的自动化又有点低端，计划就搁浅了。后来在瀚思彼岸看到过一个定时器的<a href="https://bbs.hassbian.com/thread-3660-1-1.html" title="[新奇玩法] 【卡片系列之延时器】一个关于延迟倒计时的万能应用">帖子</a>，试用下来还算可以，考量着就先这么控制吧。考虑到这个定时器是基于HA自动化做的，限制较多，最明显就是不支持多任务以及配置麻烦，于是自己折腾做了个Appdaemon版本的。为了优（zeng）雅（jia）调（nan）度（du），采用以前在公众号上看过的一篇<a href="https://mp.weixin.qq.com/s/mvFwjgxliwx808Hn_9ruEA" title="10w定时任务，如何高效触发超时">文章</a>提及的环形队列法。</p>
<hr>
<h2 id="0-功能说明"><a href="#0-功能说明" class="headerlink" title="0.功能说明"></a>0.功能说明</h2><img src="/articles/plugin-universal-timer-based-on-appdaemon/demo1.gif" class="" title="[效果图1]">    <img src="/articles/plugin-universal-timer-based-on-appdaemon/demo2.gif" class="" title="[效果图2]">
<ul>
<li>支持多个定时任务</li>
<li>可定义开/关操作</li>
<li>自动加载设备列表，无需额外配置</li>
<li>采用看起来很厉害的环形定时队列</li>
<li>可记忆设备上次设置的定时时间</li>
</ul>
<hr>
<h2 id="1-环境"><a href="#1-环境" class="headerlink" title="1.环境"></a>1.环境</h2><ul>
<li>HA 0.74.0</li>
<li>Appdaemon 3.0.1（<a href="https://ljr.im/articles/sonoff-basic-switch-brush-based-on-appdaemonhome-assistant-tasmota-equipped-with-illuminance-infrared-sensor-for-automatic-control-of-lights/" title="基于Appdaemon+Home Assistant的Sonoff basic开关刷Tasmota搭载光照度+红外传感器实现自动化控灯">安装参考教程</a>）</li>
</ul>
<hr>
<h2 id="2-过程"><a href="#2-过程" class="headerlink" title="2.过程"></a>2.过程</h2><h3 id="2-1Home-Assistant部分"><a href="#2-1Home-Assistant部分" class="headerlink" title="2.1Home Assistant部分"></a>2.1Home Assistant部分</h3><h4 id="2-1-1配置项"><a href="#2-1-1配置项" class="headerlink" title="2.1.1配置项"></a>2.1.1配置项</h4><ul>
<li>common_timer.yaml<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Packages配置方式</span></span><br><span class="line"><span class="comment">#&#123;HA配置目录&#125;/packages/common_timer.yaml</span></span><br><span class="line"><span class="attr">homeassistant:</span></span><br><span class="line">  <span class="attr">customize:</span></span><br><span class="line">    <span class="attr">input_select.domain:</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">mdi:format-list-bulleted-type</span></span><br><span class="line">    <span class="attr">input_select.entity:</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">mdi:format-list-checkbox</span></span><br><span class="line">    <span class="attr">input_select.opera:</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">mdi:nintendo-switch</span></span><br><span class="line">    <span class="attr">input_text.common_timer:</span></span><br><span class="line">      <span class="attr">friendly_name:</span> <span class="string">延迟时间</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">mdi:timer-sand</span></span><br><span class="line">    <span class="attr">input_boolean.timer_button:</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">mdi:sync</span></span><br><span class="line"></span><br><span class="line"><span class="attr">group:</span></span><br><span class="line">  <span class="attr">common_timer:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">通用定时器</span></span><br><span class="line">    <span class="attr">entities:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">input_select.domain</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">input_select.entity</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">input_select.opera</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">input_text.common_timer</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">input_boolean.timer_button</span></span><br><span class="line"></span><br><span class="line"><span class="attr">input_text:</span></span><br><span class="line">  <span class="attr">common_timer:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">common_timer</span></span><br><span class="line">    <span class="attr">initial:</span> <span class="number">00</span><span class="string">:00:00</span></span><br><span class="line">    <span class="attr">pattern:</span> <span class="string">&#x27;([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">input_select:</span></span><br><span class="line">  <span class="attr">domain:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">设备类型</span></span><br><span class="line">    <span class="attr">options:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">请选择设备类型</span></span><br><span class="line">    <span class="attr">initial:</span> <span class="string">&#x27;请选择设备类型&#x27;</span></span><br><span class="line">  <span class="attr">entity:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">设备名称</span></span><br><span class="line">    <span class="attr">options:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">请选择设备</span></span><br><span class="line">    <span class="attr">initial:</span> <span class="string">&#x27;请选择设备&#x27;</span></span><br><span class="line">  <span class="attr">opera:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">操作</span></span><br><span class="line">    <span class="attr">options:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">开</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">关</span></span><br><span class="line">    <span class="attr">initial:</span> <span class="string">&#x27;关&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">input_boolean:</span></span><br><span class="line">  <span class="attr">timer_button:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">&#x27;启用/暂停&#x27;</span></span><br><span class="line">    <span class="attr">initial:</span> <span class="string">off</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">mdi:switch</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>__INFO：增加三个input_select用于选择设备类型、设备、操作类型；一个input_text用于输入定时；一个input_boolean用于开关按钮。__</p>
</blockquote>
</li>
</ul>
<h3 id="2-2Appdaemon部分"><a href="#2-2Appdaemon部分" class="headerlink" title="2.2Appdaemon部分"></a>2.2Appdaemon部分</h3><h4 id="2-2-1配置项"><a href="#2-2-1配置项" class="headerlink" title="2.2.1配置项"></a>2.2.1配置项</h4><ul>
<li>apps.yaml<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#&#123;appdaemon配置目录&#125;/apps/apps.yaml</span></span><br><span class="line"><span class="attr">timer:</span></span><br><span class="line">  <span class="attr">module:</span> <span class="string">common_timer</span></span><br><span class="line">  <span class="attr">class:</span> <span class="string">Timer</span></span><br><span class="line">  <span class="attr">domains:</span>                                      <span class="comment">#设置可控制的设备类型</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">light</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">switch</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">script</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">automation</span></span><br><span class="line">  <span class="attr">exclude:</span>                                      <span class="comment">#排除设备</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">light.xxx</span></span><br><span class="line">  <span class="attr">should_zh:</span> <span class="literal">False</span>                              <span class="comment">#是否排除friendly_name非中文设备</span></span><br><span class="line">  <span class="attr">input_domain:</span> <span class="string">&#x27;input_select.domain&#x27;</span>           <span class="comment">#设备类型下拉框</span></span><br><span class="line">  <span class="attr">input_entity:</span> <span class="string">&#x27;input_select.entity&#x27;</span>           <span class="comment">#设备下拉框</span></span><br><span class="line">  <span class="attr">input_opera:</span> <span class="string">&#x27;input_select.opera&#x27;</span>             <span class="comment">#操作类型下拉框</span></span><br><span class="line">  <span class="attr">input_duration:</span> <span class="string">&#x27;input_text.common_timer&#x27;</span>     <span class="comment">#延时时间文本框</span></span><br><span class="line">  <span class="attr">switch:</span> <span class="string">&#x27;input_boolean.timer_button&#x27;</span>          <span class="comment">#控制按钮</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>WARN：目前只设置开（turn_on）和关（turn_off）方法，只有HA注册了对应的服务才能执行，目前light、switch、script、automation几类都有。</strong></p>
<p><strong>INFO：下拉框、文本框、按钮的id设置与HA配置一致即可，可自行定义。</strong></p>
</blockquote>
</li>
</ul>
<h4 id="2-2-2代码"><a href="#2-2-2代码" class="headerlink" title="2.2.2代码"></a>2.2.2代码</h4><ul>
<li><p>common_timer.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#&#123;appdaemon配置目录&#125;/apps/common_timer.py</span></span><br><span class="line"><span class="keyword">import</span> appdaemon.plugins.hass.hassapi <span class="keyword">as</span> hass</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime,timedelta</span><br><span class="line"><span class="keyword">import</span> DelayQueue</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Timer</span>(<span class="params">hass.Hass</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._entities = &#123;&#125;</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self._input_domain = self.args[<span class="string">&#x27;input_domain&#x27;</span>]</span><br><span class="line">            self._input_entity = self.args[<span class="string">&#x27;input_entity&#x27;</span>]</span><br><span class="line">            self._input_opera = self.args[<span class="string">&#x27;input_opera&#x27;</span>]</span><br><span class="line">            self._input_duration = self.args[<span class="string">&#x27;input_duration&#x27;</span>]</span><br><span class="line">            self._switch = self.args[<span class="string">&#x27;switch&#x27;</span>]</span><br><span class="line">        <span class="keyword">except</span> KeyError <span class="keyword">as</span> e:</span><br><span class="line">            self.log(<span class="string">&quot;初始化失败，apps.yaml中需要定义input_domain、input_entity、input_opera、input_duration、switch&quot;</span>)</span><br><span class="line">        self._queue = DelayQueue.DelayQueue(<span class="number">60</span>, self)   <span class="comment">#环形延时队列</span></span><br><span class="line">        self._dic_friendly_name = &#123;&#125;                    <span class="comment">#存储friendly_name与entity_id的单向映射</span></span><br><span class="line">        self._dic_opera = &#123;<span class="string">&#x27;turn_on&#x27;</span>:<span class="string">&#x27;开&#x27;</span>,<span class="string">&#x27;turn_off&#x27;</span>:<span class="string">&#x27;关&#x27;</span>,<span class="string">&#x27;开&#x27;</span>:<span class="string">&#x27;turn_on&#x27;</span>,<span class="string">&#x27;关&#x27;</span>:<span class="string">&#x27;turn_off&#x27;</span>&#125;                            <span class="comment">#存储opera与中文名的双向映射</span></span><br><span class="line">        self.register_constraint(<span class="string">&#x27;hasTask&#x27;</span>)             <span class="comment">#判断是否有延时任务</span></span><br><span class="line">        self._domains = self.args.get(<span class="string">&#x27;domains&#x27;</span>, [<span class="string">&#x27;light&#x27;</span>, <span class="string">&#x27;switch&#x27;</span>])   <span class="comment">#设置设备类型列表</span></span><br><span class="line">        self._exclude = self.args.get(<span class="string">&#x27;exclude&#x27;</span>, [])        <span class="comment">#排除指定设备</span></span><br><span class="line">        self._should_zh = self.args.get(<span class="string">&#x27;should_zh&#x27;</span>, <span class="literal">True</span>)  <span class="comment">#排除friendly_name非中文设备，默认是</span></span><br><span class="line">        self._exclude.append(self._switch)    <span class="comment">#忽略控制开关</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#设置可配置延时的设备（存在friendly_name信息）</span></span><br><span class="line">        entites = self.get_state()</span><br><span class="line">        zhPattern = re.compile(<span class="string">u&#x27;[\u4e00-\u9fa5]+&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> entity <span class="keyword">in</span> entites:</span><br><span class="line">            domain = entity.split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> entity <span class="keyword">in</span> self._exclude <span class="keyword">or</span> domain <span class="keyword">in</span> self._exclude <span class="keyword">or</span> domain <span class="keyword">not</span> <span class="keyword">in</span> self._domains:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                friendly_name = entites[entity].get(<span class="string">&#x27;attributes&#x27;</span>).get(<span class="string">&#x27;friendly_name&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line">                <span class="keyword">if</span> friendly_name <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line">                <span class="keyword">elif</span> <span class="keyword">not</span> self._should_zh <span class="keyword">or</span> zhPattern.search(friendly_name):</span><br><span class="line">                    self._dic_friendly_name.setdefault(friendly_name, entity)</span><br><span class="line">                    self._entities.setdefault(domain,&#123;&#125;).setdefault(entity,&#123;&#125;).setdefault(<span class="string">&#x27;friendly_name&#x27;</span>, friendly_name)</span><br><span class="line">                    self._entities[domain][entity][<span class="string">&#x27;id&#x27;</span>] = entity</span><br><span class="line">                    self._entities[domain][entity][<span class="string">&#x27;duration&#x27;</span>] = <span class="string">&#x27;0:00:00&#x27;</span></span><br><span class="line">                    self._entities[domain][entity][<span class="string">&#x27;remaining&#x27;</span>] = <span class="string">&#x27;0:00:00&#x27;</span></span><br><span class="line">                    self._entities[domain][entity][<span class="string">&#x27;handle&#x27;</span>] = <span class="literal">None</span></span><br><span class="line">                    self._entities[domain][entity][<span class="string">&#x27;opera&#x27;</span>] = <span class="string">&#x27;turn_on&#x27;</span> <span class="keyword">if</span> domain == <span class="string">&#x27;autonmation&#x27;</span> <span class="keyword">or</span> domain == <span class="string">&#x27;script&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;turn_off&#x27;</span>    <span class="comment">#设置默认操作</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.log(<span class="string">&quot;&#123;&#125;(&#123;&#125;):无中文，忽略&quot;</span>.format(friendly_name, entity))</span><br><span class="line"></span><br><span class="line">        options= list(self._entities.keys())</span><br><span class="line">        options.insert(<span class="number">0</span>,<span class="string">&#x27;请选择设备类型&#x27;</span>)</span><br><span class="line">        <span class="comment">#初始化下拉框</span></span><br><span class="line">        self.call_service(<span class="string">&#x27;input_select/set_options&#x27;</span>, entity_id = self._input_domain, options = options)</span><br><span class="line">        self.call_service(<span class="string">&#x27;input_select/set_options&#x27;</span>, entity_id = self._input_entity, options = <span class="string">&#x27;请选择设备&#x27;</span>)</span><br><span class="line">        self.select_option(self._input_domain, <span class="string">&#x27;请选择设备类型&#x27;</span>)</span><br><span class="line">        self.select_option(self._input_entity, <span class="string">&#x27;请选择设备&#x27;</span>)</span><br><span class="line">        <span class="comment">#下拉框改变联动</span></span><br><span class="line">        self.listen_state(self.choose_entity, self._input_entity)</span><br><span class="line">        self.listen_state(self.choose_domain, self._input_domain)</span><br><span class="line">        <span class="comment"># self.listen_state(self.choose_opera, self._input_opera)               #更改选项保存，否则只在开始执行脚本才保存</span></span><br><span class="line">        <span class="comment">#开关触发</span></span><br><span class="line">        self.listen_state(self.switch, self._switch)</span><br><span class="line">        <span class="comment">#环形延时队列处理以及刷新倒计时</span></span><br><span class="line">        handle = self.run_every(self.queue_task, datetime.now(), <span class="number">1</span>, hasTask=<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">queue_task</span>(<span class="params">self, kwargs</span>):</span></span><br><span class="line">        <span class="comment">#环形延时队列处理事务</span></span><br><span class="line">        self._queue.read()</span><br><span class="line">        <span class="comment">#刷新倒计时</span></span><br><span class="line">        <span class="keyword">if</span> self.get_state(self._switch) == <span class="string">&#x27;on&#x27;</span> <span class="keyword">and</span> self.get_state(self._input_entity) != <span class="string">&#x27;请选择设备&#x27;</span>:</span><br><span class="line">            domain = self.get_state(self._input_domain)</span><br><span class="line">            entity = self._dic_friendly_name.get(self.get_state(self._input_entity), <span class="literal">None</span>)</span><br><span class="line">            <span class="keyword">if</span> entity <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                self.log(<span class="string">&quot;Function task: friendly_name not found in dic !&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            remaining_time = self._queue.get_remaining_time(self._entities[domain][entity][<span class="string">&#x27;handle&#x27;</span>])</span><br><span class="line">            <span class="keyword">if</span> remaining_time <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                remaining_time = self._entities[domain][entity][<span class="string">&#x27;remaining&#x27;</span>]</span><br><span class="line">                <span class="keyword">if</span> remaining_time == <span class="string">&#x27;0:00:00&#x27;</span>:</span><br><span class="line">                    self.set_state(self._input_duration, state = self._entities[domain][entity][<span class="string">&#x27;duration&#x27;</span>])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.set_state(self._input_duration, state = remaining_time)</span><br><span class="line">                self.set_state(self._switch, state = <span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.set_state(self._input_duration, state = remaining_time)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">choose_domain</span>(<span class="params">self, entity, attribute, old, new, kwargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> new == <span class="string">&#x27;请选择设备类型&#x27;</span>:</span><br><span class="line">            options = <span class="string">&#x27;请选择设备&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            domain = new.split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">            options = [self._entities[domain][entity][<span class="string">&#x27;friendly_name&#x27;</span>] <span class="keyword">for</span> entity <span class="keyword">in</span> self._entities[domain] <span class="keyword">if</span> self._entities[domain][entity][<span class="string">&#x27;friendly_name&#x27;</span>] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>]</span><br><span class="line">            <span class="comment"># self.log(&#x27;加载设备列表：&#123;&#125;&#x27;.format(options))</span></span><br><span class="line">            options.insert(<span class="number">0</span>,<span class="string">&#x27;请选择设备&#x27;</span>)</span><br><span class="line">        self.call_service(<span class="string">&#x27;input_select/set_options&#x27;</span>, entity_id = self._input_entity, options = options)</span><br><span class="line">        self.select_option(self._input_entity, <span class="string">&#x27;请选择设备&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">choose_entity</span>(<span class="params">self, entity, attribute, old, new, kwargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> new == <span class="string">&#x27;请选择设备&#x27;</span>:</span><br><span class="line">            self.set_state(self._input_duration, state= <span class="string">&#x27;0:00:00&#x27;</span>)</span><br><span class="line">            self.set_state(self._switch, state = <span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:       <span class="comment">#加载entity的倒计时信息：先取remaining，否则取duration</span></span><br><span class="line">            entity = self._dic_friendly_name.get(new, <span class="literal">None</span>)</span><br><span class="line">            <span class="keyword">if</span> entity <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                self.log(<span class="string">&quot;Function choose_entity: friendly_name not found in dic !&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            domain = self.get_state(self._input_domain)</span><br><span class="line">            remaining_time = self._queue.get_remaining_time(self._entities[domain][entity][<span class="string">&#x27;handle&#x27;</span>])</span><br><span class="line">            <span class="keyword">if</span> remaining_time <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                duration = remaining_time</span><br><span class="line">                self.set_state(self._input_duration, state= duration)</span><br><span class="line">                self.set_state(self._switch, state = <span class="string">&#x27;on&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                duration = self._entities[domain][entity][<span class="string">&#x27;remaining&#x27;</span>] <span class="keyword">if</span> self._entities[domain][entity][<span class="string">&#x27;remaining&#x27;</span>] != <span class="string">&#x27;0:00:00&#x27;</span> <span class="keyword">else</span> self._entities[domain][entity][<span class="string">&#x27;duration&#x27;</span>]</span><br><span class="line">                self.set_state(self._input_duration, state= duration)</span><br><span class="line">                self.set_state(self._switch, state = <span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">            <span class="comment"># self.log(&quot;entity:&#123;&#125;,opera:&#123;&#125;&quot;.format(entity,self._entities[domain][entity][&#x27;opera&#x27;]))</span></span><br><span class="line">            self.select_option(self._input_opera, self._dic_opera.get(self._entities[domain][entity][<span class="string">&#x27;opera&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">choose_opera</span>(<span class="params">self, entity, attribute, old, new, kwargs</span>):</span></span><br><span class="line">        entity = self._dic_friendly_name.get(self.get_state(self._input_entity), <span class="literal">None</span>)</span><br><span class="line">        domain = entity.split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> domain <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.get_state(self._switch) == <span class="string">&#x27;off&#x27;</span>:            <span class="comment">#当前不执行任务才更新opera</span></span><br><span class="line">            self._entities[domain][entity][<span class="string">&#x27;opera&#x27;</span>] = self._dic_opera.get(new)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">switch</span>(<span class="params">self, entity, attribute, old, new, kwargs</span>):</span></span><br><span class="line">        domain = self.get_state(self._input_domain)</span><br><span class="line">        <span class="keyword">if</span> domain != <span class="string">&#x27;请选择设备类型&#x27;</span>:</span><br><span class="line">            entity = self._dic_friendly_name.get(self.get_state(self._input_entity), <span class="literal">None</span>)</span><br><span class="line">            <span class="keyword">if</span> entity <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                self.log(<span class="string">&quot;Function switch: friendly_name not found in dic !&quot;</span>)</span><br><span class="line">                self.set_state(self._switch, state = <span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> entity != <span class="string">&#x27;请选择设备&#x27;</span>:</span><br><span class="line">                duration = self.get_state(self._input_duration)</span><br><span class="line">                <span class="keyword">if</span> duration == <span class="string">&#x27;0:00:00&#x27;</span>:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">if</span> new == <span class="string">&#x27;on&#x27;</span>: <span class="comment">#开操作</span></span><br><span class="line">                    <span class="keyword">if</span> self._entities[domain][entity][<span class="string">&#x27;handle&#x27;</span>] <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                        <span class="keyword">if</span> self._entities[domain][entity][<span class="string">&#x27;remaining&#x27;</span>] != duration: <span class="comment">#倒计时剩余时间有修改，则重新设置倒计时时间</span></span><br><span class="line">                            self._entities[domain][entity][<span class="string">&#x27;duration&#x27;</span>] = duration</span><br><span class="line">                        opera = self._dic_opera.get(self.get_state(self._input_opera))</span><br><span class="line">                        self._entities[domain][entity][<span class="string">&#x27;handle&#x27;</span>] = self._queue.insert(entity, duration, self.handle_task, opera = opera)   <span class="comment">#队列增加任务</span></span><br><span class="line">                        self._entities[domain][entity][<span class="string">&#x27;opera&#x27;</span>] = opera             <span class="comment">#保存操作选项</span></span><br><span class="line">                <span class="keyword">else</span>:           <span class="comment">#关操作</span></span><br><span class="line">                    self._queue.remove(self._entities[domain][entity][<span class="string">&#x27;handle&#x27;</span>])</span><br><span class="line">                    self._entities[domain][entity][<span class="string">&#x27;handle&#x27;</span>] = <span class="literal">None</span></span><br><span class="line">                    self._entities[domain][entity][<span class="string">&#x27;remaining&#x27;</span>] = duration  <span class="comment">#记录倒计时剩余时间</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.log(<span class="string">&quot;未选设备&quot;</span>)</span><br><span class="line">                self.set_state(self._switch, state = <span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.log(<span class="string">&quot;未选设备类型&quot;</span>)</span><br><span class="line">            self.set_state(self._switch, state = <span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">    <span class="comment">#回调处理</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_task</span>(<span class="params">self, entity, opera, **kwargs</span>):</span></span><br><span class="line">        domain = entity.split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        self._entities[domain][entity][<span class="string">&#x27;handle&#x27;</span>] = <span class="literal">None</span></span><br><span class="line">        self._entities[domain][entity][<span class="string">&#x27;remaining&#x27;</span>] = <span class="string">&#x27;0:00:00&#x27;</span>             <span class="comment">#倒计时剩余时间置零</span></span><br><span class="line">        <span class="keyword">if</span> opera == <span class="string">&#x27;custom&#x27;</span>:</span><br><span class="line">            <span class="comment">#自定义处理方法</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            service_name = domain+<span class="string">&#x27;/&#x27;</span>+opera</span><br><span class="line">            self.call_service(service_name, entity_id=entity)</span><br><span class="line">            self.log(<span class="string">&quot;handle_task:&#123;&#125;(&#123;&#125;)&quot;</span>.format(service_name,entity))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasTask</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span>             <span class="comment">#注释掉的话，会根据是否有定时任务再启动队列处理，感觉然并卵所以还没测试</span></span><br><span class="line">        <span class="keyword">for</span> domain <span class="keyword">in</span> self._entities:</span><br><span class="line">            <span class="keyword">for</span> entity <span class="keyword">in</span> self._entities[domain]:</span><br><span class="line">                <span class="keyword">if</span> self._entities[domain][entity][<span class="string">&#x27;handle&#x27;</span>] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>DEBUG：大部分代码都是实现界面交互。</strong></p>
</blockquote>
</li>
<li><p>DelayQueue.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#&#123;appdaemon配置目录&#125;/apps/DelayQueue.py</span></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime,timedelta</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelayQueue</span>(<span class="params">object</span>):</span></span><br><span class="line">    __current_slot = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, slots_per_loop, app, **kwargs</span>):</span></span><br><span class="line">        self.__slots_per_loop = slots_per_loop</span><br><span class="line">        self.__queue = [[] <span class="keyword">for</span> i <span class="keyword">in</span> range(slots_per_loop)]</span><br><span class="line">        self.app = app</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, task_id, duration, callback, opera = <span class="string">&#x27;turn_off&#x27;</span>, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> duration == <span class="string">&quot;0:00:00&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        second = time_period_str(duration).total_seconds()</span><br><span class="line">        loop = second / len(self.__queue)</span><br><span class="line">        slot = (second + self.__current_slot - <span class="number">1</span>) % len(self.__queue)</span><br><span class="line">        delayQueueTask = DelayQueueTask(task_id, opera, int(slot), loop, callback, kwargs = kwargs)</span><br><span class="line">        self.__queue[delayQueueTask.slot].append(delayQueueTask)</span><br><span class="line">        self.app.log(<span class="string">&quot;create task:&#123;&#125;/&#123;&#125;&quot;</span>.format(delayQueueTask.slot, delayQueueTask.loop))</span><br><span class="line">        <span class="keyword">return</span> delayQueueTask</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self, delayQueueTask</span>):</span></span><br><span class="line">        <span class="comment"># self.app.log(&quot;remove task in slot &#123;&#125;&quot;.format(delayQueueTask.slot))</span></span><br><span class="line">        <span class="keyword">if</span> delayQueueTask <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.__queue[delayQueueTask.slot].remove(delayQueueTask)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_remaining_time</span>(<span class="params">self, delayQueueTask</span>):</span></span><br><span class="line">        <span class="keyword">if</span> delayQueueTask:</span><br><span class="line">            <span class="keyword">if</span> self.__current_slot - <span class="number">1</span> &gt; delayQueueTask.slot <span class="keyword">and</span> self.__current_slot - <span class="number">1</span> &lt; <span class="number">60</span>:</span><br><span class="line">                second = self.__slots_per_loop * (delayQueueTask.loop + <span class="number">1</span>) + delayQueueTask.slot - (self.__current_slot - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                second = self.__slots_per_loop * delayQueueTask.loop + delayQueueTask.slot - (self.__current_slot - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> str(timedelta(seconds = second))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> len(self.__queue) &gt;= self.__current_slot:</span><br><span class="line">            tasks = self.__queue[self.__current_slot - <span class="number">1</span>]</span><br><span class="line">            <span class="comment"># self.app.log(&quot;current slot：&#123;&#125;(has &#123;&#125; tasks)&quot;.format(self.__current_slot - 1,len(tasks)))</span></span><br><span class="line">            <span class="keyword">if</span> tasks:</span><br><span class="line">                executed_task = []</span><br><span class="line">                <span class="keyword">for</span> task <span class="keyword">in</span> tasks:</span><br><span class="line">                    <span class="comment"># self.app.log(&quot;task info:&#123;&#125;/&#123;&#125;,should_execute:&#123;&#125;&quot;.format(task.slot, task.loop, task.should_exec))</span></span><br><span class="line">                    <span class="keyword">if</span> task.should_exec:</span><br><span class="line">                        <span class="comment"># run</span></span><br><span class="line">                        task.exec_task()</span><br><span class="line">                        executed_task.append(task)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        task.nextLoop()</span><br><span class="line">                <span class="keyword">for</span> task <span class="keyword">in</span> executed_task:</span><br><span class="line">                    tasks.remove(task)</span><br><span class="line">            self.__current_slot += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.__current_slot &gt; len(self.__queue):</span><br><span class="line">                self.__current_slot = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelayQueueTask</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, task_id, opera:str = <span class="string">&#x27;turn_off&#x27;</span>, slot:int = <span class="number">0</span> , loop:int = <span class="number">0</span> , exec_task = None, **kwargs</span>):</span></span><br><span class="line">        self._task_id = task_id</span><br><span class="line">        self._opera = opera</span><br><span class="line">        self._slot = int(slot)</span><br><span class="line">        self._loop = int(loop)</span><br><span class="line">        self._exec_task = exec_task</span><br><span class="line">        self._kwargs = kwargs</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">slot</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> int(self._slot)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loop</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> int(self._loop)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">task_id</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._task_id</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">opera</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._opera</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextLoop</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._loop -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">should_exec</span>(<span class="params">self</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> self._loop == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># @callback</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exec_task</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._exec_task(self._task_id, self._opera, kwargs = self._kwargs)</span><br><span class="line">        </span><br><span class="line"><span class="comment">#copy from HA</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">time_period_str</span>(<span class="params">value: str</span>) -&gt; timedelta:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Validate and transform time offset.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(value, int):</span><br><span class="line">        <span class="keyword">raise</span> vol.Invalid(<span class="string">&#x27;Make sure you wrap time values in quotes&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> <span class="keyword">not</span> isinstance(value, str):</span><br><span class="line">        <span class="keyword">raise</span> vol.Invalid(TIME_PERIOD_ERROR.format(value))</span><br><span class="line"></span><br><span class="line">    negative_offset = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> value.startswith(<span class="string">&#x27;-&#x27;</span>):</span><br><span class="line">        negative_offset = <span class="literal">True</span></span><br><span class="line">        value = value[<span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">elif</span> value.startswith(<span class="string">&#x27;+&#x27;</span>):</span><br><span class="line">        value = value[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        parsed = [int(x) <span class="keyword">for</span> x <span class="keyword">in</span> value.split(<span class="string">&#x27;:&#x27;</span>)]</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="keyword">raise</span> vol.Invalid(TIME_PERIOD_ERROR.format(value))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> len(parsed) == <span class="number">2</span>:</span><br><span class="line">        hour, minute = parsed</span><br><span class="line">        second = <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> len(parsed) == <span class="number">3</span>:</span><br><span class="line">        hour, minute, second = parsed</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> vol.Invalid(TIME_PERIOD_ERROR.format(value))</span><br><span class="line"></span><br><span class="line">    offset = timedelta(hours=hour, minutes=minute, seconds=second)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> negative_offset:</span><br><span class="line">        offset *= <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> offset</span><br></pre></td></tr></table></figure>
<blockquote>
<p>__DEBUG：需要另外一个定时器方法进行周期性调用才能工作，用了Appdaemon的run_every()方法。__</p>
</blockquote>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>Home Assistant</category>
      </categories>
      <tags>
        <tag>Home Assistant</tag>
        <tag>插件</tag>
        <tag>Appdaemon</tag>
        <tag>定时器</tag>
      </tags>
  </entry>
  <entry>
    <title>【插件】智能音箱接入Home Assistant整合</title>
    <url>/articles/plugin-integration-of-smart-speakers-into-home-assistant/</url>
    <content><![CDATA[<p>前情回顾：年前折腾的<a href="https://ljr.im/articles/flip-car-series-smart-speaker-universal-access-platform/" title="【翻车系列】智能音箱通用接入平台">通用智能音箱接入平台</a>因音箱技能类型限制不过审翻车了，然后将项目成果整理做了个<a href="https://ljr.im/articles/plugin-mqtt-relay-to-achieve-smart-speaker-access-home-assistant/" title="【插件】MQTT中转实现智能音箱接入Home Assistant">智能音箱mqtt代理转发插件</a>。考虑到易用性，趁着过年闲着，于是折腾了下各个平台的智能家居类型技能对接，最终成果就是这么一个整合版插件了。</p>
<hr>
<a id="more"></a>
<h2 id="0-更新"><a href="#0-更新" class="headerlink" title="0.更新"></a>0.更新</h2><p><font color = "red">新版本插件已发布并更名为havcs（<a href="https://ljr.im/articles/plugin-smart-speaker-access-home-assistant-integration-plus/" title="【插件】智能音箱接入Home Assistant整合Plus">传送门</a>），主要变更了设备配置方式，其它部分内容基本仍适用，建议先粗略观看完此版本内容再移步观看新版本。</font></p>
<h2 id="1-插件说明"><a href="#1-插件说明" class="headerlink" title="1.插件说明"></a>1.插件说明</h2><p><strong>本插件实际上由两大功能模块组成：</strong></p>
<ul>
<li><p>MQTT对接服务</p>
<p>配合本人搭建的mqtt中转服务，可以将音箱云平台的音箱命令消息、oauth消息转发到无公网环境下家中的Home Assistant。</p>
</li>
<li><p>音箱组件</p>
<p>即智能音箱本地网关插件，对音箱云平台的音箱命令消息进行解析、处理，可以初始化为HTTP网关服务与音箱云平台直接对接。</p>
</li>
</ul>
<p><strong>有三种使用模式，适合不同场景的接入：</strong></p>
<ul>
<li><p>模式一 http模式</p>
<ul>
<li>生成音箱http网关，通过<code>自建测试技能</code>接入</li>
<li>适合<code>家庭宽带有公网ip或已实现内网穿透</code>场景下使用</li>
<li><strong>建议有条件都用这个，留服务资源给有需要的人</strong></li>
</ul>
<img src="/articles/plugin-integration-of-smart-speakers-into-home-assistant/mode1.svg" class="" title="[模式一示意图]">
</li>
<li><p>模式二 http proxy模式</p>
<ul>
<li>生成音箱http网关，同时使用mqtt代理穿透内网访问，通过<code>自建测试技能</code>接入</li>
<li>适合<code>家庭宽带无公网ip</code>场景下使用</li>
<li><strong>临时提供，视服务资源情况会停止</strong></li>
</ul>
<img src="/articles/plugin-integration-of-smart-speakers-into-home-assistant/mode2.svg" class="" title="[模式二示意图]">
</li>
<li><p>模式三 skill模式</p>
<ul>
<li>通过<code>官方音箱APP技能</code>接入，目前技能已<del>暂未</del>上线 <del>（也许没法上线）</del></li>
<li>适合<code>无公网</code>、<code>省事</code>场景使用</li>
<li><strong>服务资源有限不能保证稳定</strong></li>
</ul>
<img src="/articles/plugin-integration-of-smart-speakers-into-home-assistant/mode3.svg" class="" title="[模式三示意图]"></li>
<li><p>各模式难度指数</p>
<p>模式一：★★★★☆</p>
<p>模式二：★★☆☆☆</p>
<p>模式三：★☆☆☆☆</p>
</li>
</ul>
<blockquote>
<p><strong>INFO：不同模式的配置方法见3.3HA插件配置章节。</strong></p>
</blockquote>
<p><strong>智能音箱组件说明</strong></p>
<ul>
<li>天猫精灵插件基于瀚思彼岸论坛<a href="https://bbs.hassbian.com/thread-4758-1-1.html" title="天猫精灵音箱插件">@feversky</a>的插件修改</li>
<li>小度音箱插件基于瀚思彼岸论坛<a href="https://bbs.hassbian.com/thread-5417-1-1.html" title="小度音箱插件">@zhkufish</a>的插件修改</li>
<li>叮咚音箱插件参考前两个插件编写</li>
</ul>
<p><strong><del>aihome</del>HAVCS线上服务劝退警告</strong></p>
<ul>
<li><del>aihome</del>HAVCS线上服务（指模式二、三的mqtt中转服务及APP技能）可以实现叮咚音箱、天猫精灵、小度音箱接入Home Assistant（免公网IP），语音控制家中设备。线上服务主要目的在于测试、学习、交流，受限于个人能力，无法保证提供完善服务，并且使用线上服务有一定的风险，介意者建议另行部署自用的环境对接智能音箱平台。</li>
<li>隐私安全<ul>
<li>为解决无公网IP的家庭宽带环境下使用的痛点，线上服务采用mqtt中转的技术方案，该方案下控制消息需经个人服务器转发，存在被本人监控、冒充控制消息的风险。</li>
<li>mqtt中转模式下已采用了消息隔离、消息加密、设备entity_id加密等方式对用户的控制消息进行安全保障，但仍可能存在本人没考虑全面的安全风险。</li>
</ul>
</li>
<li>服务质量<ul>
<li>只能尽个人最大能力保证，毕竟存在不可抗力自然因素、断电、断网、服务器宕机、本人偷懒等诸多不可控风险。</li>
<li>如果不幸本人跑路，因为相关设备信息（设备个性化配置）只保留在本地，你仍可以自行部署自用环境对接智能音箱平台继续使用。</li>
</ul>
</li>
<li>服务支持<ul>
<li>本服务实质上只提供便捷接入途径，后续仍要对设备信息进行个性化配置，需要对各家音箱平台的控制指令有一定了解。</li>
<li>使用本服务上手有一定难度，建议心平气和慢慢熟悉，遇到问题可加QQ群寻求帮助。</li>
<li>因个人时间有限，只侧重支撑解决使用mqtt中转服务和使用插件遇到的问题；部署自用环境对接方面问题请自行查阅厂家技能开放平台文档。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-完成度"><a href="#2-完成度" class="headerlink" title="2.完成度"></a>2.完成度</h2><p><strong>控制指令</strong></p>
<ul>
<li>灯、开关类型设备的开/关（小度音箱可延时）</li>
<li>电源状态、温度、湿度等状态查询</li>
</ul>
<blockquote>
<p><strong>INFO：能用的控制指令实际上与各智能音箱组件对音箱平台预设功能指令的支持度有关，因各个音箱平台有差异，无法一一描述，只能先列举叮咚音箱组件下目前个人已测试的功能。</strong></p>
</blockquote>
<p><strong>平台适配进展</strong></p>
<ul>
<li>天猫精灵：支持，音箱APP已上线技能（“<del>aihome智能</del>HAVCS”）</li>
<li>小度：支持，音箱APP已上线技能（“<del>aihome</del>HAVCS”）</li>
<li>叮咚：支持，音箱APP已上线技能（“<del>aihome</del>HAVCS”）</li>
<li>echo：看情况（等支持中文。。。）</li>
<li>小爱：计划外（手持身份证验证+商用要求劝退）</li>
<li>有其它音箱接入需求可以反馈我研究下</li>
</ul>
<p><strong>高能提醒</strong></p>
<ul>
<li>设备配置各个音箱平台会有一些出入，需要一定耐心熟悉上手</li>
<li>多用户使用场景没有条件测试，估计有不少bug</li>
<li>多用户并发下服务器处理性能及带宽可能有瓶颈问题</li>
</ul>
<hr>
<h2 id="3-使用说明"><a href="#3-使用说明" class="headerlink" title="3.使用说明"></a>3.使用说明</h2><h3 id="3-0-准备"><a href="#3-0-准备" class="headerlink" title="3.0.准备"></a>3.0.准备</h3><ul>
<li>下载插件：<a href="https://github.com/cnk700i/havcs" title="aihome插件下载">aihome</a><font color = "red">（新版本插件名称已更名为havcs，旧版本在github项目release页面下载）</font></li>
<li>确认采取哪种模式接入</li>
</ul>
<h3 id="3-1-获取账号"><a href="#3-1-获取账号" class="headerlink" title="3.1.获取账号"></a>3.1.获取账号</h3><p><code>注：模式一跳过此步骤</code></p>
<p>打开<a href="https://ai-home.ljr.im/account/" title="aihome插件账号获取页面">账号获取页面</a>，获取AppKey和AppSecret</p>
<blockquote>
<p><strong>INFO：模式三需要注册用户登陆；模式二可以不登陆（暂时）。</strong></p>
</blockquote>
<h3 id="3-2-音箱技能平台配置"><a href="#3-2-音箱技能平台配置" class="headerlink" title="3.2.音箱技能平台配置"></a>3.2.音箱技能平台配置</h3><p><code>注：模式三跳过此步骤</code><br>启用模式一或模式二，会生成服务网关（不分音箱平台），访问uri为<code>/aihome_service</code>。</p>
<ul>
<li>模式一<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#前往厂家的音箱技能平台进行设置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#授权地址</span></span><br><span class="line">https://&#123;你的域名&#125;/auth/authorize</span><br><span class="line"><span class="comment">#Client_Id，回调地址域名那一串即可</span></span><br><span class="line">小度：https://xiaodu.baidu.com</span><br><span class="line">天猫：https://open.bot.tmall.com</span><br><span class="line"><span class="comment">#Token地址</span></span><br><span class="line">https://&#123;你的域名&#125;/aihome_auth</span><br><span class="line"><span class="comment">#WebService（服务网关）地址</span></span><br><span class="line">https://&#123;你的域名&#125;/aihome_service</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：需要自己解决域名访问问题，建议观看天猫精灵、小度音箱原版插件的教程。</strong></p>
</blockquote>
</li>
<li>模式二<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#前往厂家的音箱技能平台进行设置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#授权地址（授权操作只能使用本地电脑）</span></span><br><span class="line">https://&#123;本地HA访问地址&#125;/auth/authorize</span><br><span class="line"><span class="comment">#Client_Id，回调地址域名那一串即可</span></span><br><span class="line">小度：https://xiaodu.baidu.com</span><br><span class="line">天猫：https://open.bot.tmall.com</span><br><span class="line"><span class="comment">#Token地址（代理地址）</span></span><br><span class="line">https://ai-home.ljr.im/h2m2h/&#123;app_key&#125;/aihome_auth</span><br><span class="line"><span class="comment">#WebService（服务网关）地址（代理地址）</span></span><br><span class="line">https://ai-home.ljr.im/h2m2h/&#123;app_key&#125;/aihome_service</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：{本地HA访问地址}、{app_key}替换成相应的字符串。__<br>__INFO：目前叮咚技能需要联系工作人员审核后才能绑定到指定音箱，另外client_id格式不能填写”https://“（HA的oauth格式要求），需要自行修改HA对应组件代码解决。</strong></p>
</blockquote>
</li>
</ul>
<h3 id="3-3-HA插件配置"><a href="#3-3-HA插件配置" class="headerlink" title="3.3.HA插件配置"></a>3.3.HA插件配置</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#&#123;HA配置目录&#125;/configuration.yaml                 </span></span><br><span class="line"><span class="attr">aihome:</span></span><br><span class="line">  <span class="comment"># 启用音箱平台，至少启用一个</span></span><br><span class="line">  <span class="attr">platform:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">aligenie</span>                            <span class="comment"># 天猫精灵</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">dueros</span>                              <span class="comment"># 小度</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">jdwhale</span>                             <span class="comment"># 叮咚</span></span><br><span class="line">  <span class="comment"># http服务网关，&gt;&gt;模式一、模式二启用&lt;&lt;</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">    <span class="comment"># ha_url: https://localhost:8123      # HA所在主机/容器IP地址，不设置则默认识别</span></span><br><span class="line">    <span class="comment"># expire_in_hours: 24                 # token超时时间，单位小时，不设置则默认24h</span></span><br><span class="line">  <span class="comment"># http代理服务，用于穿透内网，&gt;&gt;模式二启用&lt;&lt;</span></span><br><span class="line">  <span class="attr">http_proxy:</span></span><br><span class="line">    <span class="comment"># ha_url: https://localhost:8123      # HA所在主机/容器IP地址，不设置则默认识别</span></span><br><span class="line">    <span class="comment"># allowed_uri:                        # http请求白名单，不设置则默认[&#x27;/aihome_auth&#x27;, &#x27;/aihome_service&#x27;]</span></span><br><span class="line">    <span class="comment">#   - /aihome_auth</span></span><br><span class="line">    <span class="comment">#   - /aihome_service</span></span><br><span class="line">  <span class="comment"># APP技能服务，&gt;&gt;模式三启用&lt;&lt;</span></span><br><span class="line">  <span class="attr">skill:</span></span><br><span class="line">    <span class="comment"># sync: False                         # 是否主动上报设备状态，不设置则默认False不上报（小度音箱才有效）</span></span><br><span class="line">  <span class="comment"># mqtt相关设置，启用http代理服务及APP技能服务才生效</span></span><br><span class="line">  <span class="attr">setting:</span></span><br><span class="line">    <span class="attr">app_key:</span> &#123;&#123;<span class="string">your_app_key</span>&#125;&#125;             <span class="comment"># 必填，https://ai-home.ljr.im/account/获取</span></span><br><span class="line">    <span class="attr">app_secret:</span> &#123;&#123;<span class="string">your_app_secret</span>&#125;&#125;       <span class="comment"># 必填，https://ai-home.ljr.im/account/获取</span></span><br><span class="line">    <span class="attr">entity_key:</span> &#123;&#123;<span class="string">your_entity_key</span>&#125;&#125;       <span class="comment"># 必填，加密entity_id的key，自定义16个字符</span></span><br></pre></td></tr></table></figure>


<h3 id="3-4-HA设备个性化配置（绑定设备）"><a href="#3-4-HA设备个性化配置（绑定设备）" class="headerlink" title="3.4.HA设备个性化配置（绑定设备）"></a>3.4.HA设备个性化配置（绑定设备）</h3><p>音箱云平台的设备与HA的设备属性字段有出入，HA中需要使用个性化配置文件（customize.yaml）补充额外的属性，使得音箱云平台可以识别、绑定设备。虽然音箱插件会尝试根据设备类型、设备名称进行自动补充，但目前准确率仍不高，建议还是尽量手动指定。</p>
<h4 id="3-4-1-整体配置框架"><a href="#3-4-1-整体配置框架" class="headerlink" title="3.4.1.整体配置框架"></a>3.4.1.整体配置框架</h4><p>以接入一个灯类设备、传感器类设备为例，会涉及几个大块配置。</p>
<ul>
<li><p>方法1 分散文件配置方式</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#&#123;HA配置目录&#125;/customize.yaml，&gt;设备个性化配置&lt;</span></span><br><span class="line"><span class="attr">light.demo:</span> <span class="comment"># 接入音箱平台的灯（一般设备配置属性即可）</span></span><br><span class="line">  <span class="string">属性1:</span></span><br><span class="line">  <span class="string">属性2:</span></span><br><span class="line"><span class="attr">sensor.livingroom:</span> <span class="comment"># 接入音箱平台的传感器（虚拟创建的）</span></span><br><span class="line">  <span class="string">属性1:</span></span><br><span class="line">  <span class="string">属性2:</span></span><br><span class="line"><span class="attr">sensor.temperature:</span> <span class="comment"># 虚拟传感器关联的真实传感器设备（作为一种参数查询，如温度）</span></span><br><span class="line">  <span class="string">属性1:</span></span><br><span class="line"><span class="attr">sensor.humidity:</span> <span class="comment"># 虚拟传感器关联的真实传感器设备（作为一种参数查询，如湿度）</span></span><br><span class="line">  <span class="string">属性1:</span></span><br><span class="line"><span class="comment">#&#123;HA配置目录&#125;/configuration.yaml，虚拟传感器</span></span><br><span class="line"><span class="attr">sensor:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">platform:</span> <span class="string">template</span></span><br><span class="line">  <span class="attr">sensors:</span></span><br><span class="line">    <span class="attr">livingroom:</span> <span class="comment"># 新增虚拟传感器设备，该设备在音箱云平台展示</span></span><br><span class="line">      <span class="attr">value_template:</span> <span class="string">&quot;客厅环境&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&#123;HA配置目录&#125;/group.yaml，虚拟传感器关联的传感器类分组</span></span><br><span class="line"><span class="attr">livingroom_sensors:</span></span><br><span class="line">  <span class="attr">view:</span> <span class="literal">no</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">&#x27;客厅传感器列表&#x27;</span></span><br><span class="line">  <span class="attr">control:</span> <span class="string">hidden</span></span><br><span class="line">  <span class="attr">entities:</span> <span class="comment"># 真实传感器列表，真实传感器配置过程省略</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">sensor.temperature</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">sensor.humidity</span></span><br></pre></td></tr></table></figure></li>
<li><p>方法2 统一文件配置方式（建议）</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#编辑&#123;HA配置目录&#125;/configuration.yaml，引入packages目录</span></span><br><span class="line"><span class="attr">homeassistant:</span></span><br><span class="line">  <span class="attr">packages:</span> <span class="type">!include_dir_named</span> <span class="string">packages</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#编辑&#123;HA配置目录&#125;/packages/自定义名称.yaml， 增加设备个性化配置、新增虚拟传感器、传感器分组等信息</span></span><br><span class="line"><span class="attr">homeassistant:</span></span><br><span class="line">  <span class="attr">customize:</span> <span class="comment"># &gt;设备个性化配置&lt;</span></span><br><span class="line">    <span class="attr">light.demo:</span> <span class="comment"># 接入音箱平台的灯（一般设备配置属性即可）</span></span><br><span class="line">      <span class="string">属性1:</span></span><br><span class="line">      <span class="string">属性2:</span></span><br><span class="line">    <span class="attr">sensor.livingroom:</span> <span class="comment"># 接入音箱平台的传感器（虚拟创建的）</span></span><br><span class="line">      <span class="string">属性1:</span></span><br><span class="line">      <span class="string">属性2:</span></span><br><span class="line">    <span class="attr">sensor.temperature:</span> <span class="comment"># 虚拟传感器关联的真实传感器设备（作为一种参数查询，如温度）</span></span><br><span class="line">      <span class="string">属性1:</span></span><br><span class="line">    <span class="attr">sensor.humidity:</span> <span class="comment"># 虚拟传感器关联的真实传感器设备（作为一种参数查询，如湿度）</span></span><br><span class="line">      <span class="string">属性1:</span></span><br><span class="line"><span class="attr">group:</span> <span class="comment"># 虚拟传感器关联的传感器类分组</span></span><br><span class="line">  <span class="attr">livingroom_sensors:</span></span><br><span class="line">    <span class="attr">view:</span> <span class="literal">no</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">&#x27;客厅传感器列表&#x27;</span></span><br><span class="line">    <span class="attr">control:</span> <span class="string">hidden</span></span><br><span class="line">    <span class="attr">entities:</span>  <span class="comment"># 真实传感器列表，真实传感器配置过程省略</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">sensor.temperature</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">sensor.humidity</span></span><br><span class="line"><span class="attr">sensor:</span> <span class="comment"># 虚拟传感器</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">platform:</span> <span class="string">template</span></span><br><span class="line">  <span class="attr">sensors:</span></span><br><span class="line">    <span class="attr">livingroom:</span> <span class="comment"># 新增虚拟传感器设备，该设备在音箱云平台展示</span></span><br><span class="line">      <span class="attr">value_template:</span> <span class="string">&quot;客厅环境&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-2-设备个性化配置属性"><a href="#3-4-2-设备个性化配置属性" class="headerlink" title="3.4.2.设备个性化配置属性"></a>3.4.2.设备个性化配置属性</h4><p>使用官方自带的customize组件（{HA配置目录}/customize.yaml中配置）为HA的设备增加相关属性，音箱插件根据属性信息生成音箱平台可识别的设备。在3.4.1章节<code>&gt;设备个性化配置&lt;</code>部分，可以为指定的HA设备（entity_id）增加相关的属性。</p>
</li>
<li><p>通用</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定的设备可被发现，上报设备数据</span></span><br><span class="line"><span class="attr">aihome_device:</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></li>
<li><p>传感器专用</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 虚拟传感器，关联真实传感器分组，详细用法见传感器类设备配置说明</span></span><br><span class="line"><span class="attr">aihome_sensor_group:</span> <span class="string">group.livingroom_sensors</span></span><br><span class="line"><span class="comment"># 真实传感器标识，对传感器分组特定的传感器进行上报，详细用法见传感器类设备配置说明</span></span><br><span class="line"><span class="attr">aihome_sensor:</span> <span class="literal">True</span> <span class="comment"># 不需要再设置aihome_device</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>叮咚音箱</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设备类型，不设置则尝试自动生成</span></span><br><span class="line"><span class="attr">jdwhale_deviceType:</span> <span class="string">&#x27;LIGHT&#x27;</span></span><br><span class="line"><span class="comment"># 设备支持操作，不设置则尝试自动生成</span></span><br><span class="line"><span class="attr">jdwhale_actions:</span> [<span class="string">&#x27;TurnOn&#x27;</span>, <span class="string">&#x27;TurnOff&#x27;</span>, <span class="string">&#x27;Query&#x27;</span>]</span><br></pre></td></tr></table></figure></li>
<li><p>天猫精灵</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设备别名（设备类型限定设备别名可取值）</span></span><br><span class="line"><span class="attr">aligenie_deviceName:</span> <span class="string">灯</span></span><br><span class="line"><span class="comment"># 设备位置，不设置则尝试自动生成</span></span><br><span class="line"><span class="attr">aligenie_zone:</span> <span class="string">主卧</span></span><br><span class="line"><span class="comment"># 设备类型，不设置则尝试自动生成</span></span><br><span class="line"><span class="attr">aligenie_deviceType:</span> <span class="string">&#x27;light&#x27;</span></span><br><span class="line"><span class="comment"># 设备支持操作，不设置则尝试自动生成</span></span><br><span class="line"><span class="attr">aligenie_actions:</span> [<span class="string">&quot;TurnOn&quot;</span>, <span class="string">&quot;TurnOff&quot;</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>小度音箱</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设备类型，不设置则尝试自动生成</span></span><br><span class="line"><span class="attr">dueros_deviceType:</span> <span class="string">&#x27;LIGHT&#x27;</span></span><br><span class="line"><span class="comment"># 设备支持操作，不设置则尝试自动生成</span></span><br><span class="line"><span class="attr">dueros_actions:</span> [<span class="string">&#x27;turnOn&#x27;</span>, <span class="string">&#x27;turnOff&#x27;</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：音箱的设备类型、支持的操作建议去官网看相应智能家居技能文档，无法一一详述。</strong></p>
</blockquote>
</li>
</ul>
<h4 id="3-4-3-特殊设备配置说明"><a href="#3-4-3-特殊设备配置说明" class="headerlink" title="3.4.3.特殊设备配置说明"></a>3.4.3.特殊设备配置说明</h4><ul>
<li><p>传感器类设备配置</p>
<p>HA中，一个传感器设备只有一种数据，而音箱云平台可以对设备查询多种属性，因此需要虚拟一个新的传感器设备整合多个真实传感器数据。</p>
<ol>
<li>环境类传感器先集中到一个分组<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#&#123;HA配置目录&#125;/group.yaml，虚拟传感器关联的传感器类分组</span></span><br><span class="line"><span class="attr">livingroom_sensors:</span></span><br><span class="line">  <span class="attr">view:</span> <span class="literal">no</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">&#x27;客厅传感器列表&#x27;</span></span><br><span class="line">  <span class="attr">control:</span> <span class="string">hidden</span></span><br><span class="line">  <span class="attr">entities:</span> <span class="comment"># 真实传感器列表</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">sensor.temperature</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">sensor.humidity</span></span><br></pre></td></tr></table></figure></li>
<li>新增一个虚拟的sensor（使用官方sensor组件template生成即可）<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#&#123;HA配置目录&#125;/configuration.yaml，虚拟传感器</span></span><br><span class="line"><span class="attr">sensor:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">platform:</span> <span class="string">template</span></span><br><span class="line">    <span class="attr">sensors:</span></span><br><span class="line">      <span class="attr">livingroom:</span> <span class="comment"># 新增虚拟传感器设备，该设备在音箱云平台展示</span></span><br><span class="line">        <span class="attr">value_template:</span> <span class="string">&quot;客厅环境&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>自定义虚拟sensor的属性，关联传感器分组<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#&#123;HA配置目录&#125;/customize.yaml，设备个性化配置</span></span><br><span class="line"></span><br><span class="line"><span class="attr">sensor.livingroom:</span></span><br><span class="line">  <span class="attr">aihome_device:</span> <span class="literal">True</span>     <span class="comment"># 上报设备</span></span><br><span class="line">  <span class="attr">friendly_name:</span> <span class="string">客厅传感器</span></span><br><span class="line">  <span class="attr">aihome_sensor_group:</span> <span class="string">group.livingroom_sensors</span> <span class="comment"># 关联真实传感器分组</span></span><br><span class="line">  <span class="attr">jdwhale_actions:</span> [<span class="string">&#x27;Query&#x27;</span>, <span class="string">&#x27;QueryTemperature&#x27;</span>, <span class="string">&#x27;QueryHumidity&#x27;</span>] <span class="comment"># 叮咚平台设置，需根据真实传感器及音箱平台支持的类型设置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 真实传感器设置aihome_sensor属性</span></span><br><span class="line"><span class="attr">sensor.temperature:</span></span><br><span class="line">  <span class="attr">aihome_sensor:</span> <span class="literal">True</span> <span class="comment"># 上报传感器数据，注意不参与直接上报，不需要再设置aihome_device</span></span><br><span class="line"><span class="attr">sensor.humidity:</span></span><br><span class="line">  <span class="attr">aihome_sensor:</span> <span class="literal">True</span> <span class="comment"># 上报传感器数据，注意不参与直接上报，不需要再设置aihome_device</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：建议虚拟sensor的名称命名为“{房间名}传感器”，各个平台的识别执行成功率比较高。</strong></p>
</blockquote>
</li>
</ol>
</li>
</ul>
<blockquote>
<p><strong>INFO：原天猫精灵插件根据zone组合传感器，原小度插件没有实现相应查询功能，于是对查询方法进行了统一。</strong></p>
</blockquote>
<ul>
<li><p>直接调service类设备配置说明</p>
<p>可以手动指定调用服务命令，效果和新建简单脚本再调用类似。</p>
<ol>
<li>新增一个input_boolean<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#&#123;HA配置目录&#125;/configuration.yaml</span></span><br><span class="line"><span class="attr">input_boolean:</span></span><br><span class="line">  <span class="attr">call_service:</span></span><br></pre></td></tr></table></figure></li>
<li>自定义虚拟input_boolean的属性，在aihome_actions属性中设置对应的service指令（只能设置turn_on/turn_off/increase_brightness/decrease_brightness，对应打开/关闭/调高亮度/调低亮度指令）<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#&#123;HA配置目录&#125;/customize.yaml</span></span><br><span class="line">  <span class="attr">input_boolean.call_service:</span>  </span><br><span class="line">    <span class="attr">friendly_name:</span> <span class="string">定时充电</span></span><br><span class="line">    <span class="comment">#↓↓↓该部分根据使用的音箱精简↓↓↓</span></span><br><span class="line">    <span class="attr">aihome_device:</span> <span class="literal">True</span></span><br><span class="line">    <span class="attr">aligenie_deviceName:</span> <span class="string">开关</span></span><br><span class="line">    <span class="attr">aligenie_zone:</span> <span class="string">主卧</span></span><br><span class="line">    <span class="attr">aligenie_deviceType:</span> <span class="string">switch</span></span><br><span class="line">    <span class="comment"># aligenie_actions: [&quot;TurnOn&quot;, &quot;TurnOff&quot;]  # 新版本已可根据aihome_actions自动识别</span></span><br><span class="line">    <span class="attr">dueros_deviceType:</span> <span class="string">&#x27;SWITCH&#x27;</span></span><br><span class="line">    <span class="comment"># dueros_actions: [&#x27;turnOn&#x27;, &#x27;turnOff&#x27;]    # 新版本已可根据aihome_actions自动识别</span></span><br><span class="line">    <span class="attr">jdwhale_deviceType:</span> <span class="string">&#x27;SWITCH&#x27;</span></span><br><span class="line">    <span class="comment"># jdwhale_actions: [&#x27;TurnOn&#x27;, &#x27;TurnOff&#x27;]   # 新版本已可根据aihome_actions自动识别</span></span><br><span class="line">    <span class="comment">#↑↑↑该部分根据使用的音箱精简↑↑↑</span></span><br><span class="line">    <span class="comment">#↓↓↓指令根据实际需要配置↓↓↓</span></span><br><span class="line">    <span class="attr">aihome_actions:</span></span><br><span class="line">        <span class="comment"># service指令格式:[domain, service_name, service_data（json字符串）]，具体内容需参见相应组件的服务定义。</span></span><br><span class="line">        <span class="comment"># 注意，参数变更为数组以支持多条指令，单条指令也别忘了加-</span></span><br><span class="line">        <span class="attr">turn_on:</span></span><br><span class="line">          <span class="bullet">-</span> [<span class="string">&#x27;common_timer&#x27;</span>, <span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;&#123;&quot;entity_id&quot;:&quot;switch.demo&quot;,&quot;duration&quot;:&quot;01:00:00&quot;,&quot;operation&quot;:&quot;off&quot;&#125;&#x27;</span>] <span class="comment"># 打开命令</span></span><br><span class="line">          <span class="bullet">-</span> [<span class="string">&#x27;input_boolean&#x27;</span>, <span class="string">&#x27;turn_on&#x27;</span>, <span class="string">&#x27;&#123;&#125;&#x27;</span>] <span class="comment"># 同步打开状态</span></span><br><span class="line">        <span class="attr">turn_off:</span></span><br><span class="line">          <span class="bullet">-</span> [<span class="string">&#x27;common_timer&#x27;</span>, <span class="string">&#x27;cancel&#x27;</span>, <span class="string">&#x27;&#123;&quot;entity_id&quot;:&quot;switch.demo&quot;&#125;&#x27;</span>] <span class="comment"># 关闭命令</span></span><br><span class="line">          <span class="bullet">-</span> [<span class="string">&#x27;input_boolean&#x27;</span>, <span class="string">&#x27;turn_off&#x27;</span>, <span class="string">&#x27;&#123;&#125;&#x27;</span>] <span class="comment"># 同步关闭状态</span></span><br><span class="line">        <span class="attr">increase_brightness:</span></span><br><span class="line">          <span class="bullet">-</span> [<span class="string">&#x27;指令1&#x27;</span>]</span><br><span class="line">          <span class="bullet">-</span> [<span class="string">&#x27;指令2&#x27;</span>]</span><br><span class="line">        <span class="attr">decrease_brightness:</span></span><br><span class="line">          <span class="bullet">-</span> [<span class="string">&#x27;指令1&#x27;</span>]</span><br><span class="line">          <span class="bullet">-</span> [<span class="string">&#x27;指令2&#x27;</span>]</span><br><span class="line">        <span class="attr">timing_turn_on:</span> <span class="comment"># 延时打开指令（小度音箱）</span></span><br><span class="line">          <span class="bullet">-</span> [<span class="string">&#x27;指令1&#x27;</span>]</span><br><span class="line">          <span class="bullet">-</span> [<span class="string">&#x27;指令2&#x27;</span>]</span><br><span class="line">        <span class="attr">timing_turn_off:</span> <span class="comment"># 延时关闭指令（小度音箱）</span></span><br><span class="line">          <span class="bullet">-</span> [<span class="string">&#x27;指令1&#x27;</span>]</span><br><span class="line">          <span class="bullet">-</span> [<span class="string">&#x27;指令2&#x27;</span>] </span><br></pre></td></tr></table></figure>
<blockquote>
<p>__INFO：调自动化(automation.turn_on)、调脚本(scrpit.turn_on)、调红外指令(climate.xiaomi_miio_send_command)等会比较适合。__</p>
</blockquote>
</li>
</ol>
<blockquote>
<p><strong>INFO：天猫精灵无法自定义名称，不太适合使用。</strong></p>
</blockquote>
</li>
</ul>
<h4 id="3-4-4-配置样例"><a href="#3-4-4-配置样例" class="headerlink" title="3.4.4.配置样例"></a>3.4.4.配置样例</h4><p>采用统一文件配置方式，引入packages目录及即可测试，引入方法见3.4.1。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#&#123;HA配置目录&#125;/packages/aihome_template.yaml</span></span><br><span class="line"><span class="attr">homeassistant:</span> <span class="comment"># 用于生成音箱平台设备</span></span><br><span class="line">  <span class="attr">customize:</span></span><br><span class="line">    <span class="comment"># 一般设备，switch light fan input_boolean cover等</span></span><br><span class="line">    <span class="attr">input_boolean.aihome_demo_light:</span>                                    <span class="comment"># 平台已有设备的entity_id。开关类的是switch.xxx，灯类的是light.xxx，HA左侧开发者工具第二个图标可以查看当前HA所有的entities。</span></span><br><span class="line">      <span class="attr">friendly_name:</span> <span class="string">厨房灯</span>                                             <span class="comment"># 设备别名，小度音箱和叮咚音箱使用这个名称进行控制</span></span><br><span class="line">      <span class="attr">aihome_device:</span> <span class="literal">True</span>                                               <span class="comment"># 该设备可被发现</span></span><br><span class="line">      <span class="comment"># 天猫精灵专用 &lt;测试指令：打开/关闭厨房灯&gt;</span></span><br><span class="line">      <span class="attr">aligenie_deviceName:</span> <span class="string">灯</span>                                             <span class="comment"># 设备品类别名，https://open.bot.tmall.com/oauth/api/aliaslist</span></span><br><span class="line">      <span class="attr">aligenie_zone:</span> <span class="string">厨房</span>                                                 <span class="comment"># 房间名，https://open.bot.tmall.com/oauth/api/placelist</span></span><br><span class="line">      <span class="attr">aligenie_deviceType:</span> <span class="string">light</span>                                          <span class="comment"># 设备品类，https://doc-bot.tmall.com/docs/doc.htm?treeId=393&amp;articleId=108271&amp;docType=1</span></span><br><span class="line">      <span class="attr">aligenie_actions:</span> [<span class="string">&quot;TurnOn&quot;</span>, <span class="string">&quot;TurnOff&quot;</span>]                             <span class="comment"># 指定设备支持的操作，https://doc-bot.tmall.com/docs/doc.htm?spm=0.7629140.0.0.2b131780Fl14V8&amp;treeId=393&amp;articleId=108264&amp;docType=1</span></span><br><span class="line">      <span class="comment"># 小度音箱专用 &lt;测试指令：打开/关闭厨房灯&gt;</span></span><br><span class="line">      <span class="attr">dueros_deviceType:</span> <span class="string">&#x27;LIGHT&#x27;</span>                                          <span class="comment"># 指定设备类型，https://dueros.baidu.com/didp/doc/dueros-bot-platform/dbp-smart-home/protocol/discovery-message_markdown</span></span><br><span class="line">      <span class="attr">dueros_actions:</span> [<span class="string">&#x27;turnOn&#x27;</span>, <span class="string">&#x27;turnOff&#x27;</span>]                               <span class="comment"># 指定设备支持操作，https://dueros.baidu.com/didp/doc/dueros-bot-platform/dbp-smart-home/protocol/control-message_markdown</span></span><br><span class="line">      <span class="comment"># 叮咚音箱专用 &lt;测试指令：打开/关闭厨房灯&gt;</span></span><br><span class="line">      <span class="attr">jdwhale_deviceType:</span> <span class="string">&#x27;SWITCH&#x27;</span>                                        <span class="comment"># 指定设备类型，http://jdwhale.jd.com/Docs/skillManager#shebeifaxianfanhui</span></span><br><span class="line">      <span class="attr">jdwhale_actions:</span> [<span class="string">&#x27;TurnOn&#x27;</span>, <span class="string">&#x27;TurnOff&#x27;</span>, <span class="string">&#x27;Query&#x27;</span>, <span class="string">&#x27;QueryPowerState&#x27;</span>]  <span class="comment"># 指定设备支持操作，http://jdwhale.jd.com/Docs/skillManager#dakaishebei</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 环境类传感器，虚拟的sensor</span></span><br><span class="line">    <span class="attr">sensor.aihome_demo_sensor:</span></span><br><span class="line">      <span class="attr">friendly_name:</span> <span class="string">客厅传感器</span></span><br><span class="line">      <span class="attr">aihome_device:</span> <span class="literal">True</span></span><br><span class="line">      <span class="attr">aihome_sensor_group:</span> <span class="string">group.aihome_demo_sensors</span> <span class="comment"># 关联一个传感器分组，从分组的真实传感器取数据</span></span><br><span class="line">      <span class="comment"># 天猫精灵专用 &lt;测试指令：查询客厅传感器的温度/湿度&gt;</span></span><br><span class="line">      <span class="attr">aligenie_deviceName:</span> <span class="string">传感器</span></span><br><span class="line">      <span class="attr">aligenie_zone:</span> <span class="string">客厅</span> </span><br><span class="line">      <span class="attr">aligenie_deviceType:</span> <span class="string">sensor</span> <span class="comment"># 可自动识别，可省略</span></span><br><span class="line">      <span class="attr">aligenie_actions:</span> [<span class="string">&#x27;Query&#x27;</span>, <span class="string">&#x27;QueryTemperature&#x27;</span>, <span class="string">&#x27;QueryHumidity&#x27;</span>] <span class="comment"># 只测试查询温度、湿度</span></span><br><span class="line">      <span class="comment"># 小度音箱专用 &lt;测试指令：查询客厅传感器的温度/湿度&gt;</span></span><br><span class="line">      <span class="attr">dueros_deviceType:</span> <span class="string">AIR_MONITOR</span> <span class="comment"># 无传感器类别，默认为空气监测器类设备，可省略</span></span><br><span class="line">      <span class="attr">dueros_actions:</span> [<span class="string">&quot;getTemperatureReading&quot;</span>, <span class="string">&quot;getHumidity&quot;</span>] <span class="comment"># 只测试查询温度、湿度</span></span><br><span class="line">      <span class="comment"># 叮咚音箱专用 &lt;测试指令：查询客厅传感器的温度/湿度&gt;</span></span><br><span class="line">      <span class="attr">jdwhale_deviceType:</span> <span class="string">AIR_CLEANER</span> <span class="comment"># 无传感器类别，默认为空气净化器类设备，可省略</span></span><br><span class="line">      <span class="attr">jdwhale_actions:</span> [<span class="string">&#x27;Query&#x27;</span>, <span class="string">&#x27;QueryTemperature&#x27;</span>, <span class="string">&#x27;QueryHumidity&#x27;</span>] <span class="comment"># 只测试查询温度、湿度</span></span><br><span class="line">    <span class="comment"># 真实传感器</span></span><br><span class="line">    <span class="attr">sensor.aihome_demo_temperature:</span></span><br><span class="line">      <span class="attr">aihome_sensor:</span> <span class="literal">True</span>     <span class="comment"># 上报传感器数据，注意不参与直接上报，不需要再设置aihome_device</span></span><br><span class="line">    <span class="comment"># 真实传感器</span></span><br><span class="line">    <span class="attr">sensor.aihome_demo_humidity:</span></span><br><span class="line">      <span class="attr">aihome_sensor:</span> <span class="literal">True</span>     <span class="comment"># 上报传感器数据，注意不参与直接上报，不需要再设置aihome_device</span></span><br><span class="line"></span><br><span class="line"><span class="attr">group:</span></span><br><span class="line">  <span class="comment"># 新增，传感器分组</span></span><br><span class="line">  <span class="attr">aihome_demo_sensors:</span></span><br><span class="line">    <span class="attr">view:</span> <span class="literal">no</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">&#x27;客厅传感器列表&#x27;</span></span><br><span class="line">    <span class="attr">control:</span> <span class="string">hidden</span></span><br><span class="line">    <span class="attr">entities:</span>  <span class="comment"># 关联真实传感器列表</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">sensor.aihome_demo_temperature</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">sensor.aihome_demo_humidity</span></span><br><span class="line"></span><br><span class="line"><span class="attr">sensor:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">platform:</span> <span class="string">template</span></span><br><span class="line">    <span class="attr">sensors:</span></span><br><span class="line">      <span class="comment"># 演示用</span></span><br><span class="line">      <span class="attr">aihome_demo_temperature:</span></span><br><span class="line">        <span class="attr">unit_of_measurement:</span> <span class="string">&#x27;°C&#x27;</span></span><br><span class="line">        <span class="attr">value_template:</span> <span class="string">&quot;20&quot;</span></span><br><span class="line">      <span class="comment"># 演示用</span></span><br><span class="line">      <span class="attr">aihome_demo_humidity:</span></span><br><span class="line">        <span class="attr">unit_of_measurement:</span> <span class="string">&#x27;%&#x27;</span></span><br><span class="line">        <span class="attr">value_template:</span> <span class="string">&quot;60&quot;</span></span><br><span class="line">      <span class="comment"># 新增，虚拟的sensor</span></span><br><span class="line">      <span class="attr">aihome_demo_sensor:</span></span><br><span class="line">        <span class="attr">value_template:</span> <span class="string">&quot;虚拟的传感器&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">input_boolean:</span></span><br><span class="line">  <span class="comment"># 演示用</span></span><br><span class="line">  <span class="attr">aihome_demo_light:</span></span><br></pre></td></tr></table></figure>

<h3 id="3-5-上报设备"><a href="#3-5-上报设备" class="headerlink" title="3.5.上报设备"></a>3.5.上报设备</h3><p>当HA中设备信息配置完毕后，需要上报信息给音箱平台。</p>
<ul>
<li>叮咚<br>重启HA触发上报。</li>
<li>天猫精灵<br>在APP中重新绑定触发上报。</li>
<li>小度<br>执行“发现设备”指令触发上报。</li>
</ul>
<h3 id="3-6-控制指令说明"><a href="#3-6-控制指令说明" class="headerlink" title="3.6.控制指令说明"></a>3.6.控制指令说明</h3><ul>
<li>叮咚<ul>
<li>打开/关闭<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#打开/关闭</span></span><br><span class="line"><span class="comment">#用途：一般为电源控制</span></span><br><span class="line"><span class="comment">#语义：打开/关闭&#123;设备名称&#125;</span></span><br><span class="line"><span class="comment">#例子：打开主卧灯</span></span><br></pre></td></tr></table></figure></li>
<li>查询状态<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#打开/关闭</span></span><br><span class="line"><span class="comment">#用途：查询设备状态</span></span><br><span class="line"><span class="comment">#语义：查询&#123;设备名称&#125;的&#123;状态/xx状态&#125;</span></span><br><span class="line"><span class="comment">#例子：查询主卧传感器的状态；查询主卧传感器的温度；查询主卧灯的电源状态</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：传感器信息需要挂靠到具体设备上进行查询。一般来说温度、湿度需要挂靠到空气净化器类型上。</strong></p>
</blockquote>
</li>
</ul>
</li>
<li>天猫精灵<ul>
<li>打开/关闭<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#打开/关闭</span></span><br><span class="line"><span class="comment">#用途：一般为电源控制</span></span><br><span class="line"><span class="comment">#语义：打开/关闭&#123;房间名&#125;的&#123;设备类型/别名&#125;</span></span><br><span class="line"><span class="comment">#例子：打开主卧的灯。</span></span><br><span class="line"><span class="comment">#备注：&#123;房间名&#125;、&#123;设备类型/别名&#125;需要指定，均为枚举值</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：优先匹配“位置（可为空）+别名”：例如有台灯、灯两个设备，“打开台灯”则精确匹配台灯；然后匹配“位置（可为空）+设备类型”，例如有一个台灯设备，“打开吸顶灯”、“打开床头灯”等都可控制。指令不带位置，如设备别名多个匹配，询问设备位置；当有相同匹配，一起执行。</strong></p>
</blockquote>
</li>
<li>查询状态<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#打开/关闭</span></span><br><span class="line"><span class="comment">#用途：查询设备状态</span></span><br><span class="line"><span class="comment">#语义：查询&#123;房间名&#125;&#123;设备类型/别名&#125;的&#123;状态/xx状态&#125;</span></span><br><span class="line"><span class="comment">#例子：查询主卧传感器的状态；查询主卧传感器的温度</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：查询传感器好像有个bug：查询所有状态不能正常播报；查询单个状态，发送的指令是查询所有状态的指令。</strong></p>
</blockquote>
</li>
</ul>
</li>
<li>小度<ul>
<li>打开/关闭<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#打开/关闭</span></span><br><span class="line"><span class="comment">#用途：一般为电源控制</span></span><br><span class="line"><span class="comment">#语义：打开/关闭&#123;设备名称&#125;</span></span><br><span class="line"><span class="comment">#例子：打开主卧灯</span></span><br><span class="line"><span class="string">```</span>   </span><br><span class="line"><span class="bullet">-</span> <span class="string">查询状态</span></span><br><span class="line"><span class="string">```yaml</span></span><br><span class="line"><span class="comment">#打开/关闭</span></span><br><span class="line"><span class="comment">#用途：查询设备状态</span></span><br><span class="line"><span class="comment">#语义：查询&#123;设备名称&#125;的&#123;xx状态&#125;</span></span><br><span class="line"><span class="comment">#例子：查询主卧传感器的温度</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：只能查询单一状态。</strong></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><ul>
<li>重新对各音箱平台智能家居指令进行分析，目前智能音箱插件功能实现度还有比较大的改进空间，但不同音箱如何统一整合还要好好考虑。</li>
<li>对原有多用户场景下mqtt消息发送、处理方式进行了重构。</li>
</ul>
]]></content>
      <categories>
        <category>Home Assistant</category>
      </categories>
      <tags>
        <tag>Home Assistant</tag>
        <tag>插件</tag>
        <tag>智能音箱</tag>
      </tags>
  </entry>
  <entry>
    <title>【插件】智能音箱接入Home Assistant整合PlusPlus</title>
    <url>/articles/plugin-smart-speaker-access-home-assistant-integration-plusplus/</url>
    <content><![CDATA[<p>自从上一版实现了不用重启可以更新设备信息，后来发现可以通过HA集成管理的页面实现不重启修改插件配置，于是乎折腾实现了，然后想着既然插件配置能用UI管理了，干脆也把设备信息管理UI化管理吧。一开始计划是弄个在线文本编辑器直接编辑的，某天逛论坛看到<a href="https://bbs.hassbian.com/thread-9218-1-1.html" title="[插件发布] 在HA里使用的文件管理器">jiluxinqing大大的帖子</a>已经有成品了，然后研究了下学习到了前后端交互的方法，干脆就把以前的设备管理页面改造改造给用上了。这个版本也算是实现从“能用”到“易用”的一个跨越。</p>
<hr>
<a id="more"></a>
<h2 id="0-插件说明"><a href="#0-插件说明" class="headerlink" title="0. 插件说明"></a>0. 插件说明</h2><p>此为HAVCS(Home Assistant Voice Control Skill)v3版本，主要改动：</p>
<ul>
<li>增加集成方式管理插件配置，无需重启HA</li>
<li>增加web管理设备页面</li>
<li>调整设备的信息属性设计和生成逻辑，作为集成的“设备”呈现而不是“组件”呈现</li>
<li>增加授权页面（可自定义客户端ID）&gt;&gt;*2020.04.05增加</li>
<li>调整各服务url进同一层级（/havcs/）&gt;&gt;*2020.04.05增加</li>
</ul>
<hr>
<h2 id="1-使用说明"><a href="#1-使用说明" class="headerlink" title="1. 使用说明"></a>1. 使用说明</h2><h3 id="1-1-APP的技能方式接入"><a href="#1-1-APP的技能方式接入" class="headerlink" title="1.1. APP的技能方式接入"></a>1.1. APP的技能方式接入</h3><p>使用官方APP技能，配合havcs服务可实现免公网IP接入。</p>
<ul>
<li>下载<a href="https://github.com/cnk700i/havcs" title="havcs插件">havcs插件</a>，放置到HA自定义插件目录，最终路径结构为<code>&#123;HA配置目录&#125;/custom_components/havcs/__init__.py</code>。</li>
<li>前往<a href="https://havcs.ljr.im/account/" title="havcs账号">havcs服务页面</a>注册账号，获取AppKey和AppSecret（先登录再生成，生成后记得保存）。</li>
<li>打开音箱APP（天猫精灵、小度、叮咚音箱/小京鱼）-&gt; 搜索找到’havcs’技能 -&gt; 关联账号 -&gt; 输入注册的账号信息登录。</li>
<li>配置Home Assistant<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># &#123;HA配置目录&#125;/configuration.yaml</span></span><br><span class="line"><span class="attr">havcs:</span></span><br><span class="line">  <span class="attr">platform:</span>                               <span class="comment"># 音箱平台服务网关，至少启用一个</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">aligenie</span>                            <span class="comment"># 天猫精灵</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">dueros</span>                              <span class="comment"># 小度</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">jdwhale</span>                             <span class="comment"># 叮咚</span></span><br><span class="line">  <span class="attr">skill:</span></span><br><span class="line">    <span class="attr">bind_device:</span> <span class="literal">True</span>                     <span class="comment"># 是否启动时更新设备绑定信息。不设置默认True（叮咚音箱才有效）&gt;&gt;*新版本加入&lt;&lt;</span></span><br><span class="line">    <span class="attr">sync_device:</span> <span class="literal">False</span>                    <span class="comment"># 是否主动上报设备状态。不设置默认False（小度音箱才有效）</span></span><br><span class="line">  <span class="comment"># mqtt相关设置，启用http代理服务及APP技能服务才生效</span></span><br><span class="line">  <span class="attr">setting:</span></span><br><span class="line">    <span class="attr">app_key:</span> <span class="string">your_app_key</span>                 <span class="comment"># 注册账号获取的AppKey</span></span><br><span class="line">    <span class="attr">app_secret:</span> <span class="string">your_app_secret</span>           <span class="comment"># 注册账号获取的AppSecret</span></span><br><span class="line">    <span class="attr">entity_key:</span> <span class="string">your_entity_key</span>           <span class="comment"># 加密entity_id的key，自定义16个字符。不设置则不加密</span></span><br><span class="line">  <span class="attr">device_config:</span> <span class="string">ui</span>                       <span class="comment"># 设备管理模式，text为原来文本编辑，ui为启用web管理页面。不设置默认text &gt;&gt;*新版本调整&lt;&lt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p><strong>WARN：新版本调整 device_config由原来设置设备信息文件路径更改为设置设备管理模式，设备信息文件保存路径{HA配置目录}/havcs.yaml或havcs-ui.yaml。</strong></p>
</blockquote>
<ul>
<li>配置设备信息<br>目前支持两种管理方式，这里以文本编辑模式介绍，具体属性名称见<code>2.设备信息属性说明</code>章节，web管理方式见<code>4.UI管理</code>章节<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置文件整体结构（&#123;HA配置目录&#125;/havcs.yaml）</span></span><br><span class="line"><span class="string">设备1的device_id:</span> <span class="comment"># 格式havcs.xxx</span></span><br><span class="line">  <span class="string">属性1:</span></span><br><span class="line">  <span class="string">属性2:</span></span><br><span class="line"><span class="string">设备2的device_id:</span></span><br><span class="line">  <span class="string">属性1:</span></span><br><span class="line">  <span class="string">属性2:</span></span><br><span class="line"><span class="string">设备N的device_id:</span></span><br><span class="line">  <span class="string">属性1:</span></span><br><span class="line">  <span class="string">属性2:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个设备配置样例</span></span><br><span class="line"><span class="attr">havcs.a_demo_light:</span></span><br><span class="line">  <span class="attr">entity_id:</span> <span class="string">light.demo</span> <span class="comment"># 关联真实设备</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">主卧灯</span></span><br><span class="line">  <span class="attr">zone:</span> <span class="string">主卧</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p><strong>WARN：新版本调整 顶层id由entity_id更改为可自定义的device_id，entity_id放到属性中去。</strong></p>
</blockquote>
<blockquote>
<p><strong>INFO：请确保HA中该设备已正常接入（开发者工具-&gt;状态有该设备的entity_id）,sensor.类型除外。</strong></p>
</blockquote>
<ul>
<li>更新音箱平台设备信息<ul>
<li>先重载本地信息：调用服务（HA web-&gt;开发者工具-&gt;服务-&gt;调用havcs.reload）或者重启HA</li>
<li>叮咚：首次通过APP重新绑定账号触发更新，后续可通过重载本地信息触发上报更新（bind_device配置为True）。</li>
<li>天猫精灵：APP中重新绑定触发更新。</li>
<li>小度：执行“发现设备”指令触发更新。</li>
</ul>
</li>
</ul>
<h3 id="1-2-自建技能方式接入"><a href="#1-2-自建技能方式接入" class="headerlink" title="1.2. 自建技能方式接入"></a>1.2. 自建技能方式接入</h3><ul>
<li>音箱技能配置见<a href="https://ljr.im/articles/plugins-havcs-edible-instructions/" title="【插件】HAVCS食用说明">总教程</a></li>
<li>配置Home Assistant<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># &#123;HA配置目录&#125;/configuration.yaml</span></span><br><span class="line"><span class="attr">havcs:</span></span><br><span class="line">  <span class="attr">platform:</span>                               <span class="comment"># 音箱平台服务网关，至少启用一个</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">aligenie</span>                            <span class="comment"># 天猫精灵</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">dueros</span>                              <span class="comment"># 小度</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">jdwhale</span>                             <span class="comment"># 叮咚</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">    <span class="attr">clients:</span>                              <span class="comment"># 音箱平台客户端认证信息，其节点下的键值对代表&quot;client_id: client_secret&quot;，其中client_id起始字符会匹配音箱平台，音箱平台上设置要与此处设置一致</span></span><br><span class="line">      <span class="string">dueros&#123;自定义字符&#125;:</span> &#123;<span class="string">自定义密码</span>&#125;      <span class="comment"># 小度平台认证信息，样例：duerosdemo:123 代表client_id为duerosdemo，client_secret为123</span></span><br><span class="line">      <span class="string">aligenie&#123;自定义字符&#125;:</span> &#123;<span class="string">自定义密码</span>&#125;    <span class="comment"># 天猫精灵平台认证信息，样例：aligeniedemo:123 代表client_id为aligeniedemo，client_secret为123</span></span><br><span class="line">      <span class="string">jdwhale&#123;自定义字符&#125;:</span> &#123;<span class="string">自定义密码</span>&#125;     <span class="comment"># 叮咚平台认证信息，样例：jdwhaledemo: 123 代表client_id为jdwhaledemo，client_secret为123</span></span><br><span class="line">      <span class="attr">use_ha_auth_html:</span> <span class="number">123</span>               <span class="comment"># 如果不使用插件授权页面，随意设置一个键值对</span></span><br><span class="line">    <span class="attr">ha_url:</span> <span class="string">http://localhost:8123</span>         <span class="comment"># HA主机本地访问地址，如果HA没配置base_url（http:组件里），可自动识别不用设置；否则设置http://localhost:&#123;端口号&#125; 或 https://localhost:&#123;端口号&#125;（HA启用ssl）</span></span><br><span class="line">    <span class="attr">expire_in_hours:</span> <span class="number">24</span>                   <span class="comment"># token超时时间，单位小时，不设置则默认24h</span></span><br><span class="line">  <span class="attr">device_config:</span> <span class="string">ui</span>                       <span class="comment"># 设备管理模式，text为原来文本编辑，ui为启用web管理页面。不设置默认text &gt;&gt;*新版本调整&lt;&lt;</span></span><br></pre></td></tr></table></figure></li>
<li>配置设备信息及更新音箱平台设备信息同<code>1.1.APP的技能方式接入</code>章节。</li>
</ul>
<hr>
<h2 id="2-设备信息属性说明"><a href="#2-设备信息属性说明" class="headerlink" title="2. 设备信息属性说明"></a>2. 设备信息属性说明</h2><p>支持文本编辑（<code>&#123;HA配置目录&#125;/havcs.yaml</code>）或web管理页面配置设备信息，用于生成音箱平台的设备（绑定设备）。</p>
<ul>
<li>设备统一使用属性进行配置，属性列表如下：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">属性名</th>
<th align="center">描述</th>
<th align="center">取值</th>
<th align="center">样例</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">havcs_visable</td>
<td align="center">设备可见性</td>
<td align="center">[‘aligenie’, ‘dueros’, ‘jdwhale’]</td>
<td align="center">[‘aligenie’, ‘dueros’]</td>
<td align="center">设置该属性则设备只对指定平台可见；如不设置，对所有平台可见</td>
</tr>
<tr>
<td align="center">havcs_device_name</td>
<td align="center">设备名称</td>
<td align="center"><a href="https://open.bot.tmall.com/oauth/api/aliaslist" title="天猫精灵设备名称">*天猫精灵限制</a></td>
<td align="center">客厅灯</td>
<td align="center">必填，建议“房间”+“设备类型”可以兼容三个平台使用</td>
</tr>
<tr>
<td align="center">havcs_zone</td>
<td align="center">设备位置</td>
<td align="center"><a href="https://open.bot.tmall.com/oauth/api/placelist" title="天猫精灵位置">*天猫精灵限制</a></td>
<td align="center">客厅</td>
<td align="center">天猫精灵必填，其它可不用指定</td>
</tr>
<tr>
<td align="center">havcs_device_type</td>
<td align="center">设备类型</td>
<td align="center">light /switch /sensor /input_boolean</td>
<td align="center">light</td>
<td align="center">一般不用指定</td>
</tr>
<tr>
<td align="center">havcs_attributes</td>
<td align="center">属性</td>
<td align="center">[‘temperature’, ‘brightness’, ‘humidity’, ‘pm25’, ‘co2’, ‘power_state’]</td>
<td align="center">[‘power_state’]</td>
<td align="center">一般不用指定</td>
</tr>
<tr>
<td align="center">havcs_actions</td>
<td align="center">支持操作</td>
<td align="center">[‘turn_on’, ‘turn_off’, ‘timing_turn_on’, ‘timing_turn_off’, ‘query_temperature’, ‘query_humidity’, ‘increase_brightness’, ‘decrease_brightness’]</td>
<td align="center">[‘turn_on’, ‘turn_off’]</td>
<td align="center">一般不用指定</td>
</tr>
<tr>
<td align="center">havcs_related_sensors</td>
<td align="center">传感器设备专用，关联真实传感器</td>
<td align="center">sensor/group列表</td>
<td align="center">[‘sensor.demo’, ‘group.demo’]</td>
<td align="center">支持设置group，会搜索加入该分组下的sensor</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>WARN：新版本调整 增加entity_id；传感器删除related_sensors改用entity_id关联；属性名称简化掉havcs_开头。</strong></p>
</blockquote>
<blockquote>
<p><strong>INFO：属性字典的格式为”属性名: 取值”，需要有1个空格间隔。</strong></p>
</blockquote>
<h3 id="2-1-自定义指令操作"><a href="#2-1-自定义指令操作" class="headerlink" title="2.1. 自定义指令操作"></a>2.1. 自定义指令操作</h3><p>可通过设置actions属性，实现指定指令调用自定义的service。</p>
<ul>
<li><p>actions属性中设置对应的service指令（只能设置turn_on/turn_off/timing_turn_on/timing_turn_off/increase_brightness/decrease_brightness，对应打开/关闭/延时打开/延时关闭/调高亮度/调低亮度指令）</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#&#123;HA配置目录&#125;/havcs.yaml</span></span><br><span class="line"><span class="attr">havcs.a_demo_call_service:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">客厅灯</span></span><br><span class="line">  <span class="attr">zone:</span> <span class="string">客厅</span></span><br><span class="line">  <span class="comment">#↓↓↓指令根据实际需要配置↓↓↓</span></span><br><span class="line">  <span class="attr">havcs_actions:</span></span><br><span class="line">      <span class="comment"># service指令格式:[domain, service_name, service_data（json字符串）]，具体内容需参见相应组件的服务定义。</span></span><br><span class="line">      <span class="comment"># 注意，参数变更为数组以支持多条指令，单条指令也别忘了加-</span></span><br><span class="line">      <span class="attr">turn_on:</span></span><br><span class="line">        <span class="bullet">-</span> [<span class="string">&#x27;common_timer&#x27;</span>, <span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;&#123;&quot;entity_id&quot;:&quot;switch.demo&quot;,&quot;duration&quot;:&quot;01:00:00&quot;,&quot;operation&quot;:&quot;off&quot;&#125;&#x27;</span>] <span class="comment"># 打开命令</span></span><br><span class="line">        <span class="bullet">-</span> [<span class="string">&#x27;input_boolean&#x27;</span>, <span class="string">&#x27;turn_on&#x27;</span>, <span class="string">&#x27;&#123;&#125;&#x27;</span>] <span class="comment"># 同步打开状态</span></span><br><span class="line">      <span class="attr">turn_off:</span></span><br><span class="line">        <span class="bullet">-</span> [<span class="string">&#x27;common_timer&#x27;</span>, <span class="string">&#x27;cancel&#x27;</span>, <span class="string">&#x27;&#123;&quot;entity_id&quot;:&quot;switch.demo&quot;&#125;&#x27;</span>] <span class="comment"># 关闭命令</span></span><br><span class="line">        <span class="bullet">-</span> [<span class="string">&#x27;input_boolean&#x27;</span>, <span class="string">&#x27;turn_off&#x27;</span>, <span class="string">&#x27;&#123;&#125;&#x27;</span>] <span class="comment"># 同步关闭状态</span></span><br><span class="line">      <span class="attr">timing_turn_on:</span>         <span class="comment"># 延时打开指令（小度音箱）</span></span><br><span class="line">        <span class="bullet">-</span> [<span class="string">&#x27;指令1&#x27;</span>]</span><br><span class="line">        <span class="bullet">-</span> [<span class="string">&#x27;指令2&#x27;</span>]</span><br><span class="line">      <span class="attr">timing_turn_off:</span>        <span class="comment"># 延时关闭指令（小度音箱）</span></span><br><span class="line">        <span class="bullet">-</span> [<span class="string">&#x27;指令1&#x27;</span>]</span><br><span class="line">        <span class="bullet">-</span> [<span class="string">&#x27;指令2&#x27;</span>]</span><br><span class="line">      <span class="attr">increase_brightness:</span></span><br><span class="line">        <span class="bullet">-</span> [<span class="string">&#x27;指令1&#x27;</span>]</span><br><span class="line">        <span class="bullet">-</span> [<span class="string">&#x27;指令2&#x27;</span>]</span><br><span class="line">      <span class="attr">decrease_brightness:</span></span><br><span class="line">        <span class="bullet">-</span> [<span class="string">&#x27;指令1&#x27;</span>]</span><br><span class="line">        <span class="bullet">-</span> [<span class="string">&#x27;指令2&#x27;</span>]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p><strong>INFO：调自动化(automation.turn_on)、调脚本(scrpit.turn_on)、调红外指令(climate.xiaomi_miio_send_command)等会比较适合。</strong></p>
</blockquote>
<blockquote>
<p><strong>INFO：天猫精灵无法自定义名称，不太适合使用。</strong></p>
</blockquote>
<hr>
<h2 id="3-完成度"><a href="#3-完成度" class="headerlink" title="3. 完成度"></a>3. 完成度</h2><p>目前完成度有些低，后续再继续测试完善吧。</p>
<ul>
<li>图例：✓ 支持，- 不支持，* 待测试</li>
<li>switch/cover</li>
</ul>
<table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">描述</th>
<th align="center">aligenie</th>
<th align="center">dueros</th>
<th align="center">jdwhale</th>
</tr>
</thead>
<tbody><tr>
<td align="center">turn_on</td>
<td align="center">打开</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
</tr>
<tr>
<td align="center">turn_off</td>
<td align="center">关闭</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
</tr>
<tr>
<td align="center">timing_turn_on</td>
<td align="center">延时打开</td>
<td align="center">-</td>
<td align="center">✓</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">timing_turn_off</td>
<td align="center">延时关闭</td>
<td align="center">-</td>
<td align="center">✓</td>
<td align="center">-</td>
</tr>
</tbody></table>
<ul>
<li>light</li>
</ul>
<table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">描述</th>
<th align="center">aligenie</th>
<th align="center">dueros</th>
<th align="center">jdwhale</th>
</tr>
</thead>
<tbody><tr>
<td align="center">turn_on</td>
<td align="center">打开</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
</tr>
<tr>
<td align="center">turn_off</td>
<td align="center">关闭</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
</tr>
<tr>
<td align="center">timing_turn_on</td>
<td align="center">延时打开</td>
<td align="center">-</td>
<td align="center">✓</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">timing_turn_off</td>
<td align="center">延时关闭</td>
<td align="center">-</td>
<td align="center">✓</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">set_brightness</td>
<td align="center">设置亮度</td>
<td align="center">*</td>
<td align="center">*</td>
<td align="center">*</td>
</tr>
<tr>
<td align="center">increase_brightness</td>
<td align="center">调高亮度</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
</tr>
<tr>
<td align="center">decrease_brightness</td>
<td align="center">调低亮度</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
</tr>
<tr>
<td align="center">set_color</td>
<td align="center">设置颜色</td>
<td align="center">*</td>
<td align="center">✓</td>
<td align="center">*</td>
</tr>
</tbody></table>
<ul>
<li>sensor</li>
</ul>
<table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">描述</th>
<th align="center">aligenie</th>
<th align="center">dueros</th>
<th align="center">jdwhale</th>
</tr>
</thead>
<tbody><tr>
<td align="center">query_temperature</td>
<td align="center">查询温度</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
</tr>
<tr>
<td align="center">query_humidity</td>
<td align="center">查询湿度</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
</tr>
</tbody></table>
<ul>
<li>inpu_boolean</li>
</ul>
<table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">描述</th>
<th align="center">aligenie</th>
<th align="center">dueros</th>
<th align="center">jdwhale</th>
</tr>
</thead>
<tbody><tr>
<td align="center">turn_on</td>
<td align="center">打开</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
</tr>
<tr>
<td align="center">turn_off</td>
<td align="center">关闭</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
</tr>
<tr>
<td align="center">timing_turn_on</td>
<td align="center">延时打开</td>
<td align="center">-</td>
<td align="center">✓</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">timing_turn_off</td>
<td align="center">延时关闭</td>
<td align="center">-</td>
<td align="center">✓</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">increase_brightness</td>
<td align="center">调高亮度</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
</tr>
<tr>
<td align="center">decrease_brightness</td>
<td align="center">调低亮度</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>INFO：延时打开/关闭需配合<a href="https://ljr.im/articles/plugin-home-assistant-universal-timer-upgraded/" title="【插件】Home Assistant通用定时器（升级版）">通用定时器插件</a>实现。</strong></p>
</blockquote>
<hr>
<h2 id="4-控制指令说明"><a href="#4-控制指令说明" class="headerlink" title="4. 控制指令说明"></a>4. 控制指令说明</h2><ul>
<li><p>叮咚</p>
<ul>
<li>打开/关闭<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#打开/关闭</span></span><br><span class="line"><span class="comment">#用途：一般为电源控制</span></span><br><span class="line"><span class="comment">#语义：打开/关闭&#123;设备名称&#125;</span></span><br><span class="line"><span class="comment">#例子：打开主卧灯</span></span><br></pre></td></tr></table></figure></li>
<li>查询状态<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#打开/关闭</span></span><br><span class="line"><span class="comment">#用途：查询设备状态</span></span><br><span class="line"><span class="comment">#语义：查询&#123;设备名称&#125;的&#123;状态/xx状态&#125;</span></span><br><span class="line"><span class="comment">#例子：查询主卧传感器的状态；查询主卧传感器的温度；查询主卧灯的电源状态</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：传感器信息需要挂靠到具体设备上进行查询。一般来说温度、湿度需要挂靠到空气净化器类型上。</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><p>天猫精灵</p>
<ul>
<li><p>打开/关闭</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#打开/关闭</span></span><br><span class="line"><span class="comment">#用途：一般为电源控制</span></span><br><span class="line"><span class="comment">#语义：打开/关闭&#123;房间名&#125;的&#123;设备类型/别名&#125;</span></span><br><span class="line"><span class="comment">#例子：打开主卧的灯。</span></span><br><span class="line"><span class="comment">#备注：&#123;房间名&#125;、&#123;设备类型/别名&#125;需要指定，均为枚举值</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：优先匹配“位置（可为空）+别名”：例如有台灯、灯两个设备，“打开台灯”则精确匹配台灯；然后匹配“位置（可为空）+设备类型”，例如有一个台灯设备，“打开吸顶灯”、“打开床头灯”等都可控制。指令不带位置，如设备别名多个匹配，询问设备位置；当有相同匹配，一起执行。</strong></p>
</blockquote>
</li>
<li><p>查询状态</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#打开/关闭</span></span><br><span class="line"><span class="comment">#用途：查询设备状态</span></span><br><span class="line"><span class="comment">#语义：查询&#123;房间名&#125;&#123;设备类型/别名&#125;的&#123;状态/xx状态&#125;</span></span><br><span class="line"><span class="comment">#例子：查询主卧传感器的状态；查询主卧传感器的温度</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：查询传感器好像有个bug：查询所有状态不能正常播报；查询单个状态，发送的指令是查询所有状态的指令。</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><p>小度</p>
<ul>
<li>打开/关闭<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#打开/关闭</span></span><br><span class="line"><span class="comment">#用途：一般为电源控制</span></span><br><span class="line"><span class="comment">#语义：打开/关闭&#123;设备名称&#125;</span></span><br><span class="line"><span class="comment">#例子：打开主卧灯</span></span><br></pre></td></tr></table></figure></li>
<li>查询状态<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#打开/关闭</span></span><br><span class="line"><span class="comment">#用途：查询设备状态</span></span><br><span class="line"><span class="comment">#语义：查询&#123;设备名称&#125;的&#123;xx状态&#125;/&#123;设备名称&#125;查询&#123;xx状态&#125;</span></span><br><span class="line"><span class="comment">#例子：查询主卧传感器的温度/主卧传感器查询温度</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO：只能查询单一状态。</strong></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="5-UI管理"><a href="#5-UI管理" class="headerlink" title="5. UI管理"></a>5. UI管理</h2><ul>
<li>启停插件/修改插件配置<br>1.进入集成管理界面<br>WEB界面-&gt;侧边栏<code>配置</code>-&gt;集成<br>2.新增配置<br>点右下角加号-&gt;搜索HAVCS，按界面提示新增配置<br>3.修改配置<br>删除后再新增：集成页面点击<code>HAVCS: 主配置</code>-&gt;右上角删除；或直接新增也会提示删除</li>
</ul>
<blockquote>
<p><strong>WARN：通过集成管理web页面进行的设置优先级别更高会覆盖配置文件的设置，具体生效配置可以在havcs设备管理页面-&gt;工具栏”插件配置”查看。</strong></p>
</blockquote>
<ul>
<li>设备信息管理<br>1.进入管理页面<br>WEB界面-&gt;侧边栏<code>HAVCS设备</code><br>2.编辑后，需要点击菜单栏的同步设备按钮或执行一次<code>havcs.reload</code>服务才能加载新的设备信息</li>
</ul>
<blockquote>
<p><strong>INFO：web管理设备信息只是取代之前的文本编辑，刷新设备信息的步骤暂时不变，设备信息会保存至{HA配置目录}/havcs-ui.yaml。</strong></p>
</blockquote>
<hr>
<h2 id="6-调试说明"><a href="#6-调试说明" class="headerlink" title="6. 调试说明"></a>6. 调试说明</h2><ul>
<li>把havcs插件日志级别提高，过滤其它插件输出日志，方便观察日志输出，调试后注意恢复<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># [HA配置目录]/configuration.yaml</span></span><br><span class="line"><span class="attr">logger:</span></span><br><span class="line">  <span class="attr">default:</span> <span class="string">error</span>  <span class="comment"># 提高所有组件的默认级别，调试完后改回info（预设）</span></span><br><span class="line">  <span class="attr">logs:</span>           <span class="comment"># 设定指定组件的级别，debug有更详细的输出</span></span><br><span class="line">    <span class="attr">custom_components.havcs:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure>
1.根据<a href="https://ljr.im/articles/home-assistant-novice-question-set/#3-%E8%B0%83%E8%AF%95%E5%8F%8A%E6%9F%A5%E7%9C%8B%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%A5%E5%BF%97" title="调试及查看程序运行日志">教程</a>调整插件的调试级别查看详细的运行日志<br>2.配置好插件，启动HA后，观看是否有mqtt连接成功信息（app技能接入方式） —排查插件配置信息<br>3.授权过程，观看是否有相关的处理日志 —排查授权服务<br>4.说音响指令后，观看是否有相关的处理日志 —排查语音平台接入<br>5.web页面-&gt;开发者工具-&gt;服务-&gt;havcs.reload，观看是否生成设备信息 —排查havcs.yaml设备配置信息</li>
</ul>
<blockquote>
<p><strong>WARN: 如需要帮助，请提供以上步骤相对应的日志信息方便定位原因。</strong></p>
</blockquote>
<hr>
<h2 id="7-小结"><a href="#7-小结" class="headerlink" title="7. 小结"></a>7. 小结</h2><ul>
<li>发现集成（Integration）这个新大陆，又被迫读了不少代码去分析，补充了HA的组件加载过程链的知识盲区。</li>
<li>使用Vue改造了以前的设备管理页面实现了单页面管理，感觉效果还可以。</li>
</ul>
]]></content>
      <categories>
        <category>Home Assistant</category>
      </categories>
      <tags>
        <tag>Home Assistant</tag>
        <tag>插件</tag>
        <tag>智能音箱</tag>
      </tags>
  </entry>
</search>
